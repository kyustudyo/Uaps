<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® Unity RTS Game - Architecture Document</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #0084ff;
            --secondary-color: #00c9a7;
            --danger-color: #ff5252;
            --warning-color: #ffab00;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-color: #333333;
            --text-muted: #6c757d;
            --border-color: #dee2e6;
            --code-bg: #f4f4f4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1, h2, h3, h4 {
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: 700;
        }

        h1 {
            font-size: 2.5em;
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 15px;
            margin-bottom: 30px;
        }

        h2 {
            font-size: 2em;
            color: var(--secondary-color);
            border-left: 4px solid var(--secondary-color);
            padding-left: 15px;
        }

        h3 {
            font-size: 1.5em;
            color: var(--primary-color);
        }

        h4 {
            font-size: 1.2em;
            color: var(--text-color);
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        .tldr {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 1.1em;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .summary-box {
            background: var(--bg-color);
            border-left: 4px solid var(--primary-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .icon {
            display: inline-block;
            margin-right: 8px;
        }

        .folder-tree {
            background: var(--code-bg);
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 20px 0;
        }

        .diagram-container {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .diagram-explanation {
            background: #fff8e1;
            border-left: 4px solid var(--warning-color);
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
            font-style: italic;
        }

        .diagram-explanation::before {
            content: "ğŸ§’ Like I'm 10: ";
            font-weight: bold;
            font-style: normal;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background-color: var(--bg-color);
        }

        code {
            background-color: var(--code-bg);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: var(--code-bg);
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
        }

        pre code {
            background: none;
            padding: 0;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }

        li {
            margin-bottom: 10px;
            line-height: 1.8;
        }

        .warning-box {
            background-color: #fff3cd;
            border: 1px solid var(--warning-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .danger-box {
            background-color: #f8d7da;
            border: 1px solid var(--danger-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .success-box {
            background-color: #d4edda;
            border: 1px solid var(--secondary-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        details {
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        summary {
            cursor: pointer;
            font-weight: 600;
            padding: 10px;
            background: white;
            border-radius: 4px;
            margin: -15px -15px 15px -15px;
            transition: all 0.3s ease;
        }

        summary:hover {
            background: var(--bg-color);
        }

        .toc {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            color: white;
        }

        .toc a {
            color: white;
            text-decoration: none;
            display: block;
            padding: 8px 0;
            transition: all 0.3s ease;
        }

        .toc a:hover {
            padding-left: 10px;
            font-weight: 600;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-right: 8px;
        }

        .badge-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .badge-success {
            background-color: var(--secondary-color);
            color: white;
        }

        .badge-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .badge-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .glossary-term {
            font-weight: 600;
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.6em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Unity RTS Game Architecture Document</h1>

        <div class="tldr">
            âœ¨ This game is built like a LEGO set. Each part (like player input, robots, and buttons) connects to make the whole game move. When you click the screen, events fly around telling everyone what happened!
        </div>

        <!-- Table of Contents -->
        <div class="toc" id="toc">
            <h2 style="color: white; border: none; padding: 0; margin-bottom: 20px;">ğŸ“š Table of Contents</h2>
            <a href="#project-overview">1. Project Overview</a>
            <a href="#project-structure">2. Project Structure</a>
            <a href="#architecture-overview">3. Architecture Overview</a>
            <a href="#boot-sequence">4. Boot Sequence & Game Flow</a>
            <a href="#major-systems">5. Major Systems</a>
            <a href="#scenes-prefabs">6. Scenes & Prefabs</a>
            <a href="#data-config">7. Data & Configuration</a>
            <a href="#performance">8. Performance Notes</a>
            <a href="#testing-tooling">9. Testing & Tooling</a>
            <a href="#risks-debt">10. Risks & Technical Debt</a>
            <a href="#glossary">11. Glossary</a>
        </div>

        <!-- Project Overview -->
        <h2 id="project-overview">1. ğŸ¯ Project Overview</h2>

        <div class="summary-box">
            <p><strong>One-line summary:</strong> A real-time strategy (RTS) game where you control robots, build bases, and command armies - just like StarCraft but simpler!</p>
        </div>

        <h3>ğŸ“‹ Basic Information</h3>
        <table>
            <tr>
                <th>Property</th>
                <th>Value</th>
            </tr>
            <tr>
                <td>Unity Version</td>
                <td><code>6000.0.12f1</code> (Unity 6)</td>
            </tr>
            <tr>
                <td>Project Name</td>
                <td>unity-rts-course-recording</td>
            </tr>
            <tr>
                <td>Render Pipeline</td>
                <td>Universal Render Pipeline (URP) 17.0.3</td>
            </tr>
            <tr>
                <td>Architecture Pattern</td>
                <td>Event-Driven + Command Pattern + ScriptableObject Data</td>
            </tr>
            <tr>
                <td>AI System</td>
                <td>Unity Behavior Graph + NavMesh Navigation</td>
            </tr>
            <tr>
                <td>Input System</td>
                <td>New Input System (1.9.0)</td>
            </tr>
        </table>

        <!-- Project Structure -->
        <h2 id="project-structure">2. ğŸ“ Project Structure Overview</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> Files are organized like drawers in a desk. Scripts go in one drawer, 3D models in another, and settings in yet another.</p>
        </div>

        <h3>ğŸ—‚ï¸ Folder Tree</h3>
        <div class="folder-tree">
Assets/
â”œâ”€â”€ ğŸ“œ Scripts/              # All C# code lives here
â”‚   â”œâ”€â”€ Commands/            # How units do things (Move, Attack, Build)
â”‚   â”œâ”€â”€ EventBus/            # Message system (like a walkie-talkie)
â”‚   â”œâ”€â”€ Events/              # Event messages (UnitSelected, UnitSpawned)
â”‚   â”œâ”€â”€ Player/              # Camera and player controls
â”‚   â”œâ”€â”€ UI/                  # Buttons, health bars, menus
â”‚   â”‚   â”œâ”€â”€ Components/      # Individual UI pieces
â”‚   â”‚   â””â”€â”€ Containers/      # Groups of UI pieces
â”‚   â””â”€â”€ Units/               # All unit & building code
â”‚
â”œâ”€â”€ ğŸ¨ Scenes/               # Game levels
â”‚   â”œâ”€â”€ Game.unity           # Main gameplay scene
â”‚   â””â”€â”€ SampleScene.unity    # Test/example scene
â”‚
â”œâ”€â”€ ğŸ­ Units/                # Units & Buildings
â”‚   â”œâ”€â”€ Worker/              # Worker unit (gathers resources)
â”‚   â”œâ”€â”€ Rifleman/            # Soldier unit
â”‚   â”œâ”€â”€ Grenadier/           # Explosive unit
â”‚   â”œâ”€â”€ Air Transport/       # Flying unit
â”‚   â””â”€â”€ Buildings/           # All buildings
â”‚       â”œâ”€â”€ Barracks/        # Spawns soldiers
â”‚       â”œâ”€â”€ UapCenter/       # Main base
â”‚       â”œâ”€â”€ Command Post/
â”‚       â”œâ”€â”€ Airport/
â”‚       â””â”€â”€ Infantry School/
â”‚
â”œâ”€â”€ ğŸ–¼ï¸ UI/                   # User interface assets
â”‚   â”œâ”€â”€ Prefabs/             # Reusable UI pieces
â”‚   â””â”€â”€ Fonts & Materials/
â”‚
â”œâ”€â”€ ğŸ¨ Models/               # 3D robot parts
â”‚   â”œâ”€â”€ marine_center/       # Marine robot body
â”‚   â”œâ”€â”€ marine_leg/          # Marine robot legs
â”‚   â”œâ”€â”€ marine_top/          # Marine robot top
â”‚   â”œâ”€â”€ sniper_center/
â”‚   â”œâ”€â”€ sniper_leg/
â”‚   â”œâ”€â”€ sniper_top/
â”‚   â””â”€â”€ devil_*/             # Devil robot parts
â”‚
â”œâ”€â”€ âš™ï¸ Settings/             # Graphics & render settings
â”‚   â”œâ”€â”€ PC_RPAsset.asset     # PC graphics quality
â”‚   â”œâ”€â”€ Mobile_RPAsset.asset # Mobile graphics quality
â”‚   â””â”€â”€ PC_Renderer.asset    # How things are drawn
â”‚
â”œâ”€â”€ ğŸŒ Terrain/              # Ground and landscape
â”œâ”€â”€ ğŸ“¦ Materials/            # Colors and textures
â”œâ”€â”€ ğŸ–¼ï¸ Textures/             # Image files
â””â”€â”€ ğŸ§ª Editor/               # Unity Editor tools
        </div>

        <h3>ğŸ”‘ Key Files & Their Jobs</h3>
        <table>
            <tr>
                <th>File</th>
                <th>What It Does</th>
                <th>Why It Matters</th>
            </tr>
            <tr>
                <td><code>Scripts/EventBus/Bus.cs</code></td>
                <td>Central message system</td>
                <td>Lets different parts of the game talk without knowing about each other</td>
            </tr>
            <tr>
                <td><code>Scripts/Player/PlayerInput.cs</code></td>
                <td>Handles mouse & keyboard</td>
                <td>This is how YOU control the game</td>
            </tr>
            <tr>
                <td><code>Scripts/Units/AbstractUnit.cs</code></td>
                <td>Base class for all units</td>
                <td>Every robot inherits from this</td>
            </tr>
            <tr>
                <td><code>Scripts/Units/BaseBuilding.cs</code></td>
                <td>Building logic with queue</td>
                <td>Handles unit production (like a factory)</td>
            </tr>
            <tr>
                <td><code>Scripts/Commands/ICommand.cs</code></td>
                <td>Command interface</td>
                <td>Defines how commands work (Move, Attack, Build)</td>
            </tr>
            <tr>
                <td><code>Scripts/UI/RuntimeUI.cs</code></td>
                <td>Main UI controller</td>
                <td>Shows/hides buttons based on selection</td>
            </tr>
            <tr>
                <td><code>Scenes/Game.unity</code></td>
                <td>Main game scene</td>
                <td>Where the actual game happens</td>
            </tr>
        </table>

        <!-- Architecture Overview -->
        <h2 id="architecture-overview">3. ğŸ—ï¸ Architecture Overview</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> This game uses three main patterns: <strong>Event Bus</strong> (for messaging), <strong>Command Pattern</strong> (for actions), and <strong>ScriptableObjects</strong> (for data storage).</p>
        </div>

        <h3>ğŸ¨ Architecture Pattern</h3>
        <p>The game follows an <strong>Event-Driven Architecture</strong> combined with the <strong>Command Pattern</strong>. Think of it like this:</p>

        <ul>
            <li><span class="icon">ğŸ“¢</span> <strong>Event Bus:</strong> A radio station that broadcasts messages to anyone listening</li>
            <li><span class="icon">ğŸ¯</span> <strong>Command Pattern:</strong> A to-do list that units follow</li>
            <li><span class="icon">ğŸ“¦</span> <strong>ScriptableObjects:</strong> Data containers (like recipe cards for units)</li>
        </ul>

        <h3>ğŸ“Š High-Level Architecture Diagram</h3>
        <div class="diagram-container">
            <div class="mermaid">
graph TB
    Player[ğŸ‘¤ Player Input<br/>Mouse & Keyboard]
    EventBus[ğŸ“¢ Event Bus<br/>Central Messaging]
    UI[ğŸ–¼ï¸ UI System<br/>Buttons & Displays]
    Units[ğŸ¤– Units<br/>Workers, Soldiers]
    Buildings[ğŸ­ Buildings<br/>Barracks, Base]
    Commands[ğŸ¯ Commands<br/>Move, Attack, Build]
    AI[ğŸ§  AI System<br/>Behavior Graphs]
    NavMesh[ğŸ—ºï¸ NavMesh<br/>Pathfinding]
    Data[ğŸ“¦ ScriptableObjects<br/>Unit Data]

    Player --> EventBus
    Player --> Commands
    EventBus --> UI
    EventBus --> Units
    EventBus --> Buildings
    Commands --> Units
    Commands --> Buildings
    UI --> EventBus
    Units --> AI
    AI --> NavMesh
    Buildings -.uses.-> Data
    Units -.uses.-> Data

    style EventBus fill:#667eea,color:#fff
    style Player fill:#00c9a7,color:#fff
    style Commands fill:#ffab00,color:#fff
    style Data fill:#ff5252,color:#fff
            </div>
            <div class="diagram-explanation">
                When you click the mouse, PlayerInput tells the EventBus "Hey, something happened!" The EventBus is like a school bell - everyone hears it at the same time. Then UI, Units, and Buildings all react to the news!
            </div>
        </div>

        <h3>ğŸ”— Module Dependency Diagram</h3>
        <div class="diagram-container">
            <div class="mermaid">
graph LR
    EventBus[EventBus<br/>Core System]
    Events[Events<br/>Message Types]
    Player[Player<br/>Input Handler]
    Units[Units<br/>All Units]
    Commands[Commands<br/>Actions]
    UI[UI<br/>Interface]

    Events --> EventBus
    Player --> Events
    Player --> Commands
    Units --> Events
    Units --> Commands
    UI --> Events
    Commands -.uses.-> Units

    style EventBus fill:#667eea,color:#fff,stroke:#333,stroke-width:3px
    style Events fill:#00c9a7,color:#fff
            </div>
            <div class="diagram-explanation">
                The EventBus is the boss! Everything connects to it. Events are the messages, and everyone (Player, Units, UI) sends messages through the EventBus. It's like passing notes in class, but the teacher (EventBus) delivers them instantly!
            </div>
        </div>

        <h3>ğŸ§© Key Classes Diagram</h3>
        <div class="diagram-container">
            <div class="mermaid">
classDiagram
    class IEvent {
        <<interface>>
    }

    class Bus~T~ {
        +OnEvent : Event~T~
        +Raise(T evt)
    }

    class ISelectable {
        <<interface>>
        +Select()
        +Deselect()
    }

    class ICommand {
        <<interface>>
        +CanHandle(context)
        +Handle(context)
    }

    class AbstractCommandable {
        +CurrentHealth : int
        +MaxHealth : int
        +AvailableCommands : ActionBase[]
        +Select()
        +Deselect()
    }

    class AbstractUnit {
        +AgentRadius : float
        +MoveTo(position)
    }

    class BaseBuilding {
        +QueueSize : int
        +BuildUnit(unit)
        +CancelBuildingUnit(index)
    }

    class ActionBase {
        +Icon : Sprite
        +Slot : int
        +RequiresClickToActivate : bool
        +CanHandle(context)*
        +Handle(context)*
    }

    ISelectable <|.. AbstractCommandable
    AbstractCommandable <|-- AbstractUnit
    AbstractCommandable <|-- BaseBuilding
    ICommand <|.. ActionBase
    IEvent <.. Bus
            </div>
            <div class="diagram-explanation">
                Think of this like a family tree! AbstractCommandable is the parent, and AbstractUnit (robots) and BaseBuilding (houses) are the children. They all share some powers (like Select/Deselect), but each has their own special abilities!
            </div>
        </div>

        <!-- Boot Sequence -->
        <h2 id="boot-sequence">4. ğŸš€ Boot Sequence & Game Flow</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> When you press Play, Unity wakes up the scene, creates all the objects, and starts listening for your clicks!</p>
        </div>

        <h3>ğŸ“‹ Boot Sequence Diagram</h3>
        <div class="diagram-container">
            <div class="mermaid">
sequenceDiagram
    participant Unity as ğŸ® Unity Engine
    participant Scene as ğŸ¨ Game Scene
    participant Player as ğŸ‘¤ PlayerInput
    participant UI as ğŸ–¼ï¸ RuntimeUI
    participant EventBus as ğŸ“¢ Event Bus
    participant Units as ğŸ¤– Units

    Unity->>Scene: Load Game.unity
    Scene->>Player: Awake()
    Scene->>UI: Awake()
    Player->>EventBus: Subscribe to events
    UI->>EventBus: Subscribe to events
    Scene->>Units: Start()
    Units->>EventBus: Raise UnitSpawnEvent
    Player->>Player: Wait for input...
    UI->>UI: Update UI...
    Note over Player,Units: Game is ready! ğŸ‰
            </div>
            <div class="diagram-explanation">
                First, Unity wakes up and opens the Game scene (like opening a book). Then PlayerInput and RuntimeUI wake up and tell the EventBus "Hey, we're listening!" When units appear, they shout "I'm here!" through the EventBus. Now everyone knows what's happening!
            </div>
        </div>

        <h3>ğŸ® Core Gameplay Loop</h3>
        <div class="diagram-container">
            <div class="mermaid">
graph TD
    Start([Game Running])
    Input[Player clicks mouse]
    Raycast{What did<br/>you click?}
    Unit[Unit clicked]
    Ground[Ground clicked]
    Building[Building clicked]
    SelectUnit[Select unit<br/>Show UI buttons]
    MoveUnit[Move selected units]
    ShowBuildQueue[Show build queue]
    EventBus[Broadcast event]
    UpdateUI[Update UI]

    Start --> Input
    Input --> Raycast
    Raycast -->|Unit| Unit
    Raycast -->|Ground| Ground
    Raycast -->|Building| Building
    Unit --> SelectUnit
    SelectUnit --> EventBus
    Ground --> MoveUnit
    MoveUnit --> EventBus
    Building --> ShowBuildQueue
    ShowBuildQueue --> EventBus
    EventBus --> UpdateUI
    UpdateUI --> Input

    style Start fill:#00c9a7,color:#fff
    style EventBus fill:#667eea,color:#fff
    style UpdateUI fill:#ffab00,color:#fff
            </div>
            <div class="diagram-explanation">
                The game is always spinning in a loop! You click â†’ Game checks what you clicked â†’ Something happens â†’ EventBus tells everyone â†’ UI updates â†’ repeat! It's like a merry-go-round that never stops!
            </div>
        </div>

        <h3>ğŸ¯ Command Execution Flow</h3>
        <div class="diagram-container">
            <div class="mermaid">
sequenceDiagram
    participant P as ğŸ‘¤ Player
    participant Input as PlayerInput
    participant Cmd as ğŸ¯ Command
    participant Unit as ğŸ¤– Unit
    participant AI as ğŸ§  BehaviorGraph

    P->>Input: Right-click ground
    Input->>Input: Create CommandContext
    loop For each selected unit
        Input->>Cmd: CanHandle(context)?
        Cmd-->>Input: Yes/No
        alt Command can handle
            Input->>Cmd: Handle(context)
            Cmd->>Unit: MoveTo(position)
            Unit->>AI: Set TargetLocation
            AI->>AI: Execute movement
        end
    end
            </div>
            <div class="diagram-explanation">
                When you right-click to move units, PlayerInput asks each command "Can you do this?" The MoveCommand says "Yes!" and tells the unit where to go. The unit's brain (BehaviorGraph) figures out HOW to get there. It's like giving directions to a friend!
            </div>
        </div>

        <!-- Major Systems -->
        <h2 id="major-systems">5. âš™ï¸ Major Systems</h2>

        <h3 id="system-eventbus">ğŸ“¢ Event Bus System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> A generic messaging system that lets any part of the game talk to any other part without them knowing about each other.</p>
        </div>

        <h4>How It Works</h4>
        <p>The Event Bus uses C# generics to create type-safe messaging channels:</p>

        <pre><code class="language-csharp">// Sending a message
Bus&lt;UnitSelectedEvent&gt;.Raise(new UnitSelectedEvent(unit));

// Listening for messages
Bus&lt;UnitSelectedEvent&gt;.OnEvent += HandleUnitSelected;

// Stop listening
Bus&lt;UnitSelectedEvent&gt;.OnEvent -= HandleUnitSelected;</code></pre>

        <h4>Key Events</h4>
        <table>
            <tr>
                <th>Event</th>
                <th>When It Fires</th>
                <th>Who Listens</th>
            </tr>
            <tr>
                <td><code>UnitSelectedEvent</code></td>
                <td>When player clicks a unit</td>
                <td>RuntimeUI, PlayerInput</td>
            </tr>
            <tr>
                <td><code>UnitDeselectedEvent</code></td>
                <td>When unit is deselected</td>
                <td>RuntimeUI, PlayerInput</td>
            </tr>
            <tr>
                <td><code>UnitSpawnEvent</code></td>
                <td>When unit spawns in world</td>
                <td>PlayerInput (tracks all units)</td>
            </tr>
            <tr>
                <td><code>ActionSelectedEvent</code></td>
                <td>When player clicks UI button</td>
                <td>PlayerInput (executes action)</td>
            </tr>
        </table>

        <div class="success-box">
            <strong>âœ… Why This Is Good:</strong> Loose coupling! The UI doesn't need to know about Units, and Units don't need to know about UI. They just talk through the EventBus. If you want to add a new listener, just subscribe to the event!
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Imagine you're in a big house with many rooms. Instead of walking to each room to tell people news, you use an intercom (EventBus). You press a button and say "Unit selected!" Everyone in every room hears it at the same time!
        </p>

        <h3 id="system-input">ğŸ•¹ï¸ Input System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Handles all player controls - clicking units, moving camera, selecting with drag box, and right-clicking to command.</p>
        </div>

        <h4>Features</h4>
        <ul>
            <li><span class="icon">ğŸ–±ï¸</span> <strong>Left-click:</strong> Select units or activate actions</li>
            <li><span class="icon">ğŸ–±ï¸</span> <strong>Right-click:</strong> Move units or execute commands</li>
            <li><span class="icon">ğŸ“¦</span> <strong>Drag selection:</strong> Draw a box to select multiple units</li>
            <li><span class="icon">ğŸ“·</span> <strong>Camera control:</strong> Arrow keys for panning, End key for zoom, PageUp/Down for rotation</li>
            <li><span class="icon">â‡§</span> <strong>Shift-click:</strong> Add units to selection</li>
        </ul>

        <div class="diagram-container">
            <div class="mermaid">
graph TD
    MouseClick[Mouse Click]
    Raycast[Raycast from camera]
    HitCheck{What was hit?}
    Unit[Unit Layer]
    Ground[Ground Layer]
    UI[UI Element]
    SelectUnit[Select Unit]
    ExecuteCommand[Execute Command]
    IgnoreClick[Ignore Click]
    EventBus[Event Bus]

    MouseClick --> Raycast
    Raycast --> HitCheck
    HitCheck -->|Selectable| Unit
    HitCheck -->|Floor| Ground
    HitCheck -->|UI| UI
    Unit --> SelectUnit
    Ground --> ExecuteCommand
    UI --> IgnoreClick
    SelectUnit --> EventBus
    ExecuteCommand --> EventBus

    style HitCheck fill:#ffab00,color:#fff
    style EventBus fill:#667eea,color:#fff
            </div>
            <div class="diagram-explanation">
                When you click, the game shoots an invisible laser (raycast) from the camera. If the laser hits a robot, you select it. If it hits the ground, units move there. If it hits a button, nothing happens (because you're clicking UI)!
            </div>
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            PlayerInput is like the game's eyes and ears. It watches everything you do with the mouse and keyboard, then tells the game "Hey, the player wants to do this!" It's the middleman between you and the game world!
        </p>

        <h3 id="system-camera">ğŸ“· Camera System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Uses Cinemachine to smoothly follow a target and let players pan, zoom, and rotate the view.</p>
        </div>

        <h4>How It Works</h4>
        <ul>
            <li>Uses <code>CinemachineCamera</code> with <code>CinemachineFollow</code></li>
            <li>Follows a <code>Rigidbody</code> target (physics-based smooth movement)</li>
            <li>Panning moves the target, not the camera directly</li>
            <li>Zoom and rotation adjust the camera's <code>FollowOffset</code></li>
            <li>Uses <code>Vector3.Slerp</code> for smooth interpolation</li>
        </ul>

        <div class="success-box">
            <strong>âœ… Why Use Cinemachine:</strong> It handles all the hard math! Smooth following, damping, and frame-rate independent motion all come for free. Without it, you'd need to write hundreds of lines of camera code!
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            The camera is like a drone following you around. When you press arrow keys, the drone's target moves, and the drone smoothly follows. When you press End, the drone flies closer. PageUp/Down make it circle around!
        </p>

        <h3 id="system-ui">ğŸ–¼ï¸ UI System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Shows action buttons and build queues based on what you selected, and sends events when you click buttons.</p>
        </div>

        <h4>Components</h4>
        <table>
            <tr>
                <th>Component</th>
                <th>Purpose</th>
                <th>Shows When</th>
            </tr>
            <tr>
                <td><code>RuntimeUI</code></td>
                <td>Main UI controller</td>
                <td>Always active (manages others)</td>
            </tr>
            <tr>
                <td><code>ActionsUI</code></td>
                <td>Shows action buttons</td>
                <td>Any unit is selected</td>
            </tr>
            <tr>
                <td><code>BuildingBuildingUI</code></td>
                <td>Shows build queue</td>
                <td>One building is selected</td>
            </tr>
            <tr>
                <td><code>UIActionButton</code></td>
                <td>Individual action button</td>
                <td>Unit has that command</td>
            </tr>
            <tr>
                <td><code>UIBuildQueueButton</code></td>
                <td>Unit in build queue</td>
                <td>Building is producing</td>
            </tr>
            <tr>
                <td><code>ProgressBar</code></td>
                <td>Shows build progress</td>
                <td>Unit is being built</td>
            </tr>
        </table>

        <h4>UI Flow</h4>
        <div class="diagram-container">
            <div class="mermaid">
sequenceDiagram
    participant P as ğŸ‘¤ Player
    participant U as ğŸ¤– Unit
    participant EB as ğŸ“¢ EventBus
    participant UI as ğŸ–¼ï¸ RuntimeUI
    participant ActUI as ActionsUI
    participant BldUI as BuildingBuildingUI

    P->>U: Click unit
    U->>EB: Raise UnitSelectedEvent
    EB->>UI: Forward event
    UI->>UI: Add to selectedUnits
    alt Unit is AbstractCommandable
        UI->>ActUI: EnableFor(selectedUnits)
        ActUI->>ActUI: Show action buttons
    end
    alt Unit is BaseBuilding
        UI->>BldUI: EnableFor(building)
        BldUI->>BldUI: Show build queue
    end
            </div>
            <div class="diagram-explanation">
                When you click a unit, it sends a message through the EventBus. RuntimeUI hears the message and says "Okay, let me show the right buttons!" If it's a building, it also shows what's being built. If you select a worker, it shows worker actions!
            </div>
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            The UI is like a smart assistant that knows exactly what to show you. Click a soldier? It shows attack/move buttons. Click a building? It shows what's being built. Click empty space? Everything disappears. It's like a chameleon that changes based on what you're looking at!
        </p>

        <h3 id="system-units">ğŸ¤– Units System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> All moveable characters (Workers, Riflemen, Grenadiers) that can be selected, commanded, and controlled.</p>
        </div>

        <h4>Unit Hierarchy</h4>
        <div class="diagram-container">
            <div class="mermaid">
graph TD
    Mono[MonoBehaviour]
    ISelectable[ISelectable interface]
    IMoveable[IMoveable interface]
    AbstractCommandable[AbstractCommandable<br/>Health, Selection, Commands]
    AbstractUnit[AbstractUnit<br/>NavMesh, Movement, AI]
    Worker[Worker]
    WorkerThree[WorkerThreeRobot]
    MarineThree[MarineThreeRobot]

    Mono --> AbstractCommandable
    ISelectable --> AbstractCommandable
    AbstractCommandable --> AbstractUnit
    IMoveable --> AbstractUnit
    AbstractUnit --> Worker
    AbstractUnit --> WorkerThree
    AbstractUnit --> MarineThree

    style AbstractCommandable fill:#00c9a7,color:#fff
    style AbstractUnit fill:#667eea,color:#fff
            </div>
            <div class="diagram-explanation">
                AbstractCommandable is the grandparent of all selectable things. AbstractUnit adds movement powers. Worker, WorkerThreeRobot, and MarineThreeRobot are the grandchildren - they inherit all the powers from their parents!
            </div>
        </div>

        <h4>Unit Features</h4>
        <ul>
            <li><span class="icon">ğŸ’š</span> <strong>Health:</strong> Tracked via <code>CurrentHealth</code> and <code>MaxHealth</code></li>
            <li><span class="icon">ğŸ¯</span> <strong>Commands:</strong> Each unit has <code>AvailableCommands[]</code> array</li>
            <li><span class="icon">âœ¨</span> <strong>Selection:</strong> Shows/hides decal projector on ground</li>
            <li><span class="icon">ğŸš¶</span> <strong>Movement:</strong> Uses <code>NavMeshAgent</code> for pathfinding</li>
            <li><span class="icon">ğŸ§ </span> <strong>AI:</strong> Uses <code>BehaviorGraphAgent</code> for decision-making</li>
            <li><span class="icon">ğŸ“¦</span> <strong>Data:</strong> Reads initial values from <code>UnitSO</code> ScriptableObject</li>
        </ul>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Units are like little robots you control. Each robot has health (so it can get hurt), commands (things it can do), and a brain (BehaviorGraph) that makes it walk around. When you select a robot, it shows a glowing circle on the ground so you know it's picked!
        </p>

        <h3 id="system-buildings">ğŸ­ Buildings System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Static structures (Barracks, UapCenter, Airport) that can be selected and produce units over time using a queue.</p>
        </div>

        <h4>Building Features</h4>
        <ul>
            <li><span class="icon">ğŸ­</span> <strong>Unit Production:</strong> Uses <code>BuildUnit(UnitSO)</code> to queue units</li>
            <li><span class="icon">â±ï¸</span> <strong>Build Time:</strong> Each unit takes <code>UnitSO.BuildTime</code> seconds</li>
            <li><span class="icon">ğŸ“‹</span> <strong>Queue System:</strong> Max 5 units in queue (FIFO)</li>
            <li><span class="icon">âŒ</span> <strong>Cancel:</strong> Can cancel any unit in queue via <code>CancelBuildingUnit(index)</code></li>
            <li><span class="icon">ğŸ“¢</span> <strong>Events:</strong> Fires <code>OnQueueUpdated</code> event when queue changes</li>
            <li><span class="icon">ğŸ”„</span> <strong>Coroutine:</strong> Uses <code>DoBuildUnits()</code> coroutine to process queue</li>
        </ul>

        <h4>Build Queue Flow</h4>
        <div class="diagram-container">
            <div class="mermaid">
graph LR
    Click[Click Build Button]
    Add[Add to Queue]
    Check{First in Queue?}
    StartCoro[Start Coroutine]
    Wait[Wait BuildTime]
    Spawn[Spawn Unit]
    Remove[Remove from Queue]
    CheckEmpty{Queue Empty?}
    Continue[Continue Loop]
    Done[Done]

    Click --> Add
    Add --> Check
    Check -->|Yes| StartCoro
    Check -->|No| Done
    StartCoro --> Wait
    Wait --> Spawn
    Spawn --> Remove
    Remove --> CheckEmpty
    CheckEmpty -->|No| Continue
    CheckEmpty -->|Yes| Done
    Continue --> Wait

    style StartCoro fill:#00c9a7,color:#fff
    style Spawn fill:#667eea,color:#fff
            </div>
            <div class="diagram-explanation">
                When you click "Build Worker", it joins the queue (like a line at a store). The building starts working on the first one, waits for BuildTime, then POOF - a new unit appears! If there are more in queue, it starts the next one. It's like a cookie factory!
            </div>
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Buildings are like factories that make robots. When you tell a building "Build 3 workers", they go into a waiting line (queue). The factory works on one robot at a time. When it's done, the robot pops out and the factory starts on the next one. You can even cancel if you change your mind!
        </p>

        <h3 id="system-commands">ğŸ¯ Commands System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Implements the Command Pattern to handle all unit actions (Move, Attack, Build) in a flexible, extensible way.</p>
        </div>

        <h4>Command Pattern</h4>
        <p>All commands implement the <code>ICommand</code> interface:</p>
        <pre><code class="language-csharp">public interface ICommand
{
    bool CanHandle(CommandContext context);
    void Handle(CommandContext context);
}</code></pre>

        <h4>Available Commands</h4>
        <table>
            <tr>
                <th>Command</th>
                <th>What It Does</th>
                <th>Can Handle</th>
            </tr>
            <tr>
                <td><code>MoveCommand</code></td>
                <td>Moves units to position</td>
                <td>Any AbstractUnit</td>
            </tr>
            <tr>
                <td><code>BuildUnitCommand</code></td>
                <td>Queues unit for production</td>
                <td>BaseBuilding only</td>
            </tr>
        </table>

        <h4>Command Context</h4>
        <p><code>CommandContext</code> carries all the information needed to execute a command:</p>
        <ul>
            <li><code>Commandable</code> - The unit/building executing the command</li>
            <li><code>Hit</code> - RaycastHit with position and normal</li>
            <li><code>UnitIndex</code> - For formation logic (multiple units)</li>
        </ul>

        <h4>Move Command Formation</h4>
        <p>The <code>MoveCommand</code> arranges units in a circular formation:</p>
        <ul>
            <li>First unit goes to exact click position</li>
            <li>Other units form concentric circles around it</li>
            <li>Uses <code>AgentRadius</code> to calculate spacing</li>
            <li>Prevents units from overlapping</li>
        </ul>

        <div class="success-box">
            <strong>âœ… Why Command Pattern:</strong> Adding new commands is easy! Just create a new class that implements <code>ICommand</code>. No need to modify existing code. Want an AttackCommand? Just add it! This follows the Open-Closed Principle (open for extension, closed for modification).
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Commands are like instruction cards. When you right-click, the game checks all the instruction cards and asks "Can you do this?" The MoveCommand card says "Yes!" and tells units where to go. The BuildUnitCommand card only works for buildings. If you want to add new actions (like Attack), just make a new instruction card!
        </p>

        <h3 id="system-ai">ğŸ§  AI System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Uses Unity's Behavior Tree system to control unit AI (moving to targets, avoiding obstacles).</p>
        </div>

        <h4>How It Works</h4>
        <ul>
            <li>Each unit has a <code>BehaviorGraphAgent</code> component</li>
            <li>Behavior graphs are visual scripts (like flowcharts)</li>
            <li>Units respond to variables like <code>TargetLocation</code></li>
            <li>Uses <code>NavMeshAgent</code> for actual pathfinding</li>
        </ul>

        <div class="warning-box">
            <strong>âš ï¸ Note:</strong> Behavior graphs are created in the Unity Editor. They're not visible in code, so you need to check the Inspector to see unit AI logic!
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            The AI is like a robot's brain. You tell it "Go here!" and it figures out how to walk there, avoid walls, and not bump into other robots. It's like a GPS for robots - you set the destination, it finds the path!
        </p>

        <h3 id="system-nav">ğŸ—ºï¸ Navigation System</h3>
        <div class="summary-box">
            <p><strong>One-liner:</strong> Uses Unity's NavMesh to calculate paths around obstacles and terrain.</p>
        </div>

        <h4>Features</h4>
        <ul>
            <li><span class="icon">ğŸ—ºï¸</span> <strong>NavMesh Baking:</strong> Pre-calculates walkable areas</li>
            <li><span class="icon">ğŸš¶</span> <strong>NavMeshAgent:</strong> Each unit has one for pathfinding</li>
            <li><span class="icon">âš™ï¸</span> <strong>Agent Settings:</strong> Radius, height, slope, climb distance</li>
            <li><span class="icon">ğŸš§</span> <strong>Obstacle Avoidance:</strong> Units don't walk through walls or each other</li>
        </ul>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            NavMesh is like painting the floor to show where robots can walk. Blue areas are walkable, white areas are walls. Each robot follows the blue paint to reach its destination, never stepping on white!
        </p>

        <!-- Scenes & Prefabs -->
        <h2 id="scenes-prefabs">6. ğŸ¨ Scenes & Prefabs</h2>

        <h3>ğŸ¬ Scenes</h3>
        <table>
            <tr>
                <th>Scene</th>
                <th>Purpose</th>
                <th>What's In It</th>
            </tr>
            <tr>
                <td><code>Game.unity</code></td>
                <td>Main gameplay scene</td>
                <td>
                    â€¢ Terrain & environment<br>
                    â€¢ Camera system<br>
                    â€¢ Player input<br>
                    â€¢ UI canvas<br>
                    â€¢ Initial units & buildings<br>
                    â€¢ Lighting
                </td>
            </tr>
            <tr>
                <td><code>SampleScene.unity</code></td>
                <td>Example/test scene</td>
                <td>Basic setup from URP template</td>
            </tr>
        </table>

        <h3>ğŸ­ Key Prefabs</h3>
        <h4>Units</h4>
        <ul>
            <li><code>Worker.prefab</code> - Basic worker unit (gathers resources)</li>
            <li><code>WorkerThreeRobot.prefab</code> - Custom 3-part robot worker</li>
            <li><code>MarineThreeRobot.prefab</code> - Custom 3-part marine soldier</li>
            <li><code>Rifleman.prefab</code> - Soldier with rifle</li>
            <li><code>Grenadier.prefab</code> - Explosive unit</li>
            <li><code>AirTransportThreeRobot.prefab</code> - Flying transport</li>
        </ul>

        <h4>Buildings</h4>
        <ul>
            <li><code>Barracks.prefab</code> - Spawns soldier units</li>
            <li><code>UapCenter.prefab</code> - Main command center</li>
            <li><code>Airport.prefab</code> - Spawns air units</li>
            <li><code>Command Post.prefab</code> - Secondary building</li>
            <li><code>Infantry School.prefab</code> - Training building</li>
            <li><code>Supply Hut.prefab</code> - Resource building</li>
        </ul>

        <h4>UI Prefabs</h4>
        <ul>
            <li><code>Action Button.prefab</code> - Individual action button</li>
            <li><code>Building Queue Button Variant.prefab</code> - Shows unit in queue</li>
            <li><code>Progress Bar.prefab</code> - Shows build progress</li>
        </ul>

        <h4>Prefab Structure</h4>
        <p>Most unit/building prefabs follow this pattern:</p>
        <div class="folder-tree">
Prefab Root (e.g., "Barracks")
â”œâ”€â”€ Scripts (AbstractCommandable, BaseBuilding, etc.)
â”œâ”€â”€ BoxCollider (for selection)
â”œâ”€â”€ Decal Projector (selection indicator) - child object
â””â”€â”€ 3D Model (visual) - child object
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Prefabs are like cookie cutters! You make one perfect robot or building, save it as a prefab, then you can stamp out copies anywhere in the game. Change the prefab once, and all copies update automatically. It's like magic!
        </p>

        <!-- Data & Config -->
        <h2 id="data-config">7. ğŸ“¦ Data & Configuration</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> All unit stats and settings live in ScriptableObject files (.asset). Think of them like recipe cards - they store all the ingredients for a unit!</p>
        </div>

        <h3>ğŸ“„ ScriptableObject Data</h3>
        <h4>UnitSO Structure</h4>
        <pre><code class="language-csharp">public class UnitSO : ScriptableObject
{
    public int Health { get; private set; } = 100;
    public GameObject Prefab { get; private set; }
    public float BuildTime { get; private set; } = 5;
    public Sprite Icon { get; private set; }
}</code></pre>

        <h4>Unit Data Files</h4>
        <table>
            <tr>
                <th>Asset</th>
                <th>Health</th>
                <th>Build Time</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><code>Worker.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Gatherer unit</td>
            </tr>
            <tr>
                <td><code>WorkerThreeRobot.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Custom worker</td>
            </tr>
            <tr>
                <td><code>Rifleman.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Soldier unit</td>
            </tr>
            <tr>
                <td><code>Grenadier.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Explosive unit</td>
            </tr>
            <tr>
                <td><code>Barracks.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Building</td>
            </tr>
            <tr>
                <td><code>UapCenter.asset</code></td>
                <td>100</td>
                <td>5s</td>
                <td>Main base</td>
            </tr>
        </table>

        <h4>Command Data Files</h4>
        <p>Commands are also ScriptableObjects:</p>
        <ul>
            <li><code>Move Action.asset</code> - Move command</li>
            <li><code>Build Worker.asset</code> - Build worker command</li>
            <li><code>Build Rifleman.asset</code> - Build rifleman command</li>
            <li><code>Build Grenadier.asset</code> - Build grenadier command</li>
            <li><code>Build Spider.asset</code> - Build spider robot command</li>
        </ul>

        <h3>âš™ï¸ Graphics Settings</h3>
        <h4>Quality Presets</h4>
        <table>
            <tr>
                <th>Setting</th>
                <th>Mobile</th>
                <th>PC</th>
            </tr>
            <tr>
                <td>Anti-Aliasing</td>
                <td>Off</td>
                <td>8x MSAA</td>
            </tr>
            <tr>
                <td>Shadow Resolution</td>
                <td>Low</td>
                <td>2048</td>
            </tr>
            <tr>
                <td>Shadow Distance</td>
                <td>30m</td>
                <td>50m</td>
            </tr>
            <tr>
                <td>Shadow Cascades</td>
                <td>2</td>
                <td>4</td>
            </tr>
        </table>

        <h4>URP Renderer Features</h4>
        <ul>
            <li><strong>MSAA:</strong> 8x Multi-Sampling for smooth edges</li>
            <li><strong>HDR:</strong> Enabled for better lighting</li>
            <li><strong>Depth Texture:</strong> Required for effects</li>
            <li><strong>Opaque Texture:</strong> For transparent objects</li>
            <li><strong>SRP Batcher:</strong> Enabled for performance</li>
        </ul>

        <div class="success-box">
            <strong>âœ… Why ScriptableObjects:</strong> They're stored as assets in the project, so designers can tweak unit stats without touching code! Plus, they're memory-efficient - one Worker.asset file can be used by 100 worker instances!
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            ScriptableObjects are like recipe cards at a bakery. Want to know how to make a Worker robot? Check the Worker.asset card! It says "100 health, 5 seconds to build, use Worker prefab." If you want workers to be stronger, just change the recipe card!
        </p>

        <!-- Performance -->
        <h2 id="performance">8. âš¡ Performance Notes</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> The game runs smoothly for small armies, but large battles (100+ units) might slow down. Watch out for too many raycasts and AI calculations!</p>
        </div>

        <h3>ğŸŒ Potential Bottlenecks</h3>
        <table>
            <tr>
                <th>System</th>
                <th>Issue</th>
                <th>Impact</th>
                <th>Solution</th>
            </tr>
            <tr>
                <td>PlayerInput</td>
                <td>Drag selection checks ALL units every frame</td>
                <td>High unit count = lag</td>
                <td>Use spatial partitioning (quadtree)</td>
            </tr>
            <tr>
                <td>EventBus</td>
                <td>Broadcasts to all listeners</td>
                <td>Many listeners = slower</td>
                <td>Currently fine, but watch subscriber count</td>
            </tr>
            <tr>
                <td>NavMesh</td>
                <td>Pathfinding for 100+ units</td>
                <td>CPU spike when all units move</td>
                <td>Stagger pathfinding over frames</td>
            </tr>
            <tr>
                <td>UI Updates</td>
                <td>Rebuilding UI every frame</td>
                <td>Garbage collection spikes</td>
                <td>Object pooling for buttons</td>
            </tr>
            <tr>
                <td>Raycasts</td>
                <td>Multiple raycasts per frame (mouse, selection)</td>
                <td>CPU overhead</td>
                <td>Cache results, use layer masks</td>
            </tr>
        </table>

        <h3>âœ… Good Practices Already Used</h3>
        <ul>
            <li><span class="icon">âœ…</span> <strong>SRP Batcher:</strong> Enabled for draw call batching</li>
            <li><span class="icon">âœ…</span> <strong>HashSet for Units:</strong> Fast lookup/add/remove</li>
            <li><span class="icon">âœ…</span> <strong>Layer Masks:</strong> Raycasts only check relevant layers</li>
            <li><span class="icon">âœ…</span> <strong>Event Unsubscription:</strong> Properly cleans up in <code>OnDestroy()</code></li>
            <li><span class="icon">âœ…</span> <strong>Coroutines:</strong> Async building doesn't block main thread</li>
        </ul>

        <h3>âš ï¸ Watch Out For</h3>
        <div class="warning-box">
            <strong>Memory Leaks:</strong> If you forget to unsubscribe from events in <code>OnDestroy()</code>, destroyed objects stay in memory!
        </div>

        <div class="warning-box">
            <strong>Too Many Units:</strong> Each unit has NavMeshAgent + BehaviorGraphAgent. 200+ units = potential frame drops.
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Think of the game like a restaurant kitchen. A few orders (units)? No problem! But 100 orders at once? The chefs (CPU) get overwhelmed! The trick is to spread out the work (stagger pathfinding) or hire more chefs (optimize code)!
        </p>

        <!-- Testing & Tooling -->
        <h2 id="testing-tooling">9. ğŸ§ª Testing & Tooling</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> The project has Unity Test Framework setup, editor tools for spawning robots, and MCP integration for external tooling.</p>
        </div>

        <h3>ğŸ”§ Editor Tools</h3>
        <h4>Custom Scripts</h4>
        <ul>
            <li><code>SpawnWorkerThreeRobots.cs</code> - Editor tool to quickly spawn test robots</li>
            <li><code>ThreePartRobotBuilder.cs</code> - Tool to assemble 3-part robots (top, center, legs)</li>
            <li><code>SetupAvailableCommands.cs</code> - Automatically sets up command arrays on units</li>
        </ul>

        <h4>Packages for Development</h4>
        <table>
            <tr>
                <th>Package</th>
                <th>Purpose</th>
            </tr>
            <tr>
                <td><code>com.unity.test-framework</code></td>
                <td>Unit & integration testing</td>
            </tr>
            <tr>
                <td><code>com.coplaydev.unity-mcp</code></td>
                <td>MCP integration (external tools)</td>
            </tr>
            <tr>
                <td><code>com.unity.ide.rider</code></td>
                <td>JetBrains Rider integration</td>
            </tr>
            <tr>
                <td><code>com.unity.ide.visualstudio</code></td>
                <td>Visual Studio integration</td>
            </tr>
        </table>

        <h3>ğŸ§ª Testing</h3>
        <p>Unity Test Framework is set up but no tests are currently written.</p>

        <div class="warning-box">
            <strong>âš ï¸ Missing Tests:</strong> No automated tests exist yet! This makes refactoring risky. Consider adding tests for:
            <ul>
                <li>EventBus message delivery</li>
                <li>Command execution logic</li>
                <li>Build queue operations</li>
                <li>Unit selection/deselection</li>
            </ul>
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Editor tools are like cheat codes for developers! Instead of playing the game to test something, you press a button and BOOM - 10 robots appear! It's like having a magic wand that speeds up testing!
        </p>

        <!-- Risks & Tech Debt -->
        <h2 id="risks-debt">10. âš ï¸ Risks & Technical Debt</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> The project is well-structured, but has some areas that could cause problems later if not addressed.</p>
        </div>

        <h3>ğŸš¨ High Priority Risks</h3>
        <table>
            <tr>
                <th>Risk</th>
                <th>Impact</th>
                <th>Why It's Bad</th>
                <th>How to Fix</th>
            </tr>
            <tr>
                <td class="badge-danger" style="color: white;">No Automated Tests</td>
                <td>High</td>
                <td>Refactoring could break things silently</td>
                <td>Add PlayMode tests for core systems</td>
            </tr>
            <tr>
                <td class="badge-danger" style="color: white;">Drag Select Performance</td>
                <td>High</td>
                <td>Checks ALL units every frame during drag</td>
                <td>Use spatial hash or octree</td>
            </tr>
            <tr>
                <td class="badge-warning" style="color: white;">No Attack System Yet</td>
                <td>Medium</td>
                <td>Core RTS feature missing</td>
                <td>Implement AttackCommand + combat logic</td>
            </tr>
            <tr>
                <td class="badge-warning" style="color: white;">Memory Leak Risk</td>
                <td>Medium</td>
                <td>If event unsubscription is forgotten</td>
                <td>Code review checklist + test</td>
            </tr>
        </table>

        <h3>ğŸ§¹ Technical Debt</h3>
        <div class="danger-box">
            <h4>âš ï¸ Areas That Need Cleanup</h4>
            <ul>
                <li><strong>PlayerInput is too big:</strong> 390+ lines! Should split into InputHandler, CameraController, SelectionManager</li>
                <li><strong>Hard-coded values:</strong> Magic numbers like <code>radiusMultiplier = 3.5f</code> should be in ScriptableObjects</li>
                <li><strong>Missing documentation:</strong> Many classes lack XML comments</li>
                <li><strong>No resource system:</strong> Minerals/Gas prefabs exist but aren't used yet</li>
                <li><strong>Unit stats are identical:</strong> All units have 100 health, 5s build time - needs balancing</li>
            </ul>
        </div>

        <h3>ğŸ’¡ Quick Wins</h3>
        <div class="success-box">
            <h4>âœ… Easy Improvements You Can Do Today</h4>
            <ul>
                <li>Add XML comments to public methods (<code>/// &lt;summary&gt;</code>)</li>
                <li>Extract camera control to separate <code>CameraController</code> class</li>
                <li>Create <code>GameplayConfig</code> ScriptableObject for magic numbers</li>
                <li>Add simple PlayMode test for EventBus</li>
                <li>Implement object pooling for UI buttons</li>
            </ul>
        </div>

        <h4>Simple Explanation</h4>
        <p class="diagram-explanation">
            Technical debt is like not cleaning your room. It works fine at first, but eventually you can't find anything! The PlayerInput class is like a junk drawer - it works, but it's messy and needs organizing. Fix it before it gets worse!
        </p>

        <!-- Glossary -->
        <h2 id="glossary">11. ğŸ“– Glossary & Index</h2>

        <div class="summary-box">
            <p><strong>TL;DR:</strong> Here are simple definitions for all the technical terms used in this document.</p>
        </div>

        <h3>ğŸ”¤ Technical Terms Explained</h3>
        <table>
            <tr>
                <th>Term</th>
                <th>Simple Explanation</th>
                <th>Example</th>
            </tr>
            <tr>
                <td class="glossary-term">ScriptableObject</td>
                <td>A data container stored as a file. Like a recipe card!</td>
                <td><code>Worker.asset</code> stores worker stats</td>
            </tr>
            <tr>
                <td class="glossary-term">Event Bus</td>
                <td>A messaging system where anyone can talk and anyone can listen</td>
                <td>Unit says "I was selected!" and UI hears it</td>
            </tr>
            <tr>
                <td class="glossary-term">Prefab</td>
                <td>A reusable template for GameObjects. Like a cookie cutter!</td>
                <td><code>Worker.prefab</code> is the worker template</td>
            </tr>
            <tr>
                <td class="glossary-term">NavMesh</td>
                <td>A map showing where units can walk</td>
                <td>Blue areas = walkable, white = walls</td>
            </tr>
            <tr>
                <td class="glossary-term">Coroutine</td>
                <td>Code that runs over multiple frames without blocking</td>
                <td>Building waits 5 seconds, then spawns unit</td>
            </tr>
            <tr>
                <td class="glossary-term">Raycast</td>
                <td>An invisible laser shot from the camera to see what you clicked</td>
                <td>Click screen â†’ raycast â†’ hit unit â†’ select it</td>
            </tr>
            <tr>
                <td class="glossary-term">Command Pattern</td>
                <td>A design where actions are objects you can pass around</td>
                <td><code>MoveCommand</code> is an object that moves units</td>
            </tr>
            <tr>
                <td class="glossary-term">Interface</td>
                <td>A contract that says "you must have these methods"</td>
                <td><code>ISelectable</code> requires <code>Select()</code> and <code>Deselect()</code></td>
            </tr>
            <tr>
                <td class="glossary-term">Generic Type</td>
                <td>A template that works with any type</td>
                <td><code>Bus&lt;T&gt;</code> works with any event type</td>
            </tr>
            <tr>
                <td class="glossary-term">Delegate</td>
                <td>A variable that holds a function</td>
                <td><code>OnQueueUpdated</code> is a delegate</td>
            </tr>
            <tr>
                <td class="glossary-term">URP (Universal Render Pipeline)</td>
                <td>Unity's modern graphics system</td>
                <td>Makes the game look pretty!</td>
            </tr>
            <tr>
                <td class="glossary-term">MSAA (Multi-Sample Anti-Aliasing)</td>
                <td>Smooths jagged edges in graphics</td>
                <td>8x MSAA = very smooth edges</td>
            </tr>
            <tr>
                <td class="glossary-term">HashSet</td>
                <td>A collection with no duplicates, super fast lookup</td>
                <td>Storing selected units</td>
            </tr>
            <tr>
                <td class="glossary-term">Decal Projector</td>
                <td>Projects an image onto the ground</td>
                <td>The glowing circle under selected units</td>
            </tr>
            <tr>
                <td class="glossary-term">Cinemachine</td>
                <td>Unity's camera control system</td>
                <td>Makes camera follow smoothly</td>
            </tr>
        </table>

        <h3>ğŸ“ Code Location Index</h3>
        <h4>Where to Find Key Code</h4>
        <ul>
            <li><strong>EventBus:</strong> <code>Assets/Scripts/EventBus/Bus.cs</code></li>
            <li><strong>Player Input:</strong> <code>Assets/Scripts/Player/PlayerInput.cs</code></li>
            <li><strong>Unit Base Class:</strong> <code>Assets/Scripts/Units/AbstractUnit.cs</code></li>
            <li><strong>Building Base Class:</strong> <code>Assets/Scripts/Units/BaseBuilding.cs</code></li>
            <li><strong>Move Command:</strong> <code>Assets/Scripts/Commands/MoveCommand.cs</code></li>
            <li><strong>UI Controller:</strong> <code>Assets/Scripts/UI/RuntimeUI.cs</code></li>
            <li><strong>Unit Data:</strong> <code>Assets/Scripts/Units/UnitSO.cs</code></li>
            <li><strong>Command Interface:</strong> <code>Assets/Scripts/Commands/ICommand.cs</code></li>
        </ul>

        <!-- Footer -->
        <hr style="margin: 50px 0; border: none; border-top: 2px solid var(--border-color);">
        <p style="text-align: center; color: var(--text-muted); font-size: 0.9em;">
            ğŸ“„ Document generated on <span id="date"></span><br>
            ğŸ® Unity RTS Game Architecture v1.0<br>
            Made with â¤ï¸ by Claude Code
        </p>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#667eea',
                primaryTextColor: '#fff',
                primaryBorderColor: '#5568d3',
                lineColor: '#333',
                secondaryColor: '#00c9a7',
                tertiaryColor: '#ffab00',
            }
        });

        // Set date
        document.getElementById('date').textContent = new Date().toLocaleDateString();

        // Smooth scroll
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>

<!--
===================================
JSON SUMMARY
===================================
-->
<script type="application/json" id="architecture-summary">
{
  "unity_version": "6000.0.12f1 (Unity 6)",
  "entry_scene": "Assets/Scenes/Game.unity",
  "boot_sequence": [
    "Unity loads Game.unity",
    "PlayerInput.Awake() - Subscribes to events",
    "RuntimeUI.Awake() - Subscribes to events",
    "Units call Start() - Raise UnitSpawnEvent",
    "PlayerInput tracks all spawned units",
    "Game loop starts - waits for player input"
  ],
  "modules": [
    {
      "name": "EventBus",
      "key_classes": ["Bus<T>", "IEvent"],
      "depends_on": [],
      "purpose": "Central messaging system for loose coupling"
    },
    {
      "name": "Player",
      "key_classes": ["PlayerInput", "CameraConfig"],
      "depends_on": ["EventBus", "Events", "Commands"],
      "purpose": "Handles all player input (mouse, keyboard, camera)"
    },
    {
      "name": "Units",
      "key_classes": ["AbstractUnit", "AbstractCommandable", "ISelectable", "IMoveable"],
      "depends_on": ["EventBus", "Events", "Commands"],
      "purpose": "Base classes for all controllable units"
    },
    {
      "name": "Buildings",
      "key_classes": ["BaseBuilding"],
      "depends_on": ["Units", "EventBus"],
      "purpose": "Structures that produce units with queue system"
    },
    {
      "name": "Commands",
      "key_classes": ["ICommand", "ActionBase", "MoveCommand", "BuildUnitCommand", "CommandContext"],
      "depends_on": ["Units"],
      "purpose": "Implements Command Pattern for all unit actions"
    },
    {
      "name": "UI",
      "key_classes": ["RuntimeUI", "ActionsUI", "BuildingBuildingUI", "UIActionButton"],
      "depends_on": ["EventBus", "Events", "Units"],
      "purpose": "Shows contextual UI based on selection"
    },
    {
      "name": "Events",
      "key_classes": ["UnitSelectedEvent", "UnitDeselectedEvent", "UnitSpawnEvent", "ActionSelectedEvent"],
      "depends_on": ["EventBus"],
      "purpose": "Defines all event message types"
    }
  ],
  "packages": [
    { "name": "com.unity.render-pipelines.universal", "version": "17.0.3", "purpose": "Graphics rendering (URP)" },
    { "name": "com.unity.cinemachine", "version": "3.1.1", "purpose": "Camera control system" },
    { "name": "com.unity.inputsystem", "version": "1.9.0", "purpose": "New input system (mouse, keyboard)" },
    { "name": "com.unity.ai.navigation", "version": "2.0.0", "purpose": "NavMesh pathfinding" },
    { "name": "com.unity.behavior", "version": "1.0.0", "purpose": "Behavior Trees for AI" },
    { "name": "com.unity.test-framework", "version": "1.4.4", "purpose": "Unit & integration testing" },
    { "name": "com.coplaydev.unity-mcp", "version": "git", "purpose": "MCP integration for external tools" }
  ],
  "architecture_patterns": [
    "Event-Driven Architecture",
    "Command Pattern",
    "ScriptableObject Data Pattern",
    "Interface Segregation (ISelectable, IMoveable, ICommand)",
    "Observer Pattern (EventBus)",
    "Template Method (AbstractUnit, AbstractCommandable)"
  ],
  "risks": [
    "No automated tests - refactoring is risky",
    "Drag selection checks all units every frame - performance issue with 100+ units",
    "PlayerInput class is too large (390+ lines) - needs refactoring",
    "No attack/combat system implemented yet",
    "Memory leak risk if event unsubscription is forgotten",
    "Hard-coded magic numbers should be in ScriptableObjects",
    "Resource system (Minerals/Gas) exists but not implemented",
    "All units have identical stats - needs balancing"
  ],
  "quick_wins": [
    "Add XML documentation comments to public APIs",
    "Split PlayerInput into InputHandler, CameraController, SelectionManager",
    "Create GameplayConfig ScriptableObject for magic numbers",
    "Implement simple PlayMode tests for EventBus",
    "Add object pooling for UI buttons to reduce garbage collection",
    "Balance unit stats (health, build time, speed)",
    "Implement AttackCommand for combat",
    "Add spatial partitioning (quadtree) for selection performance"
  ],
  "performance_notes": {
    "bottlenecks": [
      "Drag selection iterates all units every frame",
      "Multiple raycasts per frame (mouse, selection)",
      "NavMesh pathfinding for 100+ units simultaneously",
      "UI rebuilds every frame when selection changes"
    ],
    "optimizations_in_place": [
      "SRP Batcher enabled",
      "HashSet for fast unit lookup",
      "Layer masks for targeted raycasts",
      "Event unsubscription in OnDestroy",
      "Coroutines for async building"
    ]
  },
  "missing_features": [
    "Combat/Attack system",
    "Resource gathering system",
    "Fog of War",
    "Multiplayer/Networking",
    "Save/Load system",
    "AI opponents",
    "Unit abilities/special powers",
    "Tech tree/upgrades",
    "Minimap"
  ]
}
</script>
