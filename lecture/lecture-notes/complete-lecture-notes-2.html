<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URTS 강의 노트 - Part 2</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.8;
            font-size: 1.1em;
        }
        
        .lecture-section {
            padding: 30px;
            border-bottom: 1px solid #eee;
        }
        
        .lecture-section:last-child {
            border-bottom: none;
        }
        
        .lecture-title {
            color: #2c3e50;
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }
        
        .lecture-goal {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border-left: 5px solid #3498db;
        }
        
        .lecture-goal h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .content-section {
            margin-bottom: 25px;
        }
        
        .content-section h3 {
            color: #34495e;
            font-size: 1.3em;
            margin-bottom: 15px;
        }
        
        .content-list {
            padding-left: 20px;
        }
        
        .content-list li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .step-guide {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .step-guide h5 {
            color: #856404;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .step-guide ol {
            margin: 0;
            padding-left: 20px;
        }
        
        .step-guide li {
            margin-bottom: 5px;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
            overflow-x: auto;
            margin: 15px 0;
            white-space: pre;
            border-left: 5px solid #3498db;
        }
        
        .tech-stack {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .tech-stack h4 {
            color: #2d5a2d;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .tech-stack p {
            margin: 8px 0;
        }
        
        .tech-stack strong {
            color: #1e3a1e;
        }
        
        .table-of-contents {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #6c757d;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .table-of-contents h3 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 1.5em;
            text-align: center;
            border-bottom: 2px solid #6c757d;
            padding-bottom: 10px;
        }
        
        .toc-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .toc-list li {
            margin: 8px 0;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            transition: all 0.3s ease;
        }
        
        .toc-list li:hover {
            background: #e3f2fd;
            border-left-color: #1976d2;
            transform: translateX(5px);
        }
        
        .toc-list a {
            text-decoration: none;
            color: #2c3e50;
            font-weight: 500;
            display: block;
        }
        
        .toc-list a:hover {
            color: #1976d2;
        }
        
        .subsection {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #6c757d;
        }
        
        .subsection h3 {
            color: #495057;
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .subsection ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .subsection li {
            margin-bottom: 5px;
        }
        
        .comment {
            color: #95a5a6;
            font-style: italic;
        }
        
        .keyword {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .string {
            color: #27ae60;
        }
        
        .number {
            color: #f39c12;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 URTS 강의 노트</h1>
            <p>Unity RTS 게임 개발 강의 - Part 2 (강의 23~)</p>
            
            <div class="table-of-contents">
                <h3>📚 목차</h3>
                <ul class="toc-list">
                    <li><a href="#lecture-23">📋 강의 23: Scriptable Objects for Configuration</a></li>
                    <li><a href="#lecture-24">🏢 강의 24: Command Post Setup</a></li>
                    <li><a href="#lecture-25">⚡ 강의 25: Actions with the Command Pattern</a></li>
                    <li><a href="#lecture-26">🎯 강의 26: Command Context 도입</a></li>
                    <li><a href="#lecture-27">🎨 강의 27: UI Command Display</a></li>
                    <li><a href="#lecture-28">🖱️ 강의 28: UI Command Execution</a></li>
                    <li><a href="#lecture-29">🏭 강의 29: Build Unit Command</a></li>
                    <li><a href="#lecture-30">🏗️ 강의 30: Building Queue</a></li>
                    <li><a href="#lecture-31">🎨 강의 31: UI System Refactoring</a></li>
                    <li><a href="#lecture-32">📊 강의 32: Progress Bar Component</a></li>
                    <li><a href="#lecture-33">🏗️ 강의 33: Building Progress Display</a></li>
                    <li><a href="#lecture-34">❌ 강의 34: Cancel Queue Items</a></li>
                    <li><a href="#lecture-35">🏗️ 강의 35: More Buildings & Units</a></li>
                    <li><a href="#lecture-36">🌳 강의 36: Unity Behavior Tree</a></li>
                    <li><a href="#lecture-37">🔧 강의 37: Custom Behavior Nodes</a></li>
                </ul>
            </div>
        </div>

        <!-- 강의 23: Scriptable Objects for Configuration (설정을 위한 스크립터블 오브젝트) -->
        <div class="lecture-section" id="lecture-23">
            <h2 class="lecture-title">📋 강의 23: Scriptable Objects for Configuration (설정을 위한 스크립터블 오브젝트)</h2>
            
            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>ScriptableObject의 개념과 사용법 이해</li>
                    <li>Unit ScriptableObject를 통한 설정 데이터 관리</li>
                    <li>MonoBehaviour와 ScriptableObject의 역할 분리</li>
                    <li>상속 구조에서의 Start() 메서드 오버라이드 처리</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📝 핵심 개념</h3>
                <ul class="content-list">
                    <li><strong>ScriptableObject</strong>: 설정 데이터를 저장하는 Unity 클래스</li>
                    <li><strong>Data Container</strong>: 주로 데이터 저장용으로 사용</li>
                    <li><strong>Build Time Configuration</strong>: 빌드 시점에 결정되는 설정</li>
                    <li><strong>Runtime Data Separation</strong>: 런타임 데이터와 설정 데이터 분리</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>💻 구현 과정</h3>
                
                <div class="step-guide">
                    <h5>1단계: Unit ScriptableObject 생성</h5>
                    <ol>
                        <li>Unit.cs 클래스 생성 (ScriptableObject 상속)</li>
                        <li>[CreateAssetMenu] 속성 추가</li>
                        <li>Health 필드 추가 (기본값 100)</li>
                    </ol>
                </div>

                <div class="step-guide">
                    <h5>2단계: AbstractCommandable 수정</h5>
                    <ol>
                        <li>Health → CurrentHealth, MaxHealth로 분리</li>
                        <li>Unit ScriptableObject 참조 필드 추가</li>
                        <li>Start() 메서드에서 설정값 적용</li>
                    </ol>
                </div>

                <div class="step-guide">
                    <h5>3단계: 상속 구조 처리</h5>
                    <ol>
                        <li>AbstractCommandable.Start()를 protected virtual로 변경</li>
                        <li>AbstractUnit.Start()에서 base.Start() 호출</li>
                        <li>상속 체인에서 설정값이 올바르게 적용되도록 보장</li>
                    </ol>
                </div>

                <div class="step-guide">
                    <h5>4단계: Prefab 설정</h5>
                    <ol>
                        <li>각 Prefab에 해당하는 Unit ScriptableObject 생성</li>
                        <li>Supply Hut: Health 100</li>
                        <li>Worker: Health 50</li>
                        <li>Air Transport: Health 200</li>
                    </ol>
                </div>
            </div>

            <div class="content-section">
                <h3>🔧 핵심 코드</h3>
                
                <div class="code-block">// UnitSO.cs - ScriptableObject 클래스
<span class="comment">// UnitSO: 유닛의 설정 데이터를 저장하는 ScriptableObject</span>
<span class="comment">// ScriptableObject: Unity에서 데이터를 저장하는 자산 타입</span>
<span class="comment">// CreateAssetMenu: Unity Inspector에서 에셋을 생성할 수 있는 메뉴 추가</span>
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// Unity에서 에셋을 생성할 수 있는 메뉴 설정</span>
    <span class="comment">// CreateAssetMenu: Unity Inspector에서 우클릭으로 에셋 생성 가능</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: 메뉴에서 보일 경로</span>
    [<span class="class-name">CreateAssetMenu</span>(fileName = <span class="string">"Unit"</span>, menuName = <span class="string">"Units/Unit"</span>)]
    <span class="comment">// 유닛의 설정 데이터를 저장하는 클래스</span>
    <span class="comment">// UnitSO: "Unit ScriptableObject"의 줄임말</span>
    <span class="comment">// ScriptableObject: MonoBehaviour가 아닌 데이터 저장용 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">UnitSO</span> : <span class="class-name">ScriptableObject</span>
    {
        <span class="comment">// 유닛의 체력 설정</span>
        <span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// int: 정수 타입</span>
        <span class="comment">// Health: 체력 값</span>
        <span class="comment">// { get; private set; }: 읽기 전용 프로퍼티 (외부에서 수정 불가)</span>
        <span class="comment">// = 100: 기본값을 100으로 설정</span>
        [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public int</span> <span class="property-name">Health</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; } = <span class="number">100</span>;
    }
}</div>

                <div class="code-block">// AbstractCommandable.cs - 수정된 부분
<span class="comment">// AbstractCommandable: 명령을 받을 수 있는 모든 객체의 기본 클래스</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="comment">// ISelectable: 선택 가능한 객체를 나타내는 인터페이스</span>
<span class="keyword">public abstract class</span> <span class="class-name">AbstractCommandable</span> : <span class="class-name">MonoBehaviour</span>, <span class="class-name">ISelectable</span>
{
    <span class="comment">// 현재 체력</span>
    <span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 할당 가능하도록 함</span>
    <span class="comment">// int: 정수 타입</span>
    <span class="comment">// CurrentHealth: 현재 체력 값</span>
    <span class="comment">// { get; private set; }: 읽기 전용 프로퍼티 (외부에서 수정 불가)</span>
    [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public int</span> <span class="property-name">CurrentHealth</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// 최대 체력</span>
    <span class="comment">// MaxHealth: 최대 체력 값</span>
    [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public int</span> <span class="property-name">MaxHealth</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// 선택 시 표시할 데칼 프로젝터</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
    <span class="comment">// DecalProjector: URP에서 데칼(투영) 효과를 만드는 컴포넌트</span>
    [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">DecalProjector</span> decalProjector;
    
    <span class="comment">// 유닛의 설정 데이터</span>
    <span class="comment">// UnitSO: 유닛의 설정을 담고 있는 ScriptableObject</span>
    [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">UnitSO</span> UnitSO;

    <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
    <span class="comment">// protected: 상속받은 클래스에서만 접근 가능</span>
    <span class="comment">// virtual: 하위 클래스에서 오버라이드 가능</span>
    <span class="comment">// void: 반환값이 없음</span>
    <span class="keyword">protected virtual void</span> <span class="method-name">Start</span>()
    {
        <span class="comment">// UnitSO에서 설정된 체력 값을 현재 체력으로 설정</span>
        <span class="comment">// UnitSO.Health: ScriptableObject에 저장된 체력 값</span>
        <span class="property-name">CurrentHealth</span> = UnitSO.<span class="property-name">Health</span>;
        
        <span class="comment">// UnitSO에서 설정된 체력 값을 최대 체력으로 설정</span>
        <span class="comment">// MaxHealth: 최대 체력 값 (일반적으로 초기 체력과 동일)</span>
        <span class="property-name">MaxHealth</span> = UnitSO.<span class="property-name">Health</span>;
    }

    <span class="comment">// Select/Deselect 메서드는 동일...</span>
}</div>

                <div class="code-block">// AbstractUnit.cs - Start() 오버라이드
<span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
<span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체의 기본 클래스 상속</span>
<span class="comment">// IMoveable: 이동 가능한 객체를 나타내는 인터페이스 구현</span>
<span class="keyword">public abstract class</span> <span class="class-name">AbstractUnit</span> : <span class="class-name">AbstractCommandable</span>, <span class="class-name">IMoveable</span>
{
    <span class="comment">// NavMeshAgent의 반지름을 반환하는 프로퍼티</span>
    <span class="comment">// AgentRadius: AI 에이전트의 반지름</span>
    <span class="comment">// =>: 람다 표현식 (간단한 프로퍼티)</span>
    <span class="comment">// agent.radius: NavMeshAgent의 반지름 값</span>
    <span class="keyword">public float</span> <span class="property-name">AgentRadius</span> => agent.<span class="property-name">radius</span>;
    
    <span class="comment">// NavMeshAgent 컴포넌트 참조</span>
    <span class="comment">// NavMeshAgent: Unity의 AI 이동을 담당하는 컴포넌트</span>
    <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> agent;

    <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
    <span class="comment">// protected: 상속받은 클래스에서만 접근 가능</span>
    <span class="comment">// virtual: 하위 클래스에서 오버라이드 가능</span>
    <span class="keyword">protected virtual void</span> <span class="method-name">Awake</span>()
    {
        <span class="comment">// 같은 GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
        <span class="comment">// GetComponent: GameObject에 연결된 특정 컴포넌트를 찾는 Unity 메서드</span>
        <span class="comment">// NavMeshAgent: AI 이동을 담당하는 컴포넌트</span>
        agent = <span class="keyword">GetComponent</span>&lt;<span class="class-name">NavMeshAgent</span>&gt;();
    }

    <span class="comment">// 부모 클래스의 Start 메서드를 호출</span>
    <span class="comment">// protected: 상속받은 클래스에서만 접근 가능</span>
    <span class="comment">// override: 부모 클래스의 메서드를 재정의</span>
    <span class="keyword">protected override void</span> <span class="method-name">Start</span>()
    {
        <span class="comment">// 부모 클래스(AbstractCommandable)의 Start 메서드 호출</span>
        <span class="comment">// base: 부모 클래스를 가리키는 키워드</span>
        <span class="comment">// Start(): 부모 클래스의 Start 메서드 실행</span>
        <span class="comment">// 이렇게 해야 UnitSO의 설정값이 올바르게 적용됨</span>
        <span class="keyword">base</span>.<span class="method-name">Start</span>(); 
        
        <span class="comment">// 유닛 스폰 이벤트 발생</span>
        <span class="comment">// Bus: 이벤트 버스 패턴을 사용한 이벤트 시스템</span>
        <span class="comment">// UnitSpawnEvent: 유닛이 생성되었을 때 발생하는 이벤트</span>
        <span class="comment">// Raise: 이벤트를 발생시키는 메서드</span>
        <span class="comment">// new UnitSpawnEvent(this): 현재 유닛을 포함한 이벤트 생성</span>
        <span class="class-name">Bus</span>&lt;<span class="class-name">UnitSpawnEvent</span>&gt;.<span class="method-name">Raise</span>(<span class="keyword">new</span> <span class="class-name">UnitSpawnEvent</span>(<span class="keyword">this</span>));
    }

    <span class="comment">// IMoveable 인터페이스의 MoveTo 메서드 구현</span>
    <span class="comment">// 유닛을 지정된 위치로 이동시키는 메서드</span>
    <span class="comment">// Vector3 position: 이동할 목표 위치</span>
    <span class="keyword">public void</span> <span class="method-name">MoveTo</span>(<span class="class-name">Vector3</span> position)
    {
        <span class="comment">// NavMeshAgent에게 목표 지점을 설정</span>
        <span class="comment">// SetDestination: AI가 이동할 목표 지점을 지정하는 메서드</span>
        <span class="comment">// position: 이동할 목표 위치 (Vector3)</span>
        <span class="comment">// AI가 자동으로 최적의 경로를 계산하여 이동함</span>
        agent.<span class="method-name">SetDestination</span>(position);
    }
}</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>📋 ScriptableObject의 장점</h4>
                    <p><strong>설정 데이터 분리</strong>: 코드와 데이터를 명확히 분리</p>
                    <p><strong>디자이너 친화적</strong>: 프로그래머 없이도 설정 변경 가능</p>
                    <p><strong>재사용성</strong>: 하나의 설정으로 여러 Prefab에 적용</p>
                    <p><strong>버전 관리</strong>: 설정 변경사항을 Git으로 추적 가능</p>
                </div>

                <div class="tech-stack">
                    <h4>🔄 MonoBehaviour vs ScriptableObject</h4>
                    <p><strong>MonoBehaviour</strong>: GameObject에 부착, 런타임 데이터 관리</p>
                    <p><strong>ScriptableObject</strong>: 프로젝트 파일에 저장, 빌드 시점 설정</p>
                    <p><strong>역할 분리</strong>: 각각의 고유한 역할을 명확히 구분</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>빌드 시점 데이터</strong>: 런타임에 변경된 데이터는 저장되지 않음</p>
                    <p><strong>에디터 vs 플레이어</strong>: 에디터에서는 변경사항이 유지되지만 플레이어에서는 초기화</p>
                    <p><strong>상속 처리</strong>: Start() 메서드 오버라이드 시 base.Start() 호출 필수</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>로봇 타입별 설정</strong>: 각 로봇의 체력, 공격력, 방어력을 ScriptableObject로 관리</li>
                    <li><strong>건물별 설정</strong>: 생산 속도, 비용, 업그레이드 정보를 ScriptableObject로 관리</li>
                    <li><strong>무기 시스템</strong>: 각 무기의 데미지, 사거리, 발사 속도를 ScriptableObject로 관리</li>
                    <li><strong>리소스 설정</strong>: 각 리소스의 수집량, 재생 속도를 ScriptableObject로 관리</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🚀 다음 단계</h3>
                <ul class="content-list">
                    <li>더 많은 설정 필드 추가 (공격력, 방어력, 비용 등)</li>
                    <li>Action 시스템 구현</li>
                    <li>Armor 시스템 추가</li>
                    <li>업그레이드 시스템 구현</li>
                </ul>
            </div>
        </div>

        <!-- 강의 24: Command Post Setup (커맨드 포스트 설정) -->
        <div class="lecture-section">
            <h2 class="lecture-title">🏢 강의 24: Command Post Setup (커맨드 포스트 설정)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">건물 시스템 확장</strong>: <span style="color: #2c3e50;">다양한 건물 타입을 지원하기 위한 기반 구축</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드 중복 제거</strong>: <span style="color: #2c3e50;">SupplyHut과 Command Post의 공통 기능을 BaseBuilding으로 통합</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">확장성 확보</strong>: <span style="color: #2c3e50;">새로운 건물 추가 시 BaseBuilding을 상속받아 쉽게 구현</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">RTS 게임 기반</strong>: <span style="color: #2c3e50;">Command Post는 향후 유닛 생산과 자원 수집의 중심이 될 건물</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🏗️ 건물이 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">게임에서 병사들이 살고 일하는 집이에요. Supply Hut은 창고 같은 곳이고, Command Post는 사령부 같은 곳이에요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎮 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>다양한 건물</strong>: 게임에 여러 종류의 건물이 있어야 재미있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>코드 정리</strong>: 비슷한 건물들은 같은 코드를 사용해서 관리하기 쉬워요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>새 건물 만들기</strong>: 새로운 건물을 만들 때 기존 코드를 복사해서 쉽게 만들 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">모든 집(건물)은 기본적으로 문, 창문, 지붕이 있어요. BaseBuilding은 이런 기본 기능을 담고 있고, 각 집은 이걸 상속받아서 특별한 기능을 추가해요!</p>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. BaseBuilding 클래스 생성</span>
<span class="comment">// BaseBuilding: 모든 건물의 기본 클래스</span>
<span class="comment">// AbstractCommandable: 명령을 받을 수 있는 모든 객체의 기본 클래스</span>
<span class="comment">// 상속: BaseBuilding이 AbstractCommandable의 모든 기능을 상속받음</span>
<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// 모든 건물의 기본 클래스</span>
    <span class="comment">// BaseBuilding: "건물의 기본"이라는 의미</span>
    <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체의 기본 클래스 상속</span>
    <span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">BaseBuilding</span> : <span class="class-name">AbstractCommandable</span>
    {
        <span class="comment">// 모든 건물의 공통 기능을 AbstractCommandable에서 상속</span>
        <span class="comment">// - Select/Deselect 기능: 건물 선택/해제</span>
        <span class="comment">// - Health 관리: 건물의 체력 시스템</span>
        <span class="comment">// - DecalProjector 시각화: 선택 시 원형 표시</span>
        <span class="comment">// - UnitSO 설정: 건물의 기본 정보 (체력, 이름 등)</span>
        <span class="comment">// - AvailableCommands: 건물이 사용할 수 있는 명령들</span>
    }
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 BaseBuilding이 필요한가?</h4>
                    <ul>
                        <li><strong>코드 중복 제거</strong>: SupplyHut과 Command Post가 동일한 기능을 가지고 있어서 공통 클래스로 통합</li>
                        <li><strong>일관성 유지</strong>: 모든 건물이 동일한 선택/해제 시스템을 사용</li>
                        <li><strong>확장성</strong>: 새로운 건물 추가 시 BaseBuilding을 상속받아 쉽게 구현</li>
                        <li><strong>유지보수성</strong>: 건물 관련 공통 기능 수정 시 한 곳에서만 변경</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 2. SupplyHut.cs 삭제</span>
<span class="comment">// - 기존 SupplyHut 클래스는 BaseBuilding으로 대체</span>
<span class="comment">// - Supply Hut prefab에서 BaseBuilding 스크립트 사용</span>

<span class="comment">// 3. Command Post 설정</span>
<span class="comment">// - Command Post.asset 생성 (Health: 400)</span>
<span class="comment">// - DecalProjector 설정 (크기: 4x4)</span>
<span class="comment">// - NavMeshObstacle 설정 (크기: 2x0.25x2)</span>
<span class="comment">// - Layer를 Buildings로 변경</span>
                </div>

                <div class="info-box">
                    <h4>💡 왜 Command Post의 Health가 400인가?</h4>
                    <ul>
                        <li><strong>게임 밸런스</strong>: Supply Hut(100)보다 훨씬 강한 건물로 설정</li>
                        <li><strong>전략적 중요성</strong>: Command Post는 게임의 핵심 건물이므로 파괴하기 어려워야 함</li>
                        <li><strong>RTS 게임 관례</strong>: 메인 건물은 일반 건물보다 높은 체력을 가짐</li>
                        <li><strong>플레이어 경험</strong>: 중요한 건물이 쉽게 파괴되면 좌절감을 느낄 수 있음</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🏗️ 건물 시스템 아키텍처</h3>
                
                <div class="code-block">
<span class="comment">// 건물 상속 구조</span>
<span class="class-name">AbstractCommandable</span> (기본 선택/해제 기능)
    ↓
<span class="class-name">BaseBuilding</span> (모든 건물의 공통 기능)
    ↓
<span class="comment">// 향후 확장 가능:</span>
<span class="comment">// - SupplyHut : BaseBuilding</span>
<span class="comment">// - CommandPost : BaseBuilding</span>
<span class="comment">// - Barracks : BaseBuilding (유닛 생산)</span>
<span class="comment">// - Factory : BaseBuilding (기계 생산)</span>
                </div>

                <div class="info-box">
                    <h4>💡 왜 이런 구조를 사용하는가?</h4>
                    <ul>
                        <li><strong>Template Method Pattern</strong>: 공통 기능은 부모 클래스에서, 특별한 기능은 자식 클래스에서 구현</li>
                        <li><strong>DRY 원칙</strong>: Don't Repeat Yourself - 중복 코드 제거</li>
                        <li><strong>확장성</strong>: 새로운 건물 타입 추가 시 BaseBuilding만 상속받으면 됨</li>
                        <li><strong>일관성</strong>: 모든 건물이 동일한 인터페이스를 제공</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// Command Post의 역할 (향후 확장 예정)</span>
<span class="comment">// 1. 유닛 생산: Worker, Soldier 등 생산</span>
<span class="comment">// 2. 자원 수집: Worker들이 수집한 자원을 저장</span>
<span class="comment">// 3. 업그레이드: 건물과 유닛의 능력 향상</span>
<span class="comment">// 4. 연구: 새로운 기술 개발</span>

<span class="comment">// 현재 구현된 기능</span>
<span class="comment">// - 선택/해제 (ISelectable)</span>
<span class="comment">// - 체력 관리 (Health: 400)</span>
<span class="comment">// - 시각적 피드백 (DecalProjector)</span>
<span class="comment">// - NavMesh 장애물 (NavMeshObstacle)</span>
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>모듈화된 건물 시스템</strong>: BaseBuilding을 기반으로 한 확장 가능한 건물 구조</li>
                    <li><strong>설정 기반 밸런싱</strong>: UnitSO를 통한 체력 관리로 게임 밸런스 조정</li>
                    <li><strong>시각적 피드백</strong>: DecalProjector를 통한 명확한 선택 표시</li>
                    <li><strong>전략적 깊이</strong>: 다양한 건물 타입으로 게임의 전략성 향상</li>
                </ul>
            </div>
        </div>

        <!-- 강의 25: Actions with the Command Pattern (커맨드 패턴을 사용한 액션 시스템) -->
        <div class="lecture-section">
            <h2 class="lecture-title">⚡ 강의 25: Actions with the Command Pattern (커맨드 패턴을 사용한 액션 시스템)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">액션 시스템 확장</strong>: <span style="color: #2c3e50;">RTS 게임의 다양한 명령(Move, Attack, Build 등)을 체계적으로 관리</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드 결합도 감소</strong>: <span style="color: #2c3e50;">PlayerInput과 유닛 간의 직접적인 의존성 제거</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">유연한 명령 시스템</strong>: <span style="color: #2c3e50;">새로운 액션 추가 시 기존 코드 수정 없이 확장 가능</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">디자인 패턴 적용</strong>: <span style="color: #2c3e50;">Command Pattern을 통한 확장 가능한 아키텍처 구축</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🎮 게임 명령이 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">게임에서 병사들에게 내리는 명령이에요. "이동해!", "공격해!", "멈춰!" 같은 명령들이죠!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>다양한 명령</strong>: 게임에 여러 종류의 명령이 있어야 재미있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>쉽게 추가하기</strong>: 새로운 명령을 만들 때 기존 코드를 건드리지 않아도 돼요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>정리하기</strong>: 모든 명령을 한 곳에서 관리할 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">리모컨(Command Pattern)이 있어서 TV, 에어컨, 불빛을 모두 조절할 수 있어요. 새로운 기기를 사도 리모컨만 바꾸면 되죠!</p>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. ICommand 인터페이스 생성</span>
<span class="comment">// ICommand: 모든 명령이 구현해야 하는 기본 계약</span>
<span class="comment">// interface: 클래스가 반드시 구현해야 하는 메서드들을 정의</span>
<span class="comment">// Command Pattern: 명령을 객체로 캡슐화하여 요청과 실행을 분리하는 디자인 패턴</span>
<span class="keyword">namespace</span> GameDevTV.RTS.Commands
{
    <span class="comment">// 모든 명령의 기본 인터페이스</span>
    <span class="comment">// ICommand: "명령"이라는 의미를 가진 인터페이스 이름</span>
    <span class="keyword">public interface</span> <span class="class-name">ICommand</span>
    {
        <span class="comment">// 명령이 특정 상황에서 실행 가능한지 확인하는 메서드</span>
        <span class="comment">// CanHandle: "처리할 수 있는가?"라는 의미</span>
        <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체 (유닛 또는 건물)</span>
        <span class="comment">// RaycastHit: 마우스 클릭 지점의 정보</span>
        <span class="comment">// bool: 참/거짓 값 반환</span>
        <span class="keyword">bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit);
        
        <span class="comment">// 실제 명령을 실행하는 메서드</span>
        <span class="comment">// Handle: "처리하다"라는 의미</span>
        <span class="comment">// void: 반환값이 없음 (명령 실행만 함)</span>
        <span class="keyword">void</span> <span class="method-name">Handle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit);
    }
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 ICommand 인터페이스가 필요한가?</h4>
                    <ul>
                        <li><strong>공통 인터페이스</strong>: 모든 명령이 동일한 구조를 가지도록 보장</li>
                        <li><strong>확장성</strong>: 새로운 명령 추가 시 인터페이스만 구현하면 됨</li>
                        <li><strong>일관성</strong>: 모든 명령이 CanHandle과 Handle 메서드를 가짐</li>
                        <li><strong>다형성</strong>: 다양한 명령을 동일한 방식으로 처리 가능</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 2. ActionBase 추상 클래스 생성</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
<span class="comment">// abstract class: 직접 인스턴스를 만들 수 없고, 하위 클래스에서 상속받아 사용</span>
<span class="comment">// ScriptableObject: Unity에서 데이터를 저장하는 자산 타입</span>
<span class="comment">// ICommand: 위에서 정의한 명령 인터페이스</span>
<span class="keyword">namespace</span> GameDevTV.RTS.Commands
{
    <span class="comment">// 모든 액션의 기본 추상 클래스</span>
    <span class="comment">// ActionBase: "액션의 기본"이라는 의미</span>
    <span class="comment">// ScriptableObject: Unity Inspector에서 설정 가능한 에셋</span>
    <span class="comment">// ICommand: 명령 패턴의 인터페이스 구현</span>
    <span class="keyword">public abstract class</span> <span class="class-name">ActionBase</span> : <span class="class-name">ScriptableObject</span>, <span class="class-name">ICommand</span>
    {
        <span class="comment">// 명령이 특정 상황에서 실행 가능한지 확인하는 추상 메서드</span>
        <span class="comment">// abstract: 하위 클래스에서 반드시 구현해야 함</span>
        <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체</span>
        <span class="comment">// RaycastHit: 마우스 클릭 지점의 정보</span>
        <span class="comment">// bool: 참/거짓 값 반환</span>
        <span class="keyword">public abstract bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit);
        
        <span class="comment">// 실제 명령을 실행하는 추상 메서드</span>
        <span class="comment">// abstract: 하위 클래스에서 반드시 구현해야 함</span>
        <span class="comment">// void: 반환값이 없음 (명령 실행만 함)</span>
        <span class="keyword">public abstract void</span> <span class="method-name">Handle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit);
    }
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 ActionBase가 필요한가?</h4>
                    <ul>
                        <li><strong>ScriptableObject 상속</strong>: Unity Inspector에서 설정 가능</li>
                        <li><strong>추상 클래스</strong>: 공통 기능은 제공하고 구체적 구현은 강제</li>
                        <li><strong>Inspector 연동</strong>: MonoBehaviour가 아닌 ScriptableObject로 Inspector에서 참조 가능</li>
                        <li><strong>에셋 관리</strong>: 각 명령을 독립적인 에셋으로 관리</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 3. MoveCommand 구현</span>
<span class="comment">// MoveCommand: 이동 명령을 처리하는 구체적인 클래스</span>
<span class="comment">// CreateAssetMenu: Unity에서 에셋을 생성할 수 있는 메뉴 추가</span>
<span class="comment">// ActionBase: 위에서 정의한 추상 클래스 상속</span>
<span class="keyword">namespace</span> GameDevTV.RTS.Commands
{
    <span class="comment">// Unity에서 에셋을 생성할 수 있는 메뉴 설정</span>
    <span class="comment">// CreateAssetMenu: Unity Inspector에서 우클릭으로 에셋 생성 가능</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: 메뉴에서 보일 경로</span>
    <span class="comment">// order: 메뉴에서의 순서 (낮을수록 위에 표시)</span>
    [<span class="class-name">CreateAssetMenu</span>(fileName = <span class="string">"Move Action"</span>, menuName = <span class="string">"AI/Actions/Move"</span>, order = 100)]
    <span class="comment">// 이동 명령을 처리하는 구체적인 클래스</span>
    <span class="comment">// MoveCommand: "이동 명령"이라는 의미</span>
    <span class="comment">// ActionBase: 모든 명령의 기본 클래스 상속</span>
    <span class="keyword">public class</span> <span class="class-name">MoveCommand</span> : <span class="class-name">ActionBase</span>
    {
        <span class="comment">// 이동 명령이 실행 가능한지 확인하는 메서드</span>
        <span class="comment">// override: 부모 클래스의 추상 메서드를 구현</span>
        <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체</span>
        <span class="comment">// RaycastHit: 마우스 클릭 지점의 정보</span>
        <span class="keyword">public override bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit)
        {
            <span class="comment">// 객체가 IMoveable 인터페이스를 구현했는지 확인</span>
            <span class="comment">// is: 타입 확인 연산자</span>
            <span class="comment">// IMoveable: 이동 가능한 객체를 나타내는 인터페이스</span>
            <span class="comment">// 이동 가능한 객체만 이동 명령을 받을 수 있음</span>
            <span class="keyword">return</span> commandable <span class="keyword">is</span> <span class="class-name">IMoveable</span>;
        }

        <span class="comment">// 실제 이동 명령을 실행하는 메서드</span>
        <span class="comment">// override: 부모 클래스의 추상 메서드를 구현</span>
        <span class="comment">// AbstractCommandable: 명령을 받을 객체</span>
        <span class="comment">// RaycastHit: 마우스 클릭 지점의 정보</span>
        <span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit)
        {
            <span class="comment">// AbstractCommandable을 IMoveable로 캐스팅</span>
            <span class="comment">// (IMoveable): 명시적 타입 변환</span>
            <span class="comment">// IMoveable: 이동 가능한 객체의 인터페이스</span>
            <span class="class-name">IMoveable</span> moveable = (<span class="class-name">IMoveable</span>)commandable;
            
            <span class="comment">// 객체를 클릭한 지점으로 이동</span>
            <span class="comment">// MoveTo: 이동 목표 지점을 받아서 해당 위치로 이동</span>
            <span class="comment">// hit.point: 레이캐스트가 충돌한 지점의 3D 좌표</span>
            moveable.<span class="method-name">MoveTo</span>(hit.point);
        }
    }
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 MoveCommand가 필요한가?</h4>
                    <ul>
                        <li><strong>명령 캡슐화</strong>: 이동 로직을 별도 클래스로 분리</li>
                        <li><strong>조건 검사</strong>: CanHandle에서 IMoveable 인터페이스 확인</li>
                        <li><strong>실행 로직</span>: Handle에서 실제 이동 명령 실행</li>
                        <li><strong>에셋 생성</strong>: CreateAssetMenu로 Unity에서 쉽게 생성 가능</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 4. AbstractCommandable에 AvailableCommands 필드 추가</span>
<span class="comment">// AbstractCommandable: 명령을 받을 수 있는 모든 객체의 기본 클래스</span>
<span class="comment">// AvailableCommands: 각 객체가 사용할 수 있는 명령들의 배열</span>
<span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 설정 가능하게 함</span>
<span class="keyword">public abstract class</span> <span class="class-name">AbstractCommandable</span> : <span class="class-name">MonoBehaviour</span>, <span class="class-name">ISelectable</span>
{
    <span class="comment">// 각 객체가 사용할 수 있는 명령들의 배열</span>
    <span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 할당 가능하도록 함</span>
    <span class="comment">// ActionBase[]: 모든 명령의 기본 클래스 배열</span>
    <span class="comment">// { get; private set; }: 읽기 전용 프로퍼티 (외부에서 수정 불가)</span>
    [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public</span> <span class="class-name">ActionBase</span>[] <span class="property-name">AvailableCommands</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    <span class="comment">// ... 기타 필드들</span>
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 AvailableCommands 필드가 필요한가?</h4>
                    <ul>
                        <li><strong>유닛별 명령 제한</strong>: 각 유닛이 수행할 수 있는 명령을 제한</li>
                        <li><strong>Inspector 설정</strong>: Unity에서 각 유닛의 명령을 쉽게 설정</li>
                        <li><strong>확장성</strong>: 새로운 유닛 타입 추가 시 명령만 설정하면 됨</li>
                        <li><strong>유연성</strong>: 런타임에 명령을 동적으로 변경 가능</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 5. PlayerInput 리팩토링</span>
<span class="comment">// PlayerInput: 플레이어의 입력을 처리하는 클래스</span>
<span class="comment">// HandleRightClick: 오른쪽 클릭을 처리하는 메서드</span>
<span class="comment">// Command Pattern: 명령 패턴을 사용하여 입력과 실행을 분리</span>
<span class="keyword">private void</span> <span class="method-name">HandleRightClick</span>()
{
    <span class="comment">// ... 기존 코드 ...</span>
    
    <span class="comment">// 선택된 모든 유닛에 대해 반복</span>
    <span class="comment">// foreach: 배열이나 컬렉션의 모든 요소를 순회</span>
    <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
    <span class="comment">// abstractUnits: 선택된 유닛들의 컬렉션</span>
    <span class="keyword">foreach</span>(<span class="class-name">AbstractUnit</span> unit <span class="keyword">in</span> abstractUnits)
    {
        <span class="comment">// 각 유닛의 사용 가능한 명령들에 대해 반복</span>
        <span class="comment">// AvailableCommands: 유닛이 사용할 수 있는 명령들의 배열</span>
        <span class="comment">// ICommand: 모든 명령의 기본 인터페이스</span>
        <span class="keyword">foreach</span>(<span class="class-name">ICommand</span> command <span class="keyword">in</span> unit.<span class="property-name">AvailableCommands</span>)
        {
            <span class="comment">// 명령이 현재 상황에서 실행 가능한지 확인</span>
            <span class="comment">// CanHandle: 명령이 특정 상황에서 실행 가능한지 확인하는 메서드</span>
            <span class="comment">// unit: 명령을 받을 유닛</span>
            <span class="comment">// hit: 마우스 클릭 지점의 정보</span>
            <span class="keyword">if</span> (command.<span class="method-name">CanHandle</span>(unit, hit))
            {
                <span class="comment">// 명령을 실제로 실행</span>
                <span class="comment">// Handle: 실제 명령을 실행하는 메서드</span>
                <span class="comment">// unit: 명령을 받을 유닛</span>
                <span class="comment">// hit: 마우스 클릭 지점의 정보</span>
                command.<span class="method-name">Handle</span>(unit, hit);
            }
        }
    }
}
                </div>

                <div class="info-box">
                    <h4>💡 왜 PlayerInput 리팩토링이 필요한가?</h4>
                    <ul>
                        <li><strong>결합도 감소</strong>: PlayerInput이 구체적인 명령을 알 필요 없음</li>
                        <li><strong>확장성</strong>: 새로운 명령 추가 시 PlayerInput 수정 불필요</li>
                        <li><strong>유연성</strong>: 각 유닛의 명령을 동적으로 처리</li>
                        <li><strong>유지보수성</strong>: 명령 로직이 분산되어 관리하기 쉬움</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🏗️ Command Pattern 아키텍처</h3>
                
                <div class="code-block">
<span class="comment">// Command Pattern 구조</span>
<span class="class-name">ICommand</span> (인터페이스)
    ↓
<span class="class-name">ActionBase</span> (추상 클래스, ScriptableObject)
    ↓
<span class="comment">// 구체적인 명령들:</span>
<span class="comment">// - MoveCommand : 이동 명령</span>
<span class="comment">// - AttackCommand : 공격 명령 (향후)</span>
<span class="comment">// - BuildCommand : 건설 명령 (향후)</span>
<span class="comment">// - StopCommand : 정지 명령 (향후)</span>

<span class="comment">// 사용 흐름:</span>
<span class="comment">// PlayerInput → AbstractCommandable.AvailableCommands → ICommand.CanHandle() → ICommand.Handle()</span>
                </div>

                <div class="info-box">
                    <h4>💡 왜 이런 구조를 사용하는가?</h4>
                    <ul>
                        <li><strong>Command Pattern</strong>: 명령의 요청과 실행을 분리하여 결합도 감소</li>
                        <li><strong>Strategy Pattern</strong>: 다양한 명령 알고리즘을 동적으로 교체</li>
                        <li><strong>Template Method Pattern</strong>: ActionBase에서 공통 구조 정의</li>
                        <li><strong>Factory Pattern</strong>: ScriptableObject를 통한 명령 생성</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// 향후 확장 가능한 명령들</span>
<span class="comment">// 1. AttackCommand: 적 유닛/건물 공격</span>
<span class="comment">// 2. BuildCommand: 건물 건설</span>
<span class="comment">// 3. StopCommand: 현재 행동 중단</span>
<span class="comment">// 4. HoldPositionCommand: 위치 고수</span>
<span class="comment">// 5. PatrolCommand: 순찰</span>
<span class="comment">// 6. FollowCommand: 다른 유닛 따라가기</span>

<span class="comment">// 유닛별 명령 제한 예시</span>
<span class="comment">// - Worker: Move, Build, Gather</span>
<span class="comment">// - Soldier: Move, Attack, Stop, HoldPosition</span>
<span class="comment">// - Air Transport: Move, Stop, Follow</span>
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>모듈화된 명령 시스템</strong>: Command Pattern을 통한 확장 가능한 액션 구조</li>
                    <li><strong>유닛별 특화 명령</strong>: 각 로봇 타입별로 다른 명령 세트 제공</li>
                    <li><strong>설정 기반 명령</strong>: ScriptableObject를 통한 명령 관리</li>
                    <li><strong>전략적 깊이</strong>: 다양한 명령 조합으로 게임의 전략성 향상</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>🎯 강의 26: Command Context 도입</h2>
            
            <div class="subsection">
                <h3>🎯 이번 강의를 왜 해야 하는가?</h3>
                <div class="info-box">
                    <p><strong>문제점:</strong> 강의 25에서 Command Pattern을 도입했지만, 유닛들이 같은 위치로 이동하려고 해서 "춤추는" 현상이 발생했습니다.</p>
                    <p><strong>해결책:</strong> Command Context를 도입하여 명령에 더 많은 정보를 전달하고, radial placement 알고리즘을 MoveCommand 안에서 재구현합니다.</p>
                    <p><strong>목표:</strong> 유닛들이 원형으로 배치되어 자연스럽게 이동하도록 개선합니다.</p>
                </div>
            </div>

            <div class="subsection">
                <h3>🧒 초딩도 이해하기 쉬운 설명</h3>
                <div class="info-box">
                    <p>🎮 <strong>게임에서 일어난 일:</strong></p>
                    <p>• 여러 로봇을 선택하고 오른쪽 클릭하면 모두 같은 곳으로 가려고 해요</p>
                    <p>• 그러면 로봇들이 서로 밀어내면서 "춤추는" 것처럼 보여요</p>
                    <p>• 마치 학교에서 모두 같은 자리에 앉으려고 하면 서로 밀치는 것과 같아요</p>
                    
                    <p>🔧 <strong>해결 방법:</strong></p>
                    <p>• 로봇들에게 "너는 몇 번째야"라는 정보를 주어요</p>
                    <p>• 그러면 로봇들이 원 모양으로 예쁘게 배치되어요</p>
                    <p>• 마치 원형 테이블에 앉는 것처럼 깔끔하게 정렬돼요</p>
                </div>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. CommandContext 구조체 생성</span>
<span class="comment">// CommandContext: 명령 실행에 필요한 모든 정보를 담는 구조체</span>
<span class="comment">// struct: 값 타입으로 성능 최적화 (클래스보다 가벼움)</span>
<span class="keyword">public struct</span> <span class="class-name">CommandContext</span>
{
    <span class="comment">// 명령을 받을 수 있는 객체 (유닛 또는 건물)</span>
    <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 모든 객체의 기본 클래스</span>
    <span class="comment">// { get; private set; }: 읽기 전용 프로퍼티</span>
    <span class="keyword">public</span> <span class="class-name">AbstractCommandable</span> <span class="property-name">Commandable</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// 레이캐스트 충돌 정보</span>
    <span class="comment">// RaycastHit: 레이캐스트가 충돌한 지점의 정보 (위치, 노멀 등)</span>
    <span class="keyword">public</span> <span class="class-name">RaycastHit</span> <span class="property-name">Hit</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// 유닛의 순서 인덱스 (0부터 시작)</span>
    <span class="comment">// int: 정수 타입</span>
    <span class="comment">// 원형 배치에서 유닛의 위치를 계산하는 데 사용</span>
    <span class="keyword">public int</span> <span class="property-name">UnitIndex</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }

    <span class="comment">// CommandContext 생성자</span>
    <span class="comment">// commandable: 명령을 받을 객체</span>
    <span class="comment">// hit: 레이캐스트 충돌 정보</span>
    <span class="comment">// unitIndex: 유닛 순서 (기본값 0)</span>
    <span class="keyword">public</span> <span class="class-name">CommandContext</span>(<span class="class-name">AbstractCommandable</span> commandable, <span class="class-name">RaycastHit</span> hit, <span class="keyword">int</span> unitIndex = <span class="number">0</span>)
    {
        <span class="comment">// 전달받은 값들을 프로퍼티에 저장</span>
        <span class="property-name">Commandable</span> = commandable;
        <span class="property-name">Hit</span> = hit;
        <span class="property-name">UnitIndex</span> = unitIndex;
    }
}
                </div>

                <div class="code-block">
<span class="comment">// 2. ICommand 인터페이스 리팩토링</span>
<span class="keyword">public interface</span> <span class="class-name">ICommand</span>
{
    <span class="keyword">bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> context);
    <span class="keyword">void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> context);
}
                </div>

                <div class="code-block">
<span class="comment">// 3. MoveCommand에 radial placement 알고리즘 재구현</span>
<span class="comment">// Handle: 실제 이동 명령을 실행하는 메서드</span>
<span class="comment">// CommandContext: 명령 실행에 필요한 모든 정보</span>
<span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> context)
{
    <span class="comment">// Commandable을 AbstractUnit으로 캐스팅</span>
    <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
    <span class="comment">// (AbstractUnit): 명시적 타입 변환</span>
    <span class="class-name">AbstractUnit</span> unit = (<span class="class-name">AbstractUnit</span>)context.<span class="property-name">Commandable</span>;

    <span class="comment">// 첫 번째 유닛일 때 원형 배치 변수들 초기화</span>
    <span class="comment">// UnitIndex == 0: 첫 번째 유닛임을 의미</span>
    <span class="keyword">if</span> (context.<span class="property-name">UnitIndex</span> == <span class="number">0</span>)
    {
        <span class="comment">// 현재 레이어의 유닛 수 초기화</span>
        unitsOnLayer = <span class="number">0</span>;
        <span class="comment">// 현재 레이어에 배치할 수 있는 최대 유닛 수</span>
        maxUnitsOnLayer = <span class="number">1</span>;
        <span class="comment">// 현재 원의 반지름</span>
        circleRadius = <span class="number">0</span>;
        <span class="comment">// 각 유닛 간의 각도 간격</span>
        radialOffset = <span class="number">0</span>;
    }
    
    <span class="comment">// 원형 배치 계산</span>
    <span class="comment">// Vector3: 3차원 벡터 (x, y, z 좌표)</span>
    <span class="comment">// new Vector3: 새로운 벡터 생성</span>
    <span class="class-name">Vector3</span> targetPosition = <span class="keyword">new</span>(
        <span class="comment">// X 좌표: 클릭 지점 + 원의 반지름 * 코사인 값</span>
        <span class="comment">// Mathf.Cos: 코사인 함수 (각도를 라디안으로 변환)</span>
        <span class="comment">// radialOffset * unitsOnLayer: 현재 유닛의 각도</span>
        context.<span class="property-name">Hit</span>.<span class="property-name">point</span>.<span class="property-name">x</span> + circleRadius * <span class="class-name">Mathf</span>.<span class="property-name">Cos</span>(radialOffset * unitsOnLayer),
        <span class="comment">// Y 좌표: 클릭 지점과 동일 (높이 변화 없음)</span>
        context.<span class="property-name">Hit</span>.<span class="property-name">point</span>.<span class="property-name">y</span>,
        <span class="comment">// Z 좌표: 클릭 지점 + 원의 반지름 * 사인 값</span>
        <span class="comment">// Mathf.Sin: 사인 함수 (각도를 라디안으로 변환)</span>
        context.<span class="property-name">Hit</span>.<span class="property-name">point</span>.<span class="property-name">z</span> + circleRadius * <span class="class-name">Mathf</span>.<span class="property-name">Sin</span>(radialOffset * unitsOnLayer)
    );

    <span class="comment">// 계산된 위치로 유닛 이동</span>
    <span class="comment">// MoveTo: 유닛을 지정된 위치로 이동시키는 메서드</span>
    unit.<span class="method-name">MoveTo</span>(targetPosition);
    
    <span class="comment">// 현재 레이어의 유닛 수 증가</span>
    unitsOnLayer++;

    <span class="comment">// 다음 레이어로 넘어가기</span>
    <span class="comment">// 현재 레이어가 가득 찬 경우 새로운 레이어 생성</span>
    <span class="keyword">if</span> (unitsOnLayer >= maxUnitsOnLayer)
    {
        <span class="comment">// 새로운 레이어 시작</span>
        unitsOnLayer = <span class="number">0</span>;
        
        <span class="comment">// 원의 반지름을 유닛 크기만큼 증가</span>
        <span class="comment">// AgentRadius: NavMeshAgent의 반지름</span>
        <span class="comment">// radiusMultiplier: 반지름 증가 배수 (설정 가능)</span>
        circleRadius += unit.<span class="property-name">AgentRadius</span> * radiusMultiplier;
        
        <span class="comment">// 새로운 레이어의 최대 유닛 수 계산</span>
        <span class="comment">// Mathf.FloorToInt: 소수를 정수로 내림</span>
        <span class="comment">// 2 * Mathf.PI * circleRadius: 원의 둘레</span>
        <span class="comment">// unit.AgentRadius * 2: 유닛 간 최소 거리</span>
        maxUnitsOnLayer = <span class="class-name">Mathf</span>.<span class="method-name">FloorToInt</span>(<span class="number">2</span> * <span class="class-name">Mathf</span>.<span class="property-name">PI</span> * circleRadius / (unit.<span class="property-name">AgentRadius</span> * <span class="number">2</span>));
        
        <span class="comment">// 각 유닛 간의 각도 간격 계산</span>
        <span class="comment">// 2 * Mathf.PI: 전체 원의 각도 (360도)</span>
        <span class="comment">// maxUnitsOnLayer: 레이어에 배치할 수 있는 유닛 수</span>
        radialOffset = <span class="number">2</span> * <span class="class-name">Mathf</span>.<span class="property-name">PI</span> / maxUnitsOnLayer;
    }
}
                </div>

                <div class="code-block">
<span class="comment">// 4. PlayerInput에서 CommandContext 사용</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < abstractUnits.<span class="property-name">Count</span>; i++)
{
    <span class="class-name">CommandContext</span> context = <span class="keyword">new</span>(abstractUnits[i], hit, i);

    <span class="keyword">foreach</span>(<span class="class-name">ICommand</span> command <span class="keyword">in</span> abstractUnits[i].<span class="property-name">AvailableCommands</span>)
    {
        <span class="keyword">if</span> (command.<span class="method-name">CanHandle</span>(context))
        {
            command.<span class="method-name">Handle</span>(context);
            <span class="keyword">break</span>; <span class="comment">// 하나의 명령만 실행</span>
        }
    }
}
                </div>
            </div>

            <div class="subsection">
                <h3>🔧 핵심 기술 개념</h3>
                
                <div class="info-box">
                    <h4>📦 CommandContext 구조체</h4>
                    <ul>
                        <li><strong>struct 사용 이유</strong>: 성능 최적화 - 클래스보다 가벼움, 가비지 컬렉션 부담 없음</li>
                        <li><strong>UnitIndex</strong>: 유닛의 순서를 알려주는 인덱스 (0부터 시작)</li>
                        <li><strong>RaycastHit</strong>: 클릭한 지점의 정보 (위치, 노멀 등)</li>
                        <li><strong>AbstractCommandable</strong>: 명령을 받을 수 있는 객체 (유닛 또는 건물)</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🎯 Radial Placement 알고리즘</h4>
                    <ul>
                        <li><strong>원형 배치</strong>: 유닛들을 원 모양으로 배치하여 자연스러운 이동</li>
                        <li><strong>레이어 시스템</strong>: 첫 번째 원이 가득 차면 다음 원으로 확장</li>
                        <li><strong>수학적 계산</strong>: 삼각함수(Cos, Sin)를 사용한 정확한 위치 계산</li>
                        <li><strong>Agent Radius</strong>: 각 유닛의 크기를 고려한 간격 조정</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>⚙️ Radius Multiplier</h4>
                    <ul>
                        <li><strong>Inspector 조정</strong>: 런타임에서 원의 크기를 실시간으로 조정 가능</li>
                        <li><strong>기본값 3.5</strong>: 테스트를 통해 찾은 최적의 배치 간격</li>
                        <li><strong>ScriptableObject 장점</strong>: 설정값이 에디터에서 영구 저장됨</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// 이전: 모든 유닛이 같은 위치로 이동 (춤추는 현상)</span>
unit.<span class="method-name">MoveTo</span>(hit.<span class="property-name">point</span>);

<span class="comment">// 개선: 유닛별로 다른 위치에 원형 배치</span>
<span class="class-name">Vector3</span> targetPosition = <span class="keyword">new</span>(
    hit.<span class="property-name">point</span>.<span class="property-name">x</span> + circleRadius * <span class="class-name">Mathf</span>.<span class="property-name">Cos</span>(radialOffset * unitsOnLayer),
    hit.<span class="property-name">point</span>.<span class="property-name">y</span>,
    hit.<span class="property-name">point</span>.<span class="property-name">z</span> + circleRadius * <span class="class-name">Mathf</span>.<span class="property-name">Sin</span>(radialOffset * unitsOnLayer)
);
unit.<span class="method-name">MoveTo</span>(targetPosition);
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>자연스러운 유닛 배치</strong>: 원형 배치로 군집 이동의 현실감 향상</li>
                    <li><strong>확장 가능한 명령 시스템</strong>: CommandContext를 통한 복잡한 명령 구현</li>
                    <li><strong>런타임 설정 조정</strong>: Inspector에서 실시간으로 게임 밸런스 조정</li>
                    <li><strong>성능 최적화</strong>: struct 사용으로 메모리 효율성 개선</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>🎯 강의 27: UI 명령 표시</h2>
            
            <div class="subsection">
                <h3>🎯 이번 강의를 왜 해야 하는가?</h3>
                <div class="info-box">
                    <p><strong>문제점:</strong> 플레이어가 선택한 유닛들이 어떤 명령을 사용할 수 있는지 UI에서 확인할 수 없었습니다.</p>
                    <p><strong>해결책:</strong> 선택된 유닛들의 사용 가능한 명령을 UI 버튼으로 표시하여 직관적인 인터페이스를 제공합니다.</p>
                    <p><strong>목표:</strong> RTS 게임의 핵심인 명령 시스템을 시각적으로 표현하여 사용자 경험을 향상시킵니다.</p>
                </div>
            </div>

            <div class="subsection">
                <h3>🧒 초딩도 이해하기 쉬운 설명</h3>
                <div class="info-box">
                    <p>🎮 <strong>게임에서 일어난 일:</strong></p>
                    <p>• 로봇을 선택했는데 어떤 명령을 할 수 있는지 모르겠어요</p>
                    <p>• 마치 리모컨에 버튼이 있지만 어떤 기능인지 표시가 안 되어 있는 것 같아요</p>
                    <p>• 플레이어가 혼란스러워하고 게임을 제대로 즐기기 어려워요</p>
                    
                    <p>🔧 <strong>해결 방법:</strong></p>
                    <p>• 로봇을 선택하면 화면 아래에 사용할 수 있는 명령 버튼들이 나타나요</p>
                    <p>• 이동 명령은 화살표 아이콘으로 표시되어요</p>
                    <p>• 마치 스마트폰 앱처럼 직관적으로 어떤 기능인지 알 수 있어요</p>
                </div>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. ActionBase에 UI 필드 추가</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스 (ScriptableObject)</span>
<span class="comment">// ScriptableObject: Unity에서 데이터를 저장하는 자산 타입</span>
<span class="comment">// ICommand: 명령 패턴의 인터페이스</span>
<span class="keyword">public abstract class</span> <span class="class-name">ActionBase</span> : <span class="class-name">ScriptableObject</span>, <span class="class-name">ICommand</span>
{
    <span class="comment">// UI에 표시될 아이콘 스프라이트</span>
    <span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 설정 가능하게 함</span>
    <span class="comment">// Sprite: Unity의 2D 이미지 타입</span>
    [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public</span> <span class="class-name">Sprite</span> <span class="property-name">Icon</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// UI 슬롯 번호 (0-8, 총 9개 슬롯)</span>
    <span class="comment">// [Range(0, 8)]: Inspector에서 슬라이더로 0-8 범위 제한</span>
    <span class="comment">// int: 정수 타입</span>
    [<span class="keyword">field:</span> <span class="class-name">Range</span>(<span class="number">0</span>, <span class="number">8</span>)] [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public int</span> <span class="property-name">Slot</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
    
    <span class="comment">// 명령 실행 시 추가 클릭이 필요한지 여부</span>
    <span class="comment">// bool: 참/거짓 값</span>
    <span class="comment">// = true: 기본값을 true로 설정</span>
    [<span class="keyword">field:</span> <span class="class-name">SerializeField</span>] <span class="keyword">public bool</span> <span class="property-name">RequiresClickToActivate</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; } = <span class="keyword">true</span>;

    <span class="comment">// 명령이 특정 상황에서 실행 가능한지 확인하는 추상 메서드</span>
    <span class="comment">// abstract: 하위 클래스에서 반드시 구현해야 함</span>
    <span class="comment">// CommandContext: 명령 실행에 필요한 정보를 담은 구조체</span>
    <span class="keyword">public abstract bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> context);
    
    <span class="comment">// 실제 명령을 실행하는 추상 메서드</span>
    <span class="comment">// void: 반환값이 없음</span>
    <span class="keyword">public abstract void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> context);
}
                </div>

                <div class="code-block">
<span class="comment">// 2. UIActionButton 클래스 생성</span>
<span class="comment">// UIActionButton: UI에서 명령을 표시하는 개별 버튼 컴포넌트</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="keyword">public class</span> <span class="class-name">UIActionButton</span> : <span class="class-name">MonoBehaviour</span>
{
    <span class="comment">// 아이콘을 표시할 Image 컴포넌트</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
    <span class="comment">// Image: Unity UI에서 이미지를 표시하는 컴포넌트</span>
    [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Image</span> <span class="property-name">Icon</span>;

    <span class="comment">// 아이콘을 설정하는 메서드</span>
    <span class="comment">// Sprite icon: 설정할 아이콘 스프라이트</span>
    <span class="comment">// void: 반환값이 없음</span>
    <span class="keyword">public void</span> <span class="method-name">SetIcon</span>(<span class="class-name">Sprite</span> icon)
    {
        <span class="comment">// 아이콘이 null인 경우 (명령이 없을 때)</span>
        <span class="comment">// Image 컴포넌트를 비활성화하여 빈 버튼으로 만듦</span>
        <span class="keyword">if</span> (icon == <span class="keyword">null</span>)
        {
            <span class="comment">// enabled = false: Image 컴포넌트를 비활성화</span>
            <span class="property-name">Icon</span>.<span class="property-name">enabled</span> = <span class="keyword">false</span>;
        }
        <span class="comment">// 아이콘이 있는 경우 (명령이 있을 때)</span>
        <span class="keyword">else</span>
        {
            <span class="comment">// sprite: Image에 표시할 스프라이트 설정</span>
            <span class="property-name">Icon</span>.<span class="property-name">sprite</span> = icon;
            <span class="comment">// enabled = true: Image 컴포넌트를 활성화</span>
            <span class="property-name">Icon</span>.<span class="property-name">enabled</span> = <span class="keyword">true</span>;
        }
    }
}
                </div>

                <div class="code-block">
<span class="comment">// 3. ActionsUI 클래스 생성</span>
<span class="comment">// ActionsUI: 전체 명령 UI를 관리하는 메인 컨트롤러</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="keyword">public class</span> <span class="class-name">ActionsUI</span> : <span class="class-name">MonoBehaviour</span>
{
    <span class="comment">// UI 버튼들의 배열</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
    <span class="comment">// UIActionButton[]: 개별 버튼 컴포넌트들의 배열</span>
    [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">UIActionButton</span>[] <span class="property-name">ActionButtons</span>;
    
    <span class="comment">// 현재 선택된 유닛들을 저장하는 HashSet</span>
    <span class="comment">// HashSet: 중복을 허용하지 않는 컬렉션</span>
    <span class="comment">// AbstractCommandable: 유닛과 건물 모두 포함 (명령을 받을 수 있는 모든 객체)</span>
    <span class="comment">// new(12): 초기 용량을 12로 설정 (성능 최적화)</span>
    <span class="keyword">private</span> <span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt; selectedUnits = <span class="keyword">new</span>(<span class="number">12</span>);

    <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
    <span class="comment">// Awake: GameObject가 생성될 때 한 번만 호출되는 Unity 생명주기 메서드</span>
    <span class="keyword">private void</span> <span class="method-name">Awake</span>()
    {
        <span class="comment">// 유닛 선택 이벤트 구독</span>
        <span class="comment">// Bus: 이벤트 버스 패턴을 사용한 이벤트 시스템</span>
        <span class="comment">// UnitSelectedEvent: 유닛이 선택되었을 때 발생하는 이벤트</span>
        <span class="comment">// +=: 이벤트 핸들러 추가 (구독)</span>
        <span class="class-name">Bus</span>&lt;<span class="class-name">UnitSelectedEvent</span>&gt;.<span class="property-name">OnEvent</span> += <span class="method-name">HandleUnitSelected</span>;
        
        <span class="comment">// 유닛 선택 해제 이벤트 구독</span>
        <span class="comment">// UnitDeselectedEvent: 유닛의 선택이 해제되었을 때 발생하는 이벤트</span>
        <span class="class-name">Bus</span>&lt;<span class="class-name">UnitDeselectedEvent</span>&gt;.<span class="property-name">OnEvent</span> += <span class="method-name">HandleUnitDeselected</span>;

        <span class="comment">// 모든 버튼을 기본적으로 비활성화</span>
        <span class="comment">// foreach: 배열의 모든 요소를 순회</span>
        <span class="keyword">foreach</span>(<span class="class-name">UIActionButton</span> actionButton <span class="keyword">in</span> <span class="property-name">ActionButtons</span>)
        {
            <span class="comment">// SetIcon(null): 아이콘을 제거하여 빈 버튼으로 만듦</span>
            actionButton.<span class="method-name">SetIcon</span>(<span class="keyword">null</span>);
        }
    }

    <span class="comment">// UI 버튼들을 업데이트하는 메서드</span>
    <span class="comment">// 선택된 유닛들의 사용 가능한 명령에 따라 버튼 상태를 변경</span>
    <span class="keyword">private void</span> <span class="method-name">RefreshButtons</span>()
    {
        <span class="comment">// 사용 가능한 명령들을 저장할 HashSet</span>
        <span class="comment">// HashSet: 중복을 허용하지 않는 컬렉션</span>
        <span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
        <span class="comment">// new(9): 초기 용량을 9로 설정 (최대 9개 슬롯)</span>
        <span class="class-name">HashSet</span>&lt;<span class="class-name">ActionBase</span>&gt; availableCommands = <span class="keyword">new</span>(<span class="number">9</span>);

        <span class="comment">// 선택된 모든 유닛의 명령들을 수집</span>
        <span class="comment">// foreach: HashSet의 모든 요소를 순회</span>
        <span class="keyword">foreach</span> (<span class="class-name">AbstractCommandable</span> commandable <span class="keyword">in</span> selectedUnits)
        {
            <span class="comment">// 각 유닛/건물의 AvailableCommands를 HashSet에 추가</span>
            <span class="comment">// AddRange: 배열의 모든 요소를 HashSet에 추가 (중복 자동 제거)</span>
            availableCommands.<span class="method-name">AddRange</span>(commandable.<span class="property-name">AvailableCommands</span>);
        }

        <span class="comment">// 각 슬롯에 맞는 명령 아이콘 설정</span>
        <span class="comment">// for: 배열의 인덱스를 사용한 반복</span>
        <span class="comment">// ActionButtons.Length: UI 버튼의 개수</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="property-name">ActionButtons</span>.<span class="property-name">Length</span>; i++)
        {
            <span class="comment">// LINQ를 사용하여 특정 슬롯에 맞는 명령 찾기</span>
            <span class="comment">// Where: 조건에 맞는 요소만 필터링</span>
            <span class="comment">// FirstOrDefault: 첫 번째 요소를 반환하거나 없으면 null</span>
            <span class="class-name">ActionBase</span> actionForSlot = availableCommands.<span class="method-name">Where</span>(action => action.<span class="property-name">Slot</span> == i).<span class="method-name">FirstOrDefault</span>();

            <span class="comment">// 해당 슬롯에 명령이 있는 경우</span>
            <span class="keyword">if</span> (actionForSlot != <span class="keyword">null</span>)
            {
                <span class="comment">// 버튼에 명령의 아이콘 설정</span>
                <span class="property-name">ActionButtons</span>[i].<span class="method-name">SetIcon</span>(actionForSlot.<span class="property-name">Icon</span>);
            }
            <span class="comment">// 해당 슬롯에 명령이 없는 경우</span>
            <span class="keyword">else</span>
            {
                <span class="comment">// 버튼을 빈 상태로 만듦</span>
                <span class="property-name">ActionButtons</span>[i].<span class="method-name">SetIcon</span>(<span class="keyword">null</span>);
            }
        }
    }
}
                </div>
            </div>

            <div class="subsection">
                <h3>🔧 핵심 기술 개념</h3>
                
                <div class="info-box">
                    <h4>🎨 UI 시스템 설계</h4>
                    <ul>
                        <li><strong>Icon 필드</strong>: 명령을 나타내는 스프라이트 아이콘</li>
                        <li><strong>Slot 필드</strong>: UI에서 표시될 위치 (0-8, 총 9개 슬롯)</li>
                        <li><strong>RequiresClickToActivate</strong>: 명령 실행 시 추가 클릭이 필요한지 여부</li>
                        <li><strong>Range 속성</strong>: Inspector에서 슬롯 값을 0-8 범위로 제한</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🔄 이벤트 기반 UI 업데이트</h4>
                    <ul>
                        <li><strong>UnitSelectedEvent</strong>: 유닛 선택 시 UI 버튼 업데이트</li>
                        <li><strong>UnitDeselectedEvent</strong>: 유닛 선택 해제 시 UI 버튼 업데이트</li>
                        <li><strong>HashSet 사용</strong>: 중복 제거 및 빠른 검색을 위한 컬렉션</li>
                        <li><strong>LINQ Where</span>: 특정 슬롯에 맞는 명령을 찾기 위한 필터링</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🎯 UI 버튼 관리</h4>
                    <ul>
                        <li><strong>UIActionButton</strong>: 개별 버튼의 아이콘 관리</li>
                        <li><strong>SetIcon 메서드</strong>: 아이콘 설정 및 활성화/비활성화</li>
                        <li><strong>null 처리</strong>: 아이콘이 없을 때 버튼 비활성화</li>
                        <li><strong>일관된 위치</strong>: 같은 명령은 항상 같은 슬롯에 표시</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// 이전: 명령이 무엇인지 알 수 없음</span>
<span class="comment">// 플레이어가 유닛을 선택해도 어떤 명령을 사용할 수 있는지 모름</span>

<span class="comment">// 개선: 직관적인 UI 명령 표시</span>
<span class="comment">// 1. 유닛 선택</span>
<span class="comment">// 2. UI에 사용 가능한 명령 아이콘 표시</span>
<span class="comment">// 3. 플레이어가 명령을 시각적으로 확인 가능</span>
<span class="comment">// 4. 일관된 슬롯 위치로 혼란 방지</span>
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>직관적인 사용자 인터페이스</strong>: 명령 아이콘으로 사용자 경험 향상</li>
                    <li><strong>일관된 UI 배치</strong>: 같은 명령은 항상 같은 위치에 표시</li>
                    <li><strong>확장 가능한 명령 시스템</strong>: 새로운 명령 추가 시 UI 자동 업데이트</li>
                    <li><strong>이벤트 기반 업데이트</strong>: 유닛 선택 상태에 따른 실시간 UI 반응</li>
                </ul>
            </div>
        </div>

        <div class="section">
            <h2>🎮 강의 28: UI 버튼 클릭으로 명령 실행</h2>
            
            <div class="subsection">
                <h3>🎯 이번 강의를 왜 해야 하는가?</h3>
                <div class="info-box">
                    <p><strong>문제점:</strong> UI에 명령 아이콘은 표시되지만, 실제로 클릭해도 아무 일이 일어나지 않았습니다.</p>
                    <p><strong>해결책:</strong> UI 버튼 클릭 시 해당 명령을 활성화하고, 월드 클릭 시 명령을 실행하는 시스템을 구현합니다.</p>
                    <p><strong>목표:</strong> 완전한 UI 기반 명령 시스템을 구축하여 직관적인 RTS 게임플레이를 제공합니다.</p>
                </div>
            </div>

            <div class="subsection">
                <h3>🧒 초딩도 이해하기 쉬운 설명</h3>
                <div class="info-box">
                    <p>🎮 <strong>게임에서 일어난 일:</strong></p>
                    <p>• 화면 아래에 이동 버튼이 보이지만 클릭해도 아무 일이 안 일어나요</p>
                    <p>• 마치 리모컨의 버튼을 눌러도 TV가 켜지지 않는 것 같아요</p>
                    <p>• 플레이어가 버튼을 눌러도 로봇이 움직이지 않아서 답답해요</p>
                    
                    <p>🔧 <strong>해결 방법:</strong></p>
                    <p>• 이동 버튼을 클릭하면 "이동 모드"가 활성화되어요</p>
                    <p>• 그 다음에 땅을 클릭하면 로봇들이 그곳으로 이동해요</p>
                    <p>• 마치 스마트폰에서 앱을 선택하고 위치를 지정하는 것 같아요</p>
                </div>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. UIActionButton에 Button 참조 및 클릭 핸들러 추가</span>
<span class="comment">// RequireComponent: 이 컴포넌트가 추가되면 자동으로 Button 컴포넌트도 추가됨</span>
<span class="comment">// Unity의 컴포넌트 의존성을 강제하는 방법</span>
[<span class="class-name">RequireComponent</span>(<span class="keyword">typeof</span>(<span class="class-name">Button</span>))]
<span class="keyword">public class</span> <span class="class-name">UIActionButton</span> : <span class="class-name">MonoBehaviour</span>
{
    <span class="comment">// 아이콘을 표시할 Image 컴포넌트 참조</span>
    <span class="comment">// SerializeField: Inspector에서 할당 가능하도록 함</span>
    [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Image</span> <span class="property-name">icon</span>;
    
    <span class="comment">// 실제 버튼 컴포넌트 참조 - 클릭 이벤트를 처리하기 위해 필요</span>
    <span class="keyword">private</span> <span class="class-name">Button</span> <span class="property-name">button</span>;

    <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
    <span class="keyword">private void</span> <span class="method-name">Awake</span>()
    {
        <span class="comment">// 같은 GameObject에서 Button 컴포넌트를 가져옴</span>
        <span class="comment">// RequireComponent로 인해 null이 될 수 없음</span>
        <span class="property-name">button</span> = <span class="method-name">GetComponent</span>&lt;<span class="class-name">Button</span>&gt;();
    }

    <span class="comment">// 버튼을 활성화하고 클릭 이벤트를 설정하는 메서드</span>
    <span class="comment">// ActionBase: 어떤 명령인지, UnityAction: 클릭 시 실행할 함수</span>
    <span class="keyword">public void</span> <span class="method-name">EnableFor</span>(<span class="class-name">ActionBase</span> action, <span class="class-name">UnityAction</span> onClick)
    {
        <span class="comment">// 액션의 아이콘을 버튼에 설정</span>
        <span class="method-name">SetIcon</span>(action.<span class="property-name">Icon</span>);
        
        <span class="comment">// 버튼을 클릭 가능한 상태로 만듦</span>
        <span class="property-name">button</span>.<span class="property-name">interactable</span> = <span class="keyword">true</span>;
        
        <span class="comment">// 클릭 시 실행될 함수를 이벤트에 등록</span>
        <span class="comment">// AddListener: Unity의 이벤트 시스템에서 함수를 구독하는 방법</span>
        <span class="property-name">button</span>.<span class="property-name">onClick</span>.<span class="method-name">AddListener</span>(onClick);
    }

    <span class="comment">// 버튼을 비활성화하고 클릭 이벤트를 제거하는 메서드</span>
    <span class="keyword">public void</span> <span class="method-name">Disable</span>()
    {
        <span class="comment">// 아이콘을 제거하여 빈 버튼으로 만듦</span>
        <span class="method-name">SetIcon</span>(<span class="keyword">null</span>);
        
        <span class="comment">// 버튼을 클릭할 수 없는 상태로 만듦</span>
        <span class="property-name">button</span>.<span class="property-name">interactable</span> = <span class="keyword">false</span>;
        
        <span class="comment">// 등록된 모든 클릭 이벤트를 제거</span>
        <span class="comment">// 메모리 누수 방지 및 깔끔한 상태 유지</span>
        <span class="property-name">button</span>.<span class="property-name">onClick</span>.<span class="method-name">RemoveAllListeners</span>();
    }
}
                </div>

                <div class="code-block">
<span class="comment">// 2. ActionSelectedEvent 이벤트 생성</span>
<span class="comment">// UI에서 액션 버튼이 클릭되었을 때 발생하는 이벤트</span>
<span class="comment">// Event Bus 패턴을 사용하여 UI와 PlayerInput 간의 느슨한 결합 구현</span>
<span class="keyword">public struct</span> <span class="class-name">ActionSelectedEvent</span> : <span class="class-name">IEvent</span>
{
    <span class="comment">// 선택된 액션 정보를 담는 프로퍼티</span>
    <span class="comment">// ActionBase: ScriptableObject로 정의된 명령 (MoveCommand, BuildUnitCommand 등)</span>
    <span class="keyword">public</span> <span class="class-name">ActionBase</span> <span class="property-name">Action</span> { <span class="keyword">get</span>; }

    <span class="comment">// 이벤트 생성자 - 액션 정보를 받아서 이벤트 객체 생성</span>
    <span class="keyword">public</span> <span class="method-name">ActionSelectedEvent</span>(<span class="class-name">ActionBase</span> action)
    {
        <span class="comment">// 전달받은 액션을 프로퍼티에 저장</span>
        <span class="property-name">Action</span> = action;
    }
}
                </div>

                <div class="code-block">
<span class="comment">// 3. ActionsUI에서 Enable/Disable 메서드 사용</span>
<span class="comment">// 선택된 유닛들의 사용 가능한 명령에 따라 UI 버튼들을 업데이트하는 메서드</span>
<span class="keyword">private void</span> <span class="method-name">RefreshButtons</span>()
{
    <span class="comment">// 사용 가능한 명령들을 저장할 HashSet</span>
    <span class="comment">// HashSet: 중복을 허용하지 않는 컬렉션, 같은 명령이 여러 유닛에 있어도 하나만 저장</span>
    <span class="comment">// 용량 9: 최대 9개의 슬롯을 고려</span>
    <span class="class-name">HashSet</span>&lt;<span class="class-name">ActionBase</span>&gt; availableCommands = <span class="keyword">new</span>(<span class="number">9</span>);

    <span class="comment">// 선택된 모든 유닛의 명령들을 수집</span>
    <span class="comment">// AbstractCommandable: 유닛과 건물 모두 포함 (명령을 받을 수 있는 모든 객체)</span>
    <span class="keyword">foreach</span> (<span class="class-name">AbstractCommandable</span> commandable <span class="keyword">in</span> selectedUnits)
    {
        <span class="comment">// 각 유닛/건물의 AvailableCommands를 HashSet에 추가</span>
        <span class="comment">// UnionWith: 중복 제거하면서 모든 명령을 합침</span>
        availableCommands.<span class="method-name">AddRange</span>(commandable.<span class="property-name">AvailableCommands</span>);
    }

    <span class="comment">// 각 슬롯에 맞는 명령 버튼 활성화/비활성화</span>
    <span class="comment">// actionButtons.Length: UI에 있는 버튼의 개수 (보통 9개)</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < actionButtons.<span class="property-name">Length</span>; i++)
    {
        <span class="comment">// 현재 슬롯(i)에 해당하는 명령을 찾음</span>
        <span class="comment">// Where: 조건에 맞는 요소만 필터링</span>
        <span class="comment">// FirstOrDefault: 첫 번째 요소를 반환하거나 없으면 null 반환</span>
        <span class="class-name">ActionBase</span> actionForSlot = availableCommands.<span class="method-name">Where</span>(action => action.<span class="property-name">Slot</span> == i).<span class="method-name">FirstOrDefault</span>();

        <span class="comment">// 해당 슬롯에 명령이 있으면 버튼 활성화</span>
        <span class="keyword">if</span> (actionForSlot != <span class="keyword">null</span>)
        {
            <span class="comment">// EnableFor: 버튼에 아이콘 설정, 클릭 이벤트 등록, 활성화</span>
            <span class="comment">// HandleClick: 클릭 시 ActionSelectedEvent를 발생시키는 함수</span>
            actionButtons[i].<span class="method-name">EnableFor</span>(actionForSlot, <span class="method-name">HandleClick</span>(actionForSlot));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// 해당 슬롯에 명령이 없으면 버튼 비활성화</span>
            <span class="comment">// Disable: 아이콘 제거, 클릭 이벤트 제거, 비활성화</span>
            actionButtons[i].<span class="method-name">Disable</span>();
        }
    }
}

<span class="comment">// 클릭 이벤트 핸들러를 생성하는 메서드</span>
<span class="comment">// UnityAction을 반환하여 버튼의 onClick 이벤트에 등록</span>
<span class="keyword">private</span> <span class="class-name">UnityAction</span> <span class="method-name">HandleClick</span>(<span class="class-name">ActionBase</span> action)
{
    <span class="comment">// 람다 표현식을 사용하여 클릭 시 실행될 함수를 반환</span>
    <span class="comment">// () => : 매개변수가 없는 함수</span>
    <span class="comment">// Bus&lt;ActionSelectedEvent&gt;.Raise: Event Bus를 통해 ActionSelectedEvent 발생</span>
    <span class="comment">// new ActionSelectedEvent(action): 선택된 액션 정보를 담은 이벤트 객체 생성</span>
    <span class="keyword">return</span> () => <span class="class-name">Bus</span>&lt;<span class="class-name">ActionSelectedEvent</span>&gt;.<span class="method-name">Raise</span>(<span class="keyword">new</span> <span class="class-name">ActionSelectedEvent</span>(action));
}
                </div>

                <div class="code-block">
<span class="comment">// 4. PlayerInput에서 ActionSelectedEvent 처리 및 UI/월드 클릭 구분</span>
<span class="comment">// 현재 활성화된 액션을 추적하는 변수</span>
<span class="comment">// UI에서 액션 버튼을 클릭하면 이 변수에 해당 액션이 저장됨</span>
<span class="keyword">private</span> <span class="class-name">ActionBase</span> activeAction;

<span class="comment">// 마우스 다운이 UI에서 발생했는지 추적하는 변수</span>
<span class="comment">// UI 클릭과 월드 클릭을 구분하기 위해 필요</span>
<span class="keyword">private bool</span> wasMouseDownOnUI;

<span class="comment">// 컴포넌트 초기화 시 이벤트 구독</span>
<span class="keyword">private void</span> <span class="method-name">Awake</span>()
{
    <span class="comment">// ... 기존 코드 ...</span>
    <span class="comment">// ActionSelectedEvent 구독 - UI에서 액션 버튼 클릭 시 호출됨</span>
    <span class="class-name">Bus</span>&lt;<span class="class-name">ActionSelectedEvent</span>&gt;.<span class="property-name">OnEvent</span> += <span class="method-name">HandleActionSelected</span>;
}

<span class="comment">// ActionSelectedEvent 처리 메서드</span>
<span class="comment">// UI에서 액션 버튼이 클릭되면 호출되어 activeAction을 설정</span>
<span class="keyword">private void</span> <span class="method-name">HandleActionSelected</span>(<span class="class-name">ActionSelectedEvent</span> evt) => activeAction = evt.<span class="property-name">Action</span>;

<span class="comment">// 마우스 다운 처리 - UI 클릭 여부를 기록</span>
<span class="keyword">private void</span> <span class="method-name">HandleMouseDown</span>()
{
    <span class="comment">// 현재 마우스 위치가 UI 위에 있는지 확인</span>
    <span class="comment">// EventSystem.current.IsPointerOverGameObject(): UI 요소 위에 마우스가 있는지 체크</span>
    wasMouseDownOnUI = <span class="class-name">EventSystem</span>.<span class="property-name">current</span>.<span class="method-name">IsPointerOverGameObject</span>();
    <span class="comment">// ... 기존 코드 ...</span>
}

<span class="comment">// 왼쪽 마우스 클릭 처리 - UI 클릭과 월드 클릭을 구분</span>
<span class="keyword">private void</span> <span class="method-name">HandleLeftClick</span>()
{
    <span class="comment">// 활성화된 액션이 없고 선택 가능한 유닛을 클릭한 경우</span>
    <span class="comment">// 일반적인 유닛 선택 모드</span>
    <span class="keyword">if</span> (activeAction == <span class="keyword">null</span> 
        && <span class="class-name">Physics</span>.<span class="method-name">Raycast</span>(cameraRay, <span class="keyword">out</span> <span class="class-name">RaycastHit</span> hit, <span class="keyword">float</span>.<span class="property-name">MaxValue</span>, selectableUnitsLayers)
        && hit.<span class="property-name">collider</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">ISelectable</span> selectable))
    {
        <span class="comment">// 일반적인 유닛 선택</span>
        selectable.<span class="method-name">Select</span>();
    }
    <span class="comment">// 활성화된 액션이 있고 UI가 아닌 월드를 클릭한 경우</span>
    <span class="comment">// 명령 실행 모드</span>
    <span class="keyword">else if</span> (activeAction != <span class="keyword">null</span>
        && !<span class="class-name">EventSystem</span>.<span class="property-name">current</span>.<span class="method-name">IsPointerOverGameObject</span>()
        && <span class="class-name">Physics</span>.<span class="method-name">Raycast</span>(cameraRay, <span class="keyword">out</span> hit, <span class="keyword">float</span>.<span class="property-name">MaxValue</span>, floorLayers))
    {
        <span class="comment">// 활성화된 명령 실행</span>
        <span class="class-name">List</span>&lt;<span class="class-name">AbstractUnit</span>&gt; abstractUnits = selectedUnits
            .<span class="method-name">Where</span>((unit) => unit <span class="keyword">is</span> <span class="class-name">AbstractUnit</span>)
            .<span class="method-name">Cast</span>&lt;<span class="class-name">AbstractUnit</span>&gt;()
            .<span class="method-name">ToList</span>();
        
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < abstractUnits.<span class="property-name">Count</span>; i++)
        {
            <span class="class-name">CommandContext</span> context = <span class="keyword">new</span>(abstractUnits[i], hit, i);
            activeAction.<span class="method-name">Handle</span>(context);
        }

        activeAction = <span class="keyword">null</span>;
    }
}
                </div>
            </div>

            <div class="subsection">
                <h3>🔧 핵심 기술 개념</h3>
                
                <div class="info-box">
                    <h4>🎮 UI 버튼 상호작용</h4>
                    <ul>
                        <li><strong>RequireComponent</strong>: Button 컴포넌트가 반드시 있어야 함을 보장</li>
                        <li><strong>UnityAction</strong>: Unity의 델리게이트 타입으로 버튼 클릭 이벤트 처리</li>
                        <li><strong>EnableFor/Disable</strong>: 버튼의 활성화/비활성화 상태 관리</li>
                        <li><strong>AddListener/RemoveAllListeners</strong>: 클릭 이벤트 리스너 관리</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🔄 이벤트 기반 명령 시스템</h4>
                    <ul>
                        <li><strong>ActionSelectedEvent</strong>: UI 버튼 클릭 시 발생하는 이벤트</li>
                        <li><strong>activeAction</strong>: 현재 활성화된 명령을 추적하는 상태</li>
                        <li><strong>이벤트 버스</strong>: UI와 PlayerInput 간의 느슨한 결합</li>
                        <li><strong>델리게이트 함수</strong>: HandleClick에서 반환하는 UnityAction</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🎯 UI와 월드 클릭 구분</h4>
                    <ul>
                        <li><strong>EventSystem.current.IsPointerOverGameObject()</strong>: 마우스가 UI 위에 있는지 확인</li>
                        <li><strong>wasMouseDownOnUI</strong>: 드래그 시작 시점의 UI 상태 기록</li>
                        <li><strong>Guardian Pattern</strong>: activeAction이나 UI 클릭 시 드래그 비활성화</li>
                        <li><strong>레이어 구분</strong>: selectableUnitsLayers vs floorLayers</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>🔗 LINQ 활용</h4>
                    <ul>
                        <li><strong>Where + Cast + ToList</strong>: 타입 필터링과 캐스팅을 한 번에 처리</li>
                        <li><strong>코드 간소화</strong>: 반복문과 조건문을 LINQ로 대체</li>
                        <li><strong>타입 안전성</strong>: 컴파일 타임에 타입 검증</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// 이전: UI 버튼이 표시되지만 클릭해도 아무 일이 일어나지 않음</span>
<span class="comment">// 플레이어가 혼란스러워하고 게임을 제대로 즐기기 어려움</span>

<span class="comment">// 개선: 완전한 UI 기반 명령 시스템</span>
<span class="comment">// 1. UI 버튼 클릭 → 명령 활성화</span>
<span class="comment">// 2. 월드 클릭 → 활성화된 명령 실행</span>
<span class="comment">// 3. UI와 월드 클릭을 명확히 구분</span>
<span class="comment">// 4. 직관적인 2단계 명령 시스템</span>
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>완전한 UI 명령 시스템</strong>: 버튼 클릭부터 명령 실행까지 완전한 플로우</li>
                    <li><strong>직관적인 사용자 경험</strong>: 2단계 명령 시스템으로 명확한 피드백</li>
                    <li><strong>UI와 게임월드 분리</strong>: 클릭 컨텍스트에 따른 다른 동작</li>
                    <li><strong>이벤트 기반 아키텍처</strong>: 느슨한 결합으로 확장성 향상</li>
                    <li><strong>상태 기반 명령 관리</strong>: activeAction으로 명령 상태 추적</li>
                </ul>
            </div>
        </div>

        <!-- Lecture 29: The Build Unit Command -->
        <div class="lecture-section">
            <h2>📚 Lecture 29: The Build Unit Command</h2>
            
            <div class="subsection">
                <h3>🎯 강의 목표</h3>
                <p>건물에서 유닛을 빌드하는 Build Unit Command 시스템을 구현하여 RTS 게임의 핵심 기능인 유닛 생산을 가능하게 합니다.</p>
            </div>

            <div class="subsection">
                <h3>🤔 왜 필요한가?</h3>
                <ul>
                    <li><strong>RTS 게임의 핵심 기능</strong>: 건물에서 유닛을 생산하는 것은 모든 RTS 게임의 기본 기능</li>
                    <li><strong>게임 경제 시스템</strong>: 자원을 소모하여 유닛을 생산하는 경제적 전략 요소</li>
                    <li><strong>시간 기반 생산</strong>: 즉시 생성이 아닌 시간이 걸리는 현실적인 생산 시스템</li>
                    <li><strong>명령 패턴 확장</strong>: 기존 Command Pattern을 건물 명령으로 확장</li>
                    <li><strong>UI 통합</strong>: 건물 선택 시 빌드 명령이 UI에 표시되는 통합된 시스템</li>
                </ul>
            </div>

            <div class="subsection">
                <h3>👶 초딩도 이해하기 쉬운 설명</h3>
                <p>🏭 <strong>공장에서 장난감 만들기</strong>: 공장(건물)에서 장난감(유닛)을 만드는 것처럼, 게임에서도 건물을 클릭하고 "이 유닛 만들어줘!"라고 명령하면 시간이 걸려서 유닛이 나타납니다. 마치 공장에서 장난감을 만드는 것처럼요!</p>
            </div>

            <div class="subsection">
                <h3>🔧 주요 구현 내용</h3>
                
                <h4>1. BuildUnitCommand 클래스</h4>
                <div class="code-block">
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> GameDevTV.RTS.Units;

<span class="keyword">namespace</span> GameDevTV.RTS.Commands
{
    <span class="comment">// 건물에서 유닛을 생산하는 명령을 정의하는 ScriptableObject</span>
    <span class="comment">// CreateAssetMenu: Unity Inspector에서 "Buildings/Commands/Build Unit" 메뉴로 생성 가능</span>
    <span class="comment">// order = 120: 메뉴에서 순서를 지정 (낮은 숫자가 위에 표시)</span>
    [CreateAssetMenu(fileName = <span class="string">"Build Unit"</span>, menuName = <span class="string">"Buildings/Commands/Build Unit"</span>, order = <span class="number">120</span>)]
    <span class="keyword">public class</span> BuildUnitCommand : ActionBase
    {
        <span class="comment">// 생산할 유닛의 정보를 담고 있는 ScriptableObject</span>
        <span class="comment">// UnitSO에는 Prefab, BuildTime, Health 등의 정보가 포함됨</span>
        [field: SerializeField] <span class="keyword">public</span> UnitSO Unit { <span class="keyword">get</span>; <span class="keyword">private set</span>; }

        <span class="comment">// 이 명령을 실행할 수 있는지 확인하는 메서드</span>
        <span class="comment">// BaseBuilding만 이 명령을 실행할 수 있음 (유닛은 건물을 지을 수 없으므로)</span>
        <span class="keyword">public override bool</span> CanHandle(CommandContext context)
        {
            <span class="comment">// Commandable이 BaseBuilding 타입인지 확인</span>
            <span class="comment">// is 키워드: 타입 체크와 안전한 캐스팅을 동시에 수행</span>
            <span class="keyword">return</span> context.Commandable <span class="keyword">is</span> BaseBuilding;
        }

        <span class="comment">// 실제 명령을 실행하는 메서드</span>
        <span class="comment">// Command Pattern의 핵심: 명령을 캡슐화하여 실행</span>
        <span class="keyword">public override void</span> Handle(CommandContext context)
        {
            <span class="comment">// Commandable을 BaseBuilding으로 캐스팅</span>
            <span class="comment">// CanHandle에서 이미 BaseBuilding임을 확인했으므로 안전한 캐스팅</span>
            BaseBuilding building = (BaseBuilding)context.Commandable;
            
            <span class="comment">// 건물에게 유닛 생산을 요청</span>
            <span class="comment">// UnitSO에 정의된 Prefab과 BuildTime을 사용하여 생산</span>
            building.BuildUnit(Unit);
        }
    }
}
                </div>

                <h4>2. UnitSO 확장 (Prefab과 BuildTime 추가)</h4>
                <div class="code-block">
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// 유닛의 설정 데이터를 담는 ScriptableObject</span>
    <span class="comment">// CreateAssetMenu: Unity Inspector에서 "Units/Unit" 메뉴로 생성 가능</span>
    [CreateAssetMenu(fileName = <span class="string">"Unit"</span>, menuName = <span class="string">"Units/Unit"</span>)]
    <span class="keyword">public class</span> UnitSO : ScriptableObject
    {
        <span class="comment">// 유닛의 체력 - 기본값 100으로 설정</span>
        <span class="comment">// [field: SerializeField]: 프로퍼티를 Inspector에서 편집 가능하게 만듦</span>
        [field: SerializeField] <span class="keyword">public</span> <span class="keyword">int</span> Health { <span class="keyword">get</span>; <span class="keyword">private set</span>; } = <span class="number">100</span>;
        
        <span class="comment">// 유닛의 프리팹 - 실제로 생성될 GameObject</span>
        <span class="comment">// BuildUnitCommand에서 이 프리팹을 Instantiate하여 유닛 생성</span>
        [field: SerializeField] <span class="keyword">public</span> GameObject Prefab { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        
        <span class="comment">// 유닛 생산에 걸리는 시간 (초 단위) - 기본값 5초</span>
        <span class="comment">// 코루틴에서 이 시간만큼 대기한 후 유닛을 생성</span>
        [field: SerializeField] <span class="keyword">public</span> <span class="keyword">float</span> BuildTime { <span class="keyword">get</span>; <span class="keyword">private set</span>; } = <span class="number">5</span>;
    }
}
                </div>

                <h4>3. BaseBuilding에 BuildUnit 메서드와 코루틴 추가</h4>
                <div class="code-block">
<span class="keyword">using</span> System.Collections; <span class="comment">// IEnumerator를 사용하기 위해 필요</span>
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// 모든 건물의 기본 클래스 - AbstractCommandable을 상속받아 명령을 받을 수 있음</span>
    <span class="keyword">public class</span> BaseBuilding : AbstractCommandable
    {
        <span class="comment">// 유닛 생산을 시작하는 공개 메서드</span>
        <span class="comment">// BuildUnitCommand에서 호출되어 유닛 생산 프로세스를 시작</span>
        <span class="keyword">public void</span> BuildUnit(UnitSO unit)
        {
            <span class="comment">// 코루틴을 시작하여 시간 기반 유닛 생산 실행</span>
            <span class="comment">// StartCoroutine: MonoBehaviour의 메서드로 코루틴을 시작</span>
            StartCoroutine(DoBuildUnit(unit));
        }

        <span class="comment">// 실제 유닛 생산을 담당하는 코루틴</span>
        <span class="comment">// IEnumerator: 코루틴의 반환 타입, yield return으로 실행 제어</span>
        <span class="keyword">private IEnumerator</span> DoBuildUnit(UnitSO unit)
        {
            <span class="comment">// 코루틴 시작 로그 - 디버깅용</span>
            Debug.Log(<span class="string">"starting the coroutine!"</span>);
            
            <span class="comment">// 유닛 생산 시간만큼 대기</span>
            <span class="comment">// yield return: 코루틴에서 실행을 일시 정지하고 Unity에게 제어권 반환</span>
            <span class="comment">// WaitForSeconds: 지정된 시간만큼 대기하는 코루틴 대기 객체</span>
            <span class="keyword">yield return new</span> WaitForSeconds(unit.BuildTime);
            
            <span class="comment">// 생산 시간 완료 로그 - 디버깅용</span>
            Debug.Log(<span class="string">"build time has elapsed! instantiating the unit!"</span>);
            
            <span class="comment">// 유닛 프리팹을 건물 위치에 생성</span>
            <span class="comment">// Instantiate: 런타임에 GameObject를 생성하는 Unity 메서드</span>
            <span class="comment">// transform.position: 건물의 현재 위치</span>
            <span class="comment">// Quaternion.identity: 회전 없음 (기본 회전)</span>
            Instantiate(unit.Prefab, transform.position, Quaternion.identity);
        }
    }
}
                </div>

                <h4>4. PlayerInput에서 AbstractCommandable 캐스팅 수정</h4>
                <div class="code-block">
<span class="comment">// 이전: AbstractUnit으로만 캐스팅 (건물 제외)</span>
<span class="comment">// 문제: 건물은 AbstractUnit이 아니므로 명령을 받을 수 없음</span>
List&lt;AbstractUnit&gt; abstractUnits = selectedUnits
    .Where((unit) =&gt; unit <span class="keyword">is</span> AbstractUnit) <span class="comment">// 유닛만 필터링</span>
    .Cast&lt;AbstractUnit&gt;()                  <span class="comment">// AbstractUnit으로 캐스팅</span>
    .ToList();                             <span class="comment">// List로 변환</span>

<span class="comment">// 개선: AbstractCommandable로 캐스팅 (유닛과 건물 모두 포함)</span>
<span class="comment">// 장점: 유닛과 건물 모두 명령을 받을 수 있음</span>
List&lt;AbstractCommandable&gt; abstractCommandables = selectedUnits
    .Where((unit) =&gt; unit <span class="keyword">is</span> AbstractCommandable) <span class="comment">// 명령 가능한 객체만 필터링</span>
    .Cast&lt;AbstractCommandable&gt;()                  <span class="comment">// AbstractCommandable로 캐스팅</span>
    .ToList();                                     <span class="comment">// List로 변환</span>
                </div>

                <h4>5. ActionSelected에서 즉시 실행 로직 추가</h4>
                <div class="code-block">
<span class="comment">// UI에서 액션 버튼이 클릭되었을 때 호출되는 메서드</span>
<span class="comment">// ActionSelectedEvent: UI에서 선택된 액션 정보를 담는 이벤트</span>
<span class="keyword">private void</span> HandleActionSelected(ActionSelectedEvent evt)
{
    <span class="comment">// 현재 활성화된 액션을 선택된 액션으로 설정</span>
    <span class="comment">// activeAction: PlayerInput에서 현재 활성화된 명령을 추적하는 변수</span>
    activeAction = evt.Action;
    
    <span class="comment">// RequiresClickToActivate가 false면 즉시 실행</span>
    <span class="comment">// BuildUnitCommand 같은 경우 클릭 없이 바로 실행되어야 함</span>
    <span class="keyword">if</span> (!activeAction.RequiresClickToActivate)
    {
        <span class="comment">// 더미 RaycastHit를 생성하여 즉시 명령 실행</span>
        <span class="comment">// BuildUnitCommand는 클릭 위치가 중요하지 않으므로 빈 RaycastHit 사용</span>
        ActivateAction(<span class="keyword">new</span> RaycastHit());
    }
}
                </div>
            </div>

            <div class="subsection">
                <h3>🔑 핵심 기술 개념</h3>
                <ul>
                    <li><strong>코루틴 (Coroutines)</strong>: 시간이 걸리는 작업을 여러 프레임에 걸쳐 실행</li>
                    <li><strong>IEnumerator</strong>: 코루틴의 반환 타입, yield return으로 실행 제어</li>
                    <li><strong>WaitForSeconds</strong>: 지정된 시간만큼 대기하는 코루틴 대기 객체</li>
                    <li><strong>yield return</strong>: 코루틴에서 실행을 일시 정지하고 Unity에게 제어권 반환</li>
                    <li><strong>StartCoroutine</strong>: 코루틴을 시작하는 MonoBehaviour 메서드</li>
                    <li><strong>Instantiate</strong>: 런타임에 GameObject를 생성하는 Unity 메서드</li>
                    <li><strong>RequiresClickToActivate</strong>: 클릭 없이 즉시 실행할지 결정하는 플래그</li>
                    <li><strong>AbstractCommandable 캐스팅</strong>: 유닛과 건물 모두 명령을 받을 수 있도록 확장</li>
                </ul>
            </div>

            <div class="subsection">
                <h3>🎮 게임플레이 개선</h3>
                
                <div class="code-block">
<span class="comment">// 이전: 건물 선택 시 아무 명령도 사용할 수 없음</span>
<span class="comment">// 플레이어가 건물의 기능을 활용할 수 없어 게임이 단조로움</span>

<span class="comment">// 개선: 완전한 건물 기반 유닛 생산 시스템</span>
<span class="comment">// 1. 건물 선택 → 빌드 명령 UI 표시</span>
<span class="comment">// 2. 빌드 명령 클릭 → 즉시 유닛 생산 시작</span>
<span class="comment">// 3. 시간 경과 → 유닛이 건물 근처에 생성</span>
<span class="comment">// 4. 경제적 전략 요소 추가</span>
                </div>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>건물 기반 유닛 생산</strong>: Command Post에서 Worker 생산 가능</li>
                    <li><strong>시간 기반 생산 시스템</strong>: 현실적인 빌드 타임으로 전략적 요소 추가</li>
                    <li><strong>코루틴 활용</strong>: 비동기 작업으로 게임 성능 최적화</li>
                    <li><strong>명령 패턴 확장</strong>: 기존 시스템을 건물 명령으로 확장</li>
                    <li><strong>UI 통합</strong>: 건물 선택 시 빌드 명령이 자동으로 UI에 표시</li>
                    <li><strong>즉시 실행 명령</strong>: RequiresClickToActivate로 다양한 명령 타입 지원</li>
                </ul>
            </div>
        </div>

        <!-- 강의 30: Building Queue 시스템 -->
        <div class="lecture-section" id="lecture30">
            <h2 class="lecture-title">🏗️ 강의 30: Building Queue 시스템 (건물 큐 시스템)</h2>
            
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>건물에서 여러 유닛을 동시에 생산하는 대신 <strong>Queue(큐)</strong>를 사용해서 순서대로 하나씩 생산하는 시스템을 구현합니다.</p>
            </div>

            <div class="content-section">
                <h3>📋 주요 내용</h3>
                
                <h4>1. Queue(큐)란? (쉽게 설명)</h4>
                <ul class="content-list">
                    <li><strong>Queue</strong>: 줄서기와 같은 개념 - 먼저 온 순서대로 처리</li>
                    <li><strong>FIFO</strong>: First In, First Out (먼저 들어온 것이 먼저 나감)</li>
                    <li><strong>Enqueue</strong>: 줄에 추가하기 (큐에 항목 추가)</li>
                    <li><strong>Dequeue</strong>: 줄에서 빼기 (큐에서 항목 제거)</li>
                    <li><strong>Peek</strong>: 다음에 나올 항목 미리보기 (큐 변경 없이 확인)</li>
                </ul>

                <h4>2. 왜 필요한가?</h4>
                <ul class="content-list">
                    <li><strong>현실적인 제약</strong>: 건물에서 한 번에 여러 유닛을 만들 수 없음</li>
                    <li><strong>게임 밸런스</strong>: 무한정 빠른 생산을 방지</li>
                    <li><strong>전략적 요소</strong>: 생산 순서를 고려한 전략 수립</li>
                    <li><strong>자원 관리</strong>: 생산 비용과 시간의 균형</li>
                </ul>

                <h4>3. 초딩도 이해하기 쉬운 설명</h4>
                <p>피자집에서 피자를 만드는 것과 같아요! 피자집에는 오븐이 하나밖에 없어서 피자를 하나씩만 구울 수 있어요. 
                손님이 여러 개 주문해도 첫 번째 피자부터 차례대로 만들어야 해요. 
                게임에서도 건물이 하나의 "오븐"이고, 유닛들이 "피자"예요!</p>

                <h4>4. 핵심 코드 구현</h4>
                
                <h5>BaseBuilding.cs - Queue 시스템</h5>
                <div class="code-block"><span class="comment">// 건물 큐: 생산할 유닛들을 순서대로 저장하는 큐</span>
<span class="comment">// Queue&lt;UnitSO&gt;: FIFO(First In, First Out) 방식으로 유닛을 처리</span>
<span class="comment">// System.Collections.Generic.Queue: C#의 표준 큐 컬렉션</span>
<span class="keyword">private</span> Queue&lt;UnitSO&gt; buildingQueue = <span class="keyword">new</span> Queue&lt;UnitSO&gt;(<span class="number">5</span>);

<span class="comment">// 최대 큐 크기: 무한정 큐가 커지는 것을 방지</span>
<span class="comment">// const: 컴파일 타임에 값이 결정되는 상수</span>
<span class="comment">// private: 이 클래스 내부에서만 접근 가능</span>
<span class="keyword">private const int</span> maxQueueSize = <span class="number">5</span>;

<span class="comment">// 유닛 생산 요청 메서드</span>
<span class="keyword">public void</span> BuildUnit(UnitSO unit)
{
    <span class="comment">// Guardian Pattern: 큐가 가득 찬 경우 요청을 거부</span>
    <span class="comment">// buildingQueue.Count: 현재 큐에 있는 유닛의 개수</span>
    <span class="comment">// maxQueueSize: 허용되는 최대 큐 크기</span>
    <span class="keyword">if</span> (buildingQueue.Count &gt;= maxQueueSize)
    {
        <span class="comment">// 큐가 가득 찬 경우 에러 로그 출력</span>
        <span class="comment">// 이는 코드의 버그를 나타내는 신호일 수 있음</span>
        Debug.LogError(<span class="string">$"BuildUnit was called when the queue was already full. This is not supported."</span>);
        <span class="keyword">return</span>; <span class="comment">// 메서드 종료</span>
    }

    <span class="comment">// 큐에 새로운 유닛 추가</span>
    <span class="comment">// Enqueue: 큐의 끝에 항목을 추가하는 메서드</span>
    buildingQueue.Enqueue(unit);

    <span class="comment">// 첫 번째 유닛을 추가한 경우에만 코루틴 시작</span>
    <span class="comment">// 이미 코루틴이 실행 중인 경우 새로 시작하지 않음</span>
    <span class="comment">// buildingQueue.Count == 1: 방금 첫 번째 유닛을 추가했음을 의미</span>
    <span class="keyword">if</span> (buildingQueue.Count == <span class="number">1</span>)
    {
        <span class="comment">// DoBuildUnits 코루틴 시작 (매개변수 없음)</span>
        <span class="comment">// 이 코루틴이 전체 큐를 처리함</span>
        StartCoroutine(DoBuildUnits());
    }
}</div>

                <h5>DoBuildUnits 코루틴 - 큐 처리</h5>
                <div class="code-block"><span class="comment">// 큐에 있는 유닛들을 순서대로 생산하는 코루틴</span>
<span class="keyword">private</span> IEnumerator DoBuildUnits()
{
    <span class="comment">// 큐에 유닛이 있는 동안 반복</span>
    <span class="comment">// while loop: 큐가 비어있을 때까지 계속 처리</span>
    <span class="keyword">while</span> (buildingQueue.Count &gt; <span class="number">0</span>)
    {
        <span class="comment">// Peek: 큐의 첫 번째 항목을 확인하되 제거하지 않음</span>
        <span class="comment">// 현재 처리할 유닛의 정보를 가져옴</span>
        UnitSO unit = buildingQueue.Peek();

        <span class="comment">// 해당 유닛의 빌드 시간만큼 대기</span>
        <span class="comment">// yield return: 코루틴을 일시 정지하고 다음 프레임에 재개</span>
        <span class="comment">// WaitForSeconds: 지정된 시간(초) 동안 대기</span>
        <span class="keyword">yield return new</span> WaitForSeconds(unit.BuildTime);

        <span class="comment">// 유닛 생성</span>
        <span class="comment">// Instantiate: GameObject를 복제하여 씬에 생성</span>
        <span class="comment">// transform.position: 건물의 위치에서 유닛 생성</span>
        <span class="comment">// Quaternion.identity: 회전 없음 (기본 회전)</span>
        Instantiate(unit.Prefab, transform.position, Quaternion.identity);

        <span class="comment">// Dequeue: 큐의 첫 번째 항목을 제거하고 반환</span>
        <span class="comment">// 빌드가 완료된 유닛을 큐에서 제거</span>
        <span class="comment">// 반환값은 사용하지 않으므로 변수에 저장하지 않음</span>
        buildingQueue.Dequeue();
    }
}</div>

                <h5>PlayerInput.cs - UI 클릭 시 선택 해제 방지</h5>
                <div class="code-block"><span class="comment">// UI 클릭 시 선택 해제 방지 로직 추가</span>
<span class="keyword">private void</span> HandleMouseUp()
{
    <span class="comment">// UI 클릭 시 선택 해제 방지 로직 추가</span>
    <span class="comment">// activeAction == null: 현재 활성화된 액션이 없음</span>
    <span class="comment">// !wasMouseDownOnUI: 마우스가 UI에서 시작되지 않음 (월드에서 시작됨)</span>
    <span class="comment">// !Keyboard.current.shiftKey.isPressed: Shift 키가 눌려있지 않음</span>
    <span class="comment">// 이 세 조건이 모두 만족될 때만 유닛 선택 해제</span>
    <span class="keyword">if</span> (activeAction == <span class="keyword">null</span> &amp;&amp; !wasMouseDownOnUI &amp;&amp; !Keyboard.current.shiftKey.isPressed)
    {
        DeselectAllUnits();
    }

    HandleLeftClick();
    <span class="keyword">foreach</span> (AbstractUnit unit <span class="keyword">in</span> addedUnits)
    {
        unit.Select();
    }
    selectionBox.gameObject.SetActive(<span class="keyword">false</span>);
}</div>
            </div>

            <div class="subsection">
                <h3>🔧 핵심 기술 개념</h3>
                <ul>
                    <li><strong>Queue&lt;T&gt;</strong>: FIFO 방식의 컬렉션 자료구조</li>
                    <li><strong>Enqueue()</strong>: 큐에 항목 추가</li>
                    <li><strong>Dequeue()</strong>: 큐에서 항목 제거 및 반환</li>
                    <li><strong>Peek()</strong>: 큐의 첫 번째 항목 확인 (제거하지 않음)</li>
                    <li><strong>Count</strong>: 큐에 있는 항목의 개수</li>
                    <li><strong>Guardian Pattern</strong>: 큐 크기 제한으로 오류 방지</li>
                    <li><strong>Coroutine</strong>: 비동기 작업으로 큐 처리</li>
                    <li><strong>UI Interaction</strong>: UI 클릭과 월드 클릭 구분</li>
                </ul>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>건물 기반 유닛 생산</strong>: Command Post에서 Worker 생산 가능</li>
                    <li><strong>큐 시스템</strong>: 최대 5개까지 유닛 생산 대기열</li>
                    <li><strong>시간 기반 생산</strong>: 현실적인 빌드 타임으로 전략적 요소 추가</li>
                    <li><strong>UI 개선</strong>: 빌드 버튼 클릭 시 유닛 선택 해제 방지</li>
                    <li><strong>에러 처리</strong>: 큐가 가득 찬 경우 적절한 피드백</li>
                    <li><strong>성능 최적화</strong>: 코루틴을 사용한 효율적인 큐 처리</li>
                </ul>
            </div>
        </div>

        <!-- 강의 30: Building Queue (건물 큐 시스템) -->
        <div class="lecture-section">
            <h2 class="lecture-title">🏗️ 강의 30: Building Queue (건물 큐 시스템)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">순차적 유닛 생산</strong>: <span style="color: #2c3e50;">여러 유닛이 동시에 나오는 것을 방지하고 순서대로 생산</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">전략적 깊이</strong>: <span style="color: #2c3e50;">빌드 시간과 큐 관리로 게임의 전략성 향상</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자원 관리</strong>: <span style="color: #2c3e50;">제한된 큐 크기로 자원 소모 제어</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">사용자 경험</strong>: <span style="color: #2c3e50;">UI 클릭 시 유닛 선택 해제 방지로 편의성 향상</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🏭 공장에서 일하는 것 같아요!</strong></p>
                <p style="margin: 8px 0; color: #155724;">건물은 마치 공장처럼 로봇을 하나씩 만들어요. 한 번에 여러 개를 만들 수 없고, 줄을 서서 기다려야 해요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎮 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>공정한 게임</strong>: 모든 플레이어가 같은 속도로 유닛을 만들어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>전략적 선택</strong>: 어떤 유닛을 먼저 만들지 신중하게 생각해야 해요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>자원 관리</strong>: 무한정 만들 수 없어서 자원을 아껴야 해요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🍕 피자 주문으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">피자집에서 피자를 주문할 때도 순서대로 만들어요. 먼저 주문한 사람이 먼저 받는 것처럼, 먼저 요청한 로봇이 먼저 나와요!</p>
            </div>

            <div class="subsection">
                <h3>📋 주요 변경사항</h3>
                
                <div class="code-block">
<span class="comment">// 1. BaseBuilding에 큐 시스템 추가</span>
<span class="comment">// Queue&lt;UnitSO&gt;: FIFO 방식의 유닛 생산 큐</span>
<span class="comment">// System.Collections.Generic: C#의 표준 컬렉션 네임스페이스</span>
<span class="keyword">using</span> System.Collections.Generic;

<span class="keyword">public class</span> <span class="class-name">BaseBuilding</span> : <span class="class-name">AbstractCommandable</span>
{
    <span class="comment">// 건물 큐: 생산할 유닛들을 순서대로 저장하는 큐</span>
    <span class="comment">// Queue&lt;UnitSO&gt;: FIFO(First In, First Out) 방식으로 유닛을 처리</span>
    <span class="comment">// new Queue&lt;UnitSO&gt;(5): 초기 용량을 5로 설정</span>
    <span class="keyword">private</span> <span class="class-name">Queue</span>&lt;<span class="class-name">UnitSO</span>&gt; buildingQueue = <span class="keyword">new</span> <span class="class-name">Queue</span>&lt;<span class="class-name">UnitSO</span>&gt;(<span class="number">5</span>);
    
    <span class="comment">// 최대 큐 크기: 무한정 큐가 커지는 것을 방지</span>
    <span class="comment">// const: 컴파일 타임에 값이 결정되는 상수</span>
    <span class="comment">// private: 이 클래스 내부에서만 접근 가능</span>
    <span class="keyword">private const int</span> maxQueueSize = <span class="number">5</span>;

    <span class="comment">// 유닛 생산 요청 메서드</span>
    <span class="comment">// UnitSO unit: 생산할 유닛의 설정 데이터</span>
    <span class="comment">// void: 반환값이 없음</span>
    <span class="keyword">public void</span> <span class="method-name">BuildUnit</span>(<span class="class-name">UnitSO</span> unit)
    {
        <span class="comment">// Guardian Pattern: 큐가 가득 찬 경우 요청을 거부</span>
        <span class="comment">// buildingQueue.Count: 현재 큐에 있는 유닛의 개수</span>
        <span class="comment">// maxQueueSize: 허용되는 최대 큐 크기</span>
        <span class="keyword">if</span> (buildingQueue.<span class="property-name">Count</span> >= maxQueueSize)
        {
            <span class="comment">// 큐가 가득 찬 경우 에러 로그 출력</span>
            <span class="comment">// 이는 코드의 버그를 나타내는 신호일 수 있음</span>
            <span class="class-name">Debug</span>.<span class="method-name">LogError</span>(<span class="string">$"BuildUnit was called when the queue was already full. This is not supported."</span>);
            <span class="keyword">return</span>; <span class="comment">// 메서드 종료</span>
        }

        <span class="comment">// 큐에 새로운 유닛 추가</span>
        <span class="comment">// Enqueue: 큐의 끝에 항목을 추가하는 메서드</span>
        buildingQueue.<span class="method-name">Enqueue</span>(unit);

        <span class="comment">// 첫 번째 유닛을 추가한 경우에만 코루틴 시작</span>
        <span class="comment">// 이미 코루틴이 실행 중인 경우 새로 시작하지 않음</span>
        <span class="comment">// buildingQueue.Count == 1: 방금 첫 번째 유닛을 추가했음을 의미</span>
        <span class="keyword">if</span> (buildingQueue.<span class="property-name">Count</span> == <span class="number">1</span>)
        {
            <span class="comment">// DoBuildUnits 코루틴 시작 (매개변수 없음)</span>
            <span class="comment">// 이 코루틴이 전체 큐를 처리함</span>
            <span class="method-name">StartCoroutine</span>(<span class="method-name">DoBuildUnits</span>());
        }
    }
}</div>

                <div class="info-box">
                    <h4>💡 왜 큐 시스템이 필요한가?</h4>
                    <ul>
                        <li><strong>순차적 생산</strong>: 여러 유닛이 동시에 나오는 것을 방지</li>
                        <li><strong>전략적 깊이</strong>: 빌드 시간과 큐 관리로 게임의 전략성 향상</li>
                        <li><strong>자원 제한</strong>: 무한정 유닛을 생산할 수 없도록 제한</li>
                        <li><strong>성능 최적화</strong>: 코루틴을 사용한 효율적인 처리</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 2. DoBuildUnits 코루틴 구현</span>
<span class="comment">// IEnumerator: 코루틴의 반환 타입</span>
<span class="comment">// yield return: 코루틴을 일시 정지하고 다음 프레임에 재개</span>
<span class="keyword">private</span> <span class="class-name">IEnumerator</span> <span class="method-name">DoBuildUnits</span>()
{
    <span class="comment">// 큐에 유닛이 있는 동안 반복</span>
    <span class="comment">// while loop: 큐가 비어있을 때까지 계속 처리</span>
    <span class="keyword">while</span> (buildingQueue.<span class="property-name">Count</span> > <span class="number">0</span>)
    {
        <span class="comment">// Peek: 큐의 첫 번째 항목을 확인하되 제거하지 않음</span>
        <span class="comment">// 현재 처리할 유닛의 정보를 가져옴</span>
        <span class="class-name">UnitSO</span> unit = buildingQueue.<span class="method-name">Peek</span>();

        <span class="comment">// 해당 유닛의 빌드 시간만큼 대기</span>
        <span class="comment">// yield return: 코루틴을 일시 정지하고 다음 프레임에 재개</span>
        <span class="comment">// WaitForSeconds: 지정된 시간(초) 동안 대기</span>
        <span class="keyword">yield return new</span> <span class="class-name">WaitForSeconds</span>(unit.<span class="property-name">BuildTime</span>);

        <span class="comment">// 유닛 생성</span>
        <span class="comment">// Instantiate: GameObject를 복제하여 씬에 생성</span>
        <span class="comment">// transform.position: 건물의 위치에서 유닛 생성</span>
        <span class="comment">// Quaternion.identity: 회전 없음 (기본 회전)</span>
        <span class="method-name">Instantiate</span>(unit.<span class="property-name">Prefab</span>, transform.<span class="property-name">position</span>, <span class="class-name">Quaternion</span>.<span class="property-name">identity</span>);

        <span class="comment">// Dequeue: 큐의 첫 번째 항목을 제거하고 반환</span>
        <span class="comment">// 빌드가 완료된 유닛을 큐에서 제거</span>
        <span class="comment">// 반환값은 사용하지 않으므로 변수에 저장하지 않음</span>
        buildingQueue.<span class="method-name">Dequeue</span>();
    }
}</div>

                <div class="info-box">
                    <h4>💡 왜 Peek과 Dequeue를 분리하는가?</h4>
                    <ul>
                        <li><strong>Peek</strong>: 큐의 첫 번째 항목을 확인하되 제거하지 않음</li>
                        <li><strong>Dequeue</strong>: 큐의 첫 번째 항목을 제거하고 반환</li>
                        <li><strong>중복 코루틴 방지</strong>: 빌드 완료 후에만 큐에서 제거</li>
                        <li><strong>안전한 처리</strong>: 빌드 중단 시에도 큐 상태 유지</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="comment">// 3. PlayerInput UI 클릭 처리 개선</span>
<span class="comment">// HandleMouseUp: 마우스 버튼을 놓았을 때 호출되는 메서드</span>
<span class="comment">// UI 클릭과 월드 클릭을 구분하여 처리</span>
<span class="keyword">private void</span> <span class="method-name">HandleMouseUp</span>()
{
    <span class="comment">// UI 클릭 시 선택 해제 방지 로직 추가</span>
    <span class="comment">// activeAction == null: 현재 활성화된 액션이 없음</span>
    <span class="comment">// !wasMouseDownOnUI: 마우스가 UI에서 시작되지 않음 (월드에서 시작됨)</span>
    <span class="comment">// !Keyboard.current.shiftKey.isPressed: Shift 키가 눌려있지 않음</span>
    <span class="comment">// 이 세 조건이 모두 만족될 때만 유닛 선택 해제</span>
    <span class="keyword">if</span> (activeAction == <span class="keyword">null</span> &amp;&amp; !wasMouseDownOnUI &amp;&amp; !Keyboard.current.shiftKey.isPressed)
    {
        <span class="method-name">DeselectAllUnits</span>();
    }

    <span class="method-name">HandleLeftClick</span>();
    <span class="keyword">foreach</span> (<span class="class-name">AbstractUnit</span> unit <span class="keyword">in</span> addedUnits)
    {
        unit.<span class="method-name">Select</span>();
    }
    selectionBox.gameObject.SetActive(<span class="keyword">false</span>);
}</div>
            </div>

            <div class="subsection">
                <h3>🔧 핵심 기술 개념</h3>
                <ul>
                    <li><strong>Queue&lt;T&gt;</strong>: FIFO 방식의 컬렉션 자료구조</li>
                    <li><strong>Enqueue()</strong>: 큐에 항목 추가</li>
                    <li><strong>Dequeue()</strong>: 큐에서 항목 제거 및 반환</li>
                    <li><strong>Peek()</strong>: 큐의 첫 번째 항목 확인 (제거하지 않음)</li>
                    <li><strong>Count</strong>: 큐에 있는 항목의 개수</li>
                    <li><strong>Guardian Pattern</strong>: 큐 크기 제한으로 오류 방지</li>
                    <li><strong>Coroutine</strong>: 비동기 작업으로 큐 처리</li>
                    <li><strong>UI Interaction</strong>: UI 클릭과 월드 클릭 구분</li>
                </ul>
            </div>

            <div class="subsection">
                <h3>🚀 Nova 1492 적용 포인트</h3>
                <ul>
                    <li><strong>건물 기반 유닛 생산</strong>: Command Post에서 Worker 생산 가능</li>
                    <li><strong>큐 시스템</strong>: 최대 5개까지 유닛 생산 대기열</li>
                    <li><strong>시간 기반 생산</strong>: 현실적인 빌드 타임으로 전략적 요소 추가</li>
                    <li><strong>UI 개선</strong>: 빌드 버튼 클릭 시 유닛 선택 해제 방지</li>
                    <li><strong>에러 처리</strong>: 큐가 가득 찬 경우 적절한 피드백</li>
                    <li><strong>성능 최적화</strong>: 코루틴을 사용한 효율적인 큐 처리</li>
                </ul>
            </div>
        </div>

        <!-- 강의 31: UI System Refactoring (UI 시스템 리팩토링) -->
        <div class="lecture-section" id="lecture-31">
            <h2 class="lecture-title">🎨 강의 31: UI System Refactoring (UI 시스템 리팩토링)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">UI 확장성 확보</strong>: <span style="color: #2c3e50;">다양한 UI 컨테이너와 컴포넌트를 체계적으로 관리하기 위한 기반 구축</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드 중복 제거</strong>: <span style="color: #2c3e50;">각 UI 컨테이너마다 반복되는 이벤트 리스너 코드를 통합</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">일관된 UI 관리</strong>: <span style="color: #2c3e50;">모든 UI 요소의 활성화/비활성화를 통일된 방식으로 처리</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">단방향 데이터 흐름</strong>: <span style="color: #2c3e50;">RuntimeUI에서 하위 컨테이너로 컨텍스트를 전달하는 명확한 구조</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🎮 UI가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">게임 화면에 나타나는 버튼, 메뉴, 정보창 같은 것들이에요. 마치 TV 리모컨처럼 게임을 조작할 수 있게 해주는 도구들이죠!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 정리가 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>많은 UI 요소</strong>: 게임에 버튼, 메뉴, 정보창이 많아질수록 관리가 어려워져요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>일관된 관리</strong>: 모든 UI 요소를 같은 방식으로 켜고 끄면 관리하기 쉬워요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>코드 정리</strong>: 비슷한 코드를 여러 번 쓰지 않고 한 곳에서 관리해요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집의 모든 전등을 하나의 스위치로 켜고 끄는 것과 같아요. 각 방마다 개별 스위치가 있지만, 메인 스위치로 전체를 관리할 수 있어요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>UI 시스템의 확장 가능한 아키텍처 설계</li>
                    <li>IUIElement 인터페이스를 통한 일관된 UI 관리</li>
                    <li>폴더 구조와 네임스페이스 정리</li>
                    <li>RuntimeUI를 통한 중앙집중식 UI 관리</li>
                    <li>단방향 데이터 흐름 구현</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📁 폴더 구조 정리</h3>
                
                <div class="code-block">
<span class="comment">// 폴더 구조 변경</span>
<span class="comment">// 기존: Assets/Scripts/UI/</span>
<span class="comment">// 변경: Assets/Scripts/UI/Containers/ + Components/</span>

<span class="comment">// Containers 폴더</span>
<span class="comment">// - ActionsUI.cs: 액션 버튼들을 관리하는 컨테이너</span>
<span class="comment">// - BuildingBuildingUI.cs: 건물 건설 진행 상황을 보여주는 컨테이너</span>

<span class="comment">// Components 폴더</span>
<span class="comment">// - UIActionButton.cs: 개별 액션 버튼 컴포넌트</span>

<span class="comment">// 네임스페이스 변경</span>
<span class="comment">// 기존: GameDevTV.RTS.UI</span>
<span class="comment">// 변경: GameDevTV.RTS.UI.Containers, GameDevTV.RTS.UI.Components</span>
</div>
            </div>

            <div class="content-section">
                <h3>🔧 IUIElement 인터페이스</h3>
                
                <div class="code-block">
<span class="comment">// IUIElement.cs - UI 요소의 일관된 관리 인터페이스</span>
<span class="comment">// IUIElement: 모든 UI 요소가 구현해야 하는 기본 계약</span>
<span class="comment">// interface: 클래스가 반드시 구현해야 하는 메서드들을 정의</span>
<span class="comment">// Generic Type: 다양한 타입의 컨텍스트를 받을 수 있도록 함</span>
<span class="keyword">namespace</span> GameDevTV.RTS.UI
{
    <span class="comment">// 단일 타입 컨텍스트를 받는 UI 요소 인터페이스</span>
    <span class="comment">// T: 제네릭 타입 매개변수 (Type의 줄임말)</span>
    <span class="comment">// 각 UI 요소가 어떤 타입의 데이터를 받을지 정의</span>
    <span class="keyword">public interface</span> <span class="class-name">IUIElement</span>&lt;<span class="class-name">T</span>&gt;
    {
        <span class="comment">// UI 요소를 활성화하고 컨텍스트를 전달하는 메서드</span>
        <span class="comment">// EnableFor: "~을 위해 활성화하다"라는 의미</span>
        <span class="comment">// T item: 전달받을 컨텍스트 데이터</span>
        <span class="comment">// void: 반환값이 없음 (UI 상태만 변경)</span>
        <span class="keyword">void</span> <span class="method-name">EnableFor</span>(<span class="class-name">T</span> item);
        
        <span class="comment">// UI 요소를 비활성화하는 메서드</span>
        <span class="comment">// Disable: "비활성화하다"라는 의미</span>
        <span class="comment">// 매개변수 없음: 단순히 UI를 끄기만 함</span>
        <span class="keyword">void</span> <span class="method-name">Disable</span>();
    }

    <span class="comment">// 두 개의 타입을 받는 UI 요소 인터페이스 (오버로드)</span>
    <span class="comment">// T1: 첫 번째 타입 (컨텍스트)</span>
    <span class="comment">// T2: 두 번째 타입 (콜백 함수)</span>
    <span class="comment">// 예: ActionBase + UnityAction</span>
    <span class="keyword">public interface</span> <span class="class-name">IUIElement</span>&lt;<span class="class-name">T1</span>, <span class="class-name">T2</span>&gt;
    {
        <span class="comment">// 컨텍스트와 콜백을 함께 받는 활성화 메서드</span>
        <span class="comment">// T1 item: 컨텍스트 데이터</span>
        <span class="comment">// T2 callback: 실행할 콜백 함수</span>
        <span class="keyword">void</span> <span class="method-name">EnableFor</span>(<span class="class-name">T1</span> item, <span class="class-name">T2</span> callback);
        
        <span class="comment">// UI 요소를 비활성화하는 메서드</span>
        <span class="keyword">void</span> <span class="method-name">Disable</span>();
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🏗️ RuntimeUI 클래스</h3>
                
                <div class="code-block">
<span class="comment">// RuntimeUI.cs - 모든 UI 컨테이너를 관리하는 최상위 클래스</span>
<span class="comment">// RuntimeUI: 게임 실행 중 UI를 관리하는 중앙 집중식 클래스</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.UI
{
    <span class="comment">// 모든 UI 컨테이너를 관리하는 최상위 클래스</span>
    <span class="comment">// RuntimeUI: "런타임 UI"라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">RuntimeUI</span> : <span class="class-name">MonoBehaviour</span>
    {
        <span class="comment">// ActionsUI 컨테이너 참조</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// ActionsUI: 액션 버튼들을 관리하는 컨테이너</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">ActionsUI</span> actionsUI;
        
        <span class="comment">// 현재 선택된 유닛들을 저장하는 HashSet</span>
        <span class="comment">// HashSet: 중복을 허용하지 않는 고성능 컬렉션</span>
        <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 모든 객체</span>
        <span class="comment">// default capacity 12: 기본 용량을 12로 설정 (성능 최적화)</span>
        <span class="keyword">private</span> <span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt; selectedUnits = <span class="keyword">new</span> <span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt;(<span class="number">12</span>);

        <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
        <span class="comment">// Awake: GameObject가 생성될 때 한 번만 실행</span>
        <span class="keyword">private void</span> <span class="method-name">Awake</span>()
        {
            <span class="comment">// UnitSelectedEvent 이벤트 구독</span>
            <span class="comment">// Bus: 이벤트 버스 패턴을 사용한 이벤트 시스템</span>
            <span class="comment">// OnEvent: 이벤트가 발생했을 때 호출될 메서드 등록</span>
            <span class="comment">// +=: 이벤트 핸들러 추가</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">UnitSelectedEvent</span>&gt;.<span class="property-name">OnEvent</span> += <span class="method-name">HandleUnitSelected</span>;
            
            <span class="comment">// UnitDeselectedEvent 이벤트 구독</span>
            <span class="comment">// HandleUnitDeselected: 유닛 선택 해제 시 호출될 메서드</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">UnitDeselectedEvent</span>&gt;.<span class="property-name">OnEvent</span> += <span class="method-name">HandleUnitDeselected</span>;
        }

        <span class="comment">// GameObject가 파괴될 때 실행</span>
        <span class="comment">// OnDestroy: 메모리 누수 방지를 위한 이벤트 구독 해제</span>
        <span class="keyword">private void</span> <span class="method-name">OnDestroy</span>()
        {
            <span class="comment">// UnitSelectedEvent 이벤트 구독 해제</span>
            <span class="comment">// -=: 이벤트 핸들러 제거</span>
            <span class="comment">// 메모리 누수 방지를 위해 반드시 필요</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">UnitSelectedEvent</span>&gt;.<span class="property-name">OnEvent</span> -= <span class="method-name">HandleUnitSelected</span>;
            
            <span class="comment">// UnitDeselectedEvent 이벤트 구독 해제</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">UnitDeselectedEvent</span>&gt;.<span class="property-name">OnEvent</span> -= <span class="method-name">HandleUnitDeselected</span>;
        }

        <span class="comment">// 유닛이 선택되었을 때 호출되는 메서드</span>
        <span class="comment">// HandleUnitSelected: "유닛 선택 처리"라는 의미</span>
        <span class="comment">// UnitSelectedEvent evt: 선택된 유닛 정보를 담은 이벤트</span>
        <span class="keyword">private void</span> <span class="method-name">HandleUnitSelected</span>(<span class="class-name">UnitSelectedEvent</span> evt)
        {
            <span class="comment">// 선택된 유닛을 HashSet에 추가</span>
            <span class="comment">// evt.Unit: 이벤트에 포함된 유닛</span>
            <span class="comment">// Add: HashSet에 항목 추가 (중복 시 무시)</span>
            selectedUnits.<span class="method-name">Add</span>(evt.<span class="property-name">Unit</span>);
            
            <span class="comment">// ActionsUI를 활성화하고 선택된 유닛들을 전달</span>
            <span class="comment">// EnableFor: IUIElement 인터페이스의 메서드</span>
            <span class="comment">// selectedUnits: 현재 선택된 모든 유닛들</span>
            actionsUI.<span class="method-name">EnableFor</span>(selectedUnits);
        }

        <span class="comment">// 유닛 선택이 해제되었을 때 호출되는 메서드</span>
        <span class="comment">// HandleUnitDeselected: "유닛 선택 해제 처리"라는 의미</span>
        <span class="comment">// UnitDeselectedEvent evt: 선택 해제된 유닛 정보를 담은 이벤트</span>
        <span class="keyword">private void</span> <span class="method-name">HandleUnitDeselected</span>(<span class="class-name">UnitDeselectedEvent</span> evt)
        {
            <span class="comment">// 선택 해제된 유닛을 HashSet에서 제거</span>
            <span class="comment">// Remove: HashSet에서 항목 제거</span>
            selectedUnits.<span class="method-name">Remove</span>(evt.<span class="property-name">Unit</span>);
            
            <span class="comment">// 아직 선택된 유닛이 있는지 확인</span>
            <span class="comment">// Count: HashSet에 있는 항목의 개수</span>
            <span class="comment">// > 0: 하나 이상의 유닛이 선택되어 있음</span>
            <span class="keyword">if</span> (selectedUnits.<span class="property-name">Count</span> > <span class="number">0</span>)
            {
                <span class="comment">// 선택된 유닛이 있으면 ActionsUI 업데이트</span>
                <span class="comment">// 여전히 유닛이 선택되어 있으므로 UI를 업데이트</span>
                actionsUI.<span class="method-name">EnableFor</span>(selectedUnits);
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// 선택된 유닛이 없으면 ActionsUI 비활성화</span>
                <span class="comment">// Disable: IUIElement 인터페이스의 메서드</span>
                <span class="comment">// 모든 유닛 선택이 해제되었으므로 UI를 끔</span>
                actionsUI.<span class="method-name">Disable</span>();
            }
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🔄 ActionsUI 리팩토링</h3>
                
                <div class="code-block">
<span class="comment">// ActionsUI.cs - 리팩토링된 버전</span>
<span class="comment">// ActionsUI: 액션 버튼들을 관리하는 컨테이너</span>
<span class="comment">// IUIElement: 일관된 UI 관리 인터페이스 구현</span>
<span class="comment">// HashSet<AbstractCommandable>: 선택된 유닛들의 컨텍스트 타입</span>
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Linq;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> UnityEngine.UI;

<span class="keyword">namespace</span> GameDevTV.RTS.UI.Containers
{
    <span class="comment">// 액션 버튼들을 관리하는 컨테이너 클래스</span>
    <span class="comment">// ActionsUI: "액션 UI"라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="comment">// IUIElement: UI 요소의 일관된 관리 인터페이스</span>
    <span class="keyword">public class</span> <span class="class-name">ActionsUI</span> : <span class="class-name">MonoBehaviour</span>, <span class="class-name">IUIElement</span>&lt;<span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt;&gt;
    {
        <span class="comment">// 액션 버튼들의 배열</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// UIActionButton[]: 개별 액션 버튼 컴포넌트들의 배열</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">UIActionButton</span>[] actionButtons;

        <span class="comment">// IUIElement 인터페이스의 EnableFor 메서드 구현</span>
        <span class="comment">// EnableFor: 선택된 유닛들을 받아서 UI를 활성화</span>
        <span class="comment">// HashSet<AbstractCommandable> selectedUnits: 현재 선택된 유닛들</span>
        <span class="keyword">public void</span> <span class="method-name">EnableFor</span>(<span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt; selectedUnits)
        {
            <span class="comment">// 선택된 유닛들의 액션 버튼들을 새로고침</span>
            <span class="comment">// RefreshButtons: 버튼들을 업데이트하는 메서드</span>
            <span class="comment">// selectedUnits: 현재 선택된 유닛들</span>
            <span class="method-name">RefreshButtons</span>(selectedUnits);
        }

        <span class="comment">// IUIElement 인터페이스의 Disable 메서드 구현</span>
        <span class="comment">// Disable: 모든 액션 버튼들을 비활성화</span>
        <span class="keyword">public void</span> <span class="method-name">Disable</span>()
        {
            <span class="comment">// 모든 액션 버튼들을 비활성화</span>
            <span class="comment">// foreach: 배열의 모든 요소에 대해 반복</span>
            <span class="comment">// Disable: 각 버튼의 비활성화 메서드 호출</span>
            <span class="keyword">foreach</span> (<span class="keyword">var</span> button <span class="keyword">in</span> actionButtons)
            {
                button.<span class="method-name">Disable</span>();
            }
        }

        <span class="comment">// 액션 버튼들을 새로고침하는 메서드</span>
        <span class="comment">// RefreshButtons: "버튼들 새로고침"이라는 의미</span>
        <span class="comment">// HashSet<AbstractCommandable> selectedUnits: 현재 선택된 유닛들</span>
        <span class="keyword">private void</span> <span class="method-name">RefreshButtons</span>(<span class="class-name">HashSet</span>&lt;<span class="class-name">AbstractCommandable</span>&gt; selectedUnits)
        {
            <span class="comment">// 선택된 유닛들의 사용 가능한 액션들을 수집</span>
            <span class="comment">// HashSet: 중복을 허용하지 않는 컬렉션</span>
            <span class="comment">// ActionBase: 모든 액션의 기본 클래스</span>
            <span class="keyword">var</span> availableActions = <span class="keyword">new</span> <span class="class-name">HashSet</span>&lt;<span class="class-name">ActionBase</span>&gt;();
            
            <span class="comment">// 각 선택된 유닛의 사용 가능한 액션들을 수집</span>
            <span class="comment">// foreach: 선택된 모든 유닛에 대해 반복</span>
            <span class="comment">// AvailableCommands: 유닛이 사용할 수 있는 액션들</span>
            <span class="keyword">foreach</span> (<span class="keyword">var</span> unit <span class="keyword">in</span> selectedUnits)
            {
                <span class="comment">// 유닛의 사용 가능한 액션들을 availableActions에 추가</span>
                <span class="comment">// UnionWith: 두 HashSet을 합치는 메서드</span>
                <span class="comment">// 중복된 액션은 자동으로 제거됨</span>
                availableActions.<span class="method-name">UnionWith</span>(unit.<span class="property-name">AvailableCommands</span>);
            }

            <span class="comment">// 각 액션 버튼을 설정</span>
            <span class="comment">// for loop: 액션 버튼 배열의 각 요소에 대해 반복</span>
            <span class="comment">// actionButtons.Length: 배열의 길이</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < actionButtons.<span class="property-name">Length</span>; i++)
            {
                <span class="comment">// 해당 슬롯 번호의 액션을 찾기</span>
                <span class="comment">// LINQ Where: 조건에 맞는 요소들만 필터링</span>
                <span class="comment">// Slot: 액션의 슬롯 번호 (0~8)</span>
                <span class="comment">// FirstOrDefault: 조건에 맞는 첫 번째 요소 반환 (없으면 null)</span>
                <span class="keyword">var</span> action = availableActions.<span class="method-name">Where</span>(a => a.<span class="property-name">Slot</span> == i).<span class="method-name">FirstOrDefault</span>();
                
                <span class="keyword">if</span> (action != <span class="keyword">null</span>)
                {
                    <span class="comment">// 액션이 있으면 버튼 활성화</span>
                    <span class="comment">// EnableFor: 버튼을 활성화하고 액션과 콜백 설정</span>
                    <span class="comment">// action: 활성화할 액션</span>
                    <span class="comment">// () => Bus<ActionSelectedEvent>.Raise(new ActionSelectedEvent(action)): 클릭 시 실행될 콜백</span>
                    actionButtons[i].<span class="method-name">EnableFor</span>(action, () => <span class="class-name">Bus</span>&lt;<span class="class-name">ActionSelectedEvent</span>&gt;.<span class="method-name">Raise</span>(<span class="keyword">new</span> <span class="class-name">ActionSelectedEvent</span>(action)));
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// 액션이 없으면 버튼 비활성화</span>
                    <span class="comment">// Disable: 버튼을 비활성화</span>
                    actionButtons[i].<span class="method-name">Disable</span>();
                }
            }
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🔧 UIActionButton 리팩토링</h3>
                
                <div class="code-block">
<span class="comment">// UIActionButton.cs - 리팩토링된 버전</span>
<span class="comment">// UIActionButton: 개별 액션 버튼 컴포넌트</span>
<span class="comment">// IUIElement: 일관된 UI 관리 인터페이스 구현</span>
<span class="comment">// ActionBase, UnityAction: 액션과 콜백 함수 타입</span>
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> UnityEngine.UI;

<span class="keyword">namespace</span> GameDevTV.RTS.UI.Components
{
    <span class="comment">// 개별 액션 버튼을 관리하는 컴포넌트</span>
    <span class="comment">// UIActionButton: "UI 액션 버튼"이라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="comment">// IUIElement: UI 요소의 일관된 관리 인터페이스</span>
    <span class="comment">// RequireComponent: 이 컴포넌트가 Button 컴포넌트를 필요로 함</span>
    [<span class="class-name">RequireComponent</span>(<span class="keyword">typeof</span>(<span class="class-name">Button</span>))]
    <span class="keyword">public class</span> <span class="class-name">UIActionButton</span> : <span class="class-name">MonoBehaviour</span>, <span class="class-name">IUIElement</span>&lt;<span class="class-name">ActionBase</span>, <span class="class-name">UnityAction</span>&gt;
    {
        <span class="comment">// 버튼 컴포넌트 참조</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// Button: Unity의 버튼 컴포넌트</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Button</span> button;
        
        <span class="comment">// 아이콘을 표시할 이미지 컴포넌트</span>
        <span class="comment">// Image: Unity의 이미지 컴포넌트</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Image</span> iconImage;

        <span class="comment">// IUIElement 인터페이스의 EnableFor 메서드 구현</span>
        <span class="comment">// EnableFor: 액션과 콜백을 받아서 버튼을 활성화</span>
        <span class="comment">// ActionBase action: 활성화할 액션</span>
        <span class="comment">// UnityAction onClick: 클릭 시 실행될 콜백</span>
        <span class="keyword">public void</span> <span class="method-name">EnableFor</span>(<span class="class-name">ActionBase</span> action, <span class="class-name">UnityAction</span> onClick)
        {
            <span class="comment">// 버튼을 활성화</span>
            <span class="comment">// SetActive: GameObject의 활성화/비활성화</span>
            <span class="comment">// true: 활성화</span>
            button.<span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">true</span>);
            
            <span class="comment">// 액션의 아이콘을 이미지에 설정</span>
            <span class="comment">// Icon: ActionBase에 정의된 아이콘 스프라이트</span>
            iconImage.<span class="property-name">sprite</span> = action.<span class="property-name">Icon</span>;
            
            <span class="comment">// 버튼 클릭 이벤트 설정</span>
            <span class="comment">// RemoveAllListeners: 기존의 모든 이벤트 리스너 제거</span>
            <span class="comment">// AddListener: 새로운 이벤트 리스너 추가</span>
            button.<span class="property-name">onClick</span>.<span class="method-name">RemoveAllListeners</span>();
            button.<span class="property-name">onClick</span>.<span class="method-name">AddListener</span>(onClick);
        }

        <span class="comment">// IUIElement 인터페이스의 Disable 메서드 구현</span>
        <span class="comment">// Disable: 버튼을 비활성화</span>
        <span class="keyword">public void</span> <span class="method-name">Disable</span>()
        {
            <span class="comment">// 버튼을 비활성화</span>
            <span class="comment">// SetActive: GameObject의 활성화/비활성화</span>
            <span class="comment">// false: 비활성화</span>
            button.<span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">false</span>);
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>📋 UI 확장성의 중요성</h4>
                    <p><strong>모듈화된 구조</strong>: 각 UI 컨테이너가 독립적으로 동작</p>
                    <p><strong>일관된 관리</strong>: 모든 UI 요소가 동일한 패턴으로 관리됨</p>
                    <p><strong>코드 재사용</strong>: 새로운 UI 컨테이너 추가 시 기존 패턴 활용</p>
                    <p><strong>유지보수성</strong>: 각 UI 요소의 책임이 명확히 분리됨</p>
                </div>

                <div class="tech-stack">
                    <h4>🔄 단방향 데이터 흐름의 장점</h4>
                    <p><strong>상태 관리 단순화</strong>: RuntimeUI에서만 상태를 관리</p>
                    <p><strong>디버깅 용이성</strong>: 데이터 흐름을 추적하기 쉬움</p>
                    <p><strong>예측 가능성</strong>: UI 상태 변화를 예측하기 쉬움</p>
                    <p><strong>테스트 용이성</strong>: 각 컴포넌트를 독립적으로 테스트 가능</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>네임스페이스 관리</strong>: 폴더 구조와 네임스페이스 일치 유지</p>
                    <p><strong>이벤트 구독 해제</strong>: OnDestroy에서 반드시 이벤트 구독 해제</p>
                    <p><strong>컨텍스트 타입</strong>: 각 UI 요소가 필요한 컨텍스트 타입 명확히 정의</p>
                    <p><strong>성능 고려</strong>: HashSet 사용으로 중복 제거 및 빠른 검색</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>UI 시스템 확장</strong>: 다양한 게임 모드별 UI 컨테이너 추가</li>
                    <li><strong>컨텍스트 기반 UI</strong>: 선택된 유닛/건물에 따라 다른 UI 표시</li>
                    <li><strong>모듈화된 구조</strong>: 각 UI 기능을 독립적인 컨테이너로 분리</li>
                    <li><strong>일관된 관리</strong>: 모든 UI 요소의 활성화/비활성화 통일</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>IUIElement 인터페이스</strong>: UI 요소의 일관된 관리 패턴</li>
                    <li><strong>Generic Types</strong>: 다양한 타입의 컨텍스트 지원</li>
                    <li><strong>폴더 구조와 네임스페이스</strong>: 코드 조직화의 중요성</li>
                    <li><strong>단방향 데이터 흐름</strong>: 상태 관리의 단순화</li>
                    <li><strong>HashSet</strong>: 중복 제거와 빠른 검색</li>
                    <li><strong>이벤트 구독/해제</strong>: 메모리 누수 방지</li>
                </ul>
            </div>
        </div>

        <!-- 강의 32: Progress Bar Component (프로그레스 바 컴포넌트) -->
        <div class="lecture-section" id="lecture-32">
            <h2 class="lecture-title">📊 강의 32: Progress Bar Component (프로그레스 바 컴포넌트)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">시각적 피드백 제공</strong>: <span style="color: #2c3e50;">건물에서 유닛 생산 진행 상황을 시각적으로 표시</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">사용자 경험 향상</strong>: <span style="color: #2c3e50;">플레이어가 빌드 진행도를 명확히 파악할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">재사용 가능한 컴포넌트</strong>: <span style="color: #2c3e50;">다양한 진행 상황 표시에 활용 가능한 범용 컴포넌트</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">UI 시스템 확장</strong>: <span style="color: #2c3e50;">BuildingBuildingUI에서 사용할 핵심 컴포넌트</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>📊 프로그레스 바가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">게임에서 뭔가가 얼마나 진행되었는지 보여주는 막대기예요. 마치 다운로드할 때 나타나는 진행 막대처럼요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>진행 상황 표시</strong>: 건물에서 유닛이 얼마나 만들어졌는지 보여줘요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>기다림의 즐거움</strong>: 언제 완성될지 알 수 있어서 기다리는 재미가 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>게임 정보 제공</strong>: 플레이어가 게임 상황을 쉽게 파악할 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집을 지을 때 공사 진행도를 보여주는 표시판과 같아요. 언제 완성될지 알 수 있어서 기다리는 마음이 달라져요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Unity UI Mask를 활용한 프로그레스 바 구현</li>
                    <li>RectTransform의 offset min/max 조작</li>
                    <li>패딩을 고려한 정확한 위치 계산</li>
                    <li>재사용 가능한 프로그레스 바 컴포넌트 설계</li>
                    <li>디버깅을 위한 Inspector 연동</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🎨 Progress Bar 구조</h3>
                
                <div class="code-block">
<span class="comment">// Progress Bar UI 구조</span>
<span class="comment">// Progress Bar GameObject</span>
<span class="comment">// ├── Background Image (배경 이미지)</span>
<span class="comment">// └── Mask (마스크)</span>
<span class="comment">//     └── Progress Image (진행 이미지 - 타일링)</span>

<span class="comment">// 핵심 원리:</span>
<span class="comment">// 1. Mask의 width를 조절하여 진행도를 표시</span>
<span class="comment">// 2. 타일링된 이미지로 자연스러운 애니메이션</span>
<span class="comment">// 3. 패딩을 고려한 정확한 위치 계산</span>
</div>
            </div>

            <div class="content-section">
                <h3>🔧 ProgressBar 컴포넌트</h3>
                
                <div class="code-block">
<span class="comment">// ProgressBar.cs - 프로그레스 바 컴포넌트</span>
<span class="comment">// ProgressBar: 진행 상황을 시각적으로 표시하는 UI 컴포넌트</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.UI.Components
{
    <span class="comment">// 진행 상황을 시각적으로 표시하는 컴포넌트</span>
    <span class="comment">// ProgressBar: "진행 막대"라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">ProgressBar</span> : <span class="class-name">MonoBehaviour</span>
    {
        <span class="comment">// 마스크 RectTransform 참조</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// RectTransform: UI 요소의 위치, 크기, 회전을 관리하는 컴포넌트</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">RectTransform</span> mask;
        
        <span class="comment">// 마스크의 부모 RectTransform</span>
        <span class="comment">// maskParentRectTransform: 마스크의 부모 컨테이너</span>
        <span class="keyword">private</span> <span class="class-name">RectTransform</span> maskParentRectTransform;
        
        <span class="comment">// 프로그레스 바의 패딩</span>
        <span class="comment">// [SerializeField]: Inspector에서 설정 가능</span>
        <span class="comment">// Vector2: X, Y 좌표를 가진 2D 벡터</span>
        <span class="comment">// new Vector2(9, 8): 기본 패딩 값 (X: 9, Y: 8)</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Vector2</span> padding = <span class="keyword">new</span> <span class="class-name">Vector2</span>(<span class="number">9</span>, <span class="number">8</span>);

        <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
        <span class="comment">// Awake: GameObject가 생성될 때 한 번만 실행</span>
        <span class="keyword">private void</span> <span class="method-name">Awake</span>()
        {
            <span class="comment">// 마스크가 할당되지 않은 경우 에러 처리</span>
            <span class="comment">// Guardian Pattern: 잘못된 상태를 미리 방지</span>
            <span class="keyword">if</span> (mask == <span class="keyword">null</span>)
            {
                <span class="comment">// 에러 로그 출력</span>
                <span class="comment">// Debug.LogError: 콘솔에 빨간색 에러 메시지 출력</span>
                <span class="comment">// 이 컴포넌트가 제대로 작동하지 않을 것임을 알림</span>
                <span class="class-name">Debug</span>.<span class="method-name">LogError</span>(<span class="string">"This progress bar is missing a mask"</span>);
                <span class="comment">// 메서드 조기 종료</span>
                <span class="keyword">return</span>;
            }

            <span class="comment">// 마스크의 부모 RectTransform 가져오기</span>
            <span class="comment">// mask.parent: 마스크의 부모 GameObject</span>
            <span class="comment">// GetComponent: 특정 컴포넌트를 찾는 Unity 메서드</span>
            <span class="comment">// RectTransform: UI 요소의 변환 정보</span>
            maskParentRectTransform = mask.<span class="property-name">parent</span>.<span class="method-name">GetComponent</span>&lt;<span class="class-name">RectTransform</span>&gt;();
        }

        <span class="comment">// 프로그레스 바의 진행도를 설정하는 메서드</span>
        <span class="comment">// SetProgress: "진행도 설정"이라는 의미</span>
        <span class="comment">// float progress: 0.0 ~ 1.0 사이의 진행도 값</span>
        <span class="comment">// 0.0: 0% 진행 (비어있음)</span>
        <span class="comment">// 1.0: 100% 진행 (가득참)</span>
        <span class="keyword">public void</span> <span class="method-name">SetProgress</span>(<span class="keyword">float</span> progress)
        {
            <span class="comment">// 부모 컨테이너의 크기 가져오기</span>
            <span class="comment">// sizeDelta: RectTransform의 크기 정보</span>
            <span class="comment">// 부모 컨테이너의 전체 크기를 기준으로 계산</span>
            <span class="class-name">Vector2</span> parentSize = maskParentRectTransform.<span class="property-name">sizeDelta</span>;
            
            <span class="comment">// 패딩을 고려한 실제 사용 가능한 크기 계산</span>
            <span class="comment">// padding * 2: 좌우, 상하 패딩을 모두 고려</span>
            <span class="comment">// parentSize - (padding * 2): 패딩을 제외한 실제 크기</span>
            <span class="class-name">Vector2</span> availableSize = parentSize - (padding * <span class="number">2</span>);
            
            <span class="comment">// 진행도에 따른 목표 크기 계산</span>
            <span class="comment">// Mathf.Clamp01: 값을 0.0 ~ 1.0 사이로 제한</span>
            <span class="comment">// availableSize.x * clampedProgress: 진행도에 비례한 너비</span>
            <span class="keyword">float</span> clampedProgress = <span class="class-name">Mathf</span>.<span class="method-name">Clamp01</span>(progress);
            <span class="class-name">Vector2</span> targetSize = <span class="keyword">new</span> <span class="class-name">Vector2</span>(availableSize.x * clampedProgress, availableSize.y);
            
            <span class="comment">// 마스크의 offset min 설정 (좌상단 기준점)</span>
            <span class="comment">// offsetMin: RectTransform의 좌상단 오프셋</span>
            <span class="comment">// padding: 좌상단 패딩만큼 오프셋</span>
            mask.<span class="property-name">offsetMin</span> = padding;
            
            <span class="comment">// 마스크의 offset max 설정 (우하단 기준점)</span>
            <span class="comment">// offsetMax: RectTransform의 우하단 오프셋</span>
            <span class="comment">// Vector2(padding.x + targetSize.x - parentSize.x, -padding.y):</span>
            <span class="comment">// X: 패딩 + 목표크기 - 부모크기 (우측 정렬)</span>
            <span class="comment">// Y: -패딩 (하단 정렬)</span>
            mask.<span class="property-name">offsetMax</span> = <span class="keyword">new</span> <span class="class-name">Vector2</span>(
                padding.x + targetSize.x - parentSize.x, 
                -padding.y
            );
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎯 핵심 알고리즘</h3>
                
                <div class="code-block">
<span class="comment">// 프로그레스 바 계산 알고리즘</span>

<span class="comment">// 1. 기본 크기 계산</span>
<span class="comment">// parentSize: 부모 컨테이너의 전체 크기</span>
<span class="comment">// availableSize = parentSize - (padding * 2): 패딩을 제외한 사용 가능한 크기</span>

<span class="comment">// 2. 진행도 적용</span>
<span class="comment">// targetSize.x = availableSize.x * progress: 진행도에 비례한 너비</span>
<span class="comment">// targetSize.y = availableSize.y: 높이는 항상 동일</span>

<span class="comment">// 3. 오프셋 계산</span>
<span class="comment">// offsetMin = padding: 좌상단은 패딩만큼 오프셋</span>
<span class="comment">// offsetMax.x = padding.x + targetSize.x - parentSize.x: 우측 정렬</span>
<span class="comment">// offsetMax.y = -padding.y: 하단 정렬</span>

<span class="comment">// 결과: 패딩을 고려한 정확한 위치에 진행도에 맞는 크기로 표시</span>
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>📊 시각적 피드백의 중요성</h4>
                    <p><strong>사용자 경험 향상</strong>: 플레이어가 진행 상황을 명확히 파악</p>
                    <p><strong>기다림의 즐거움</strong>: 언제 완성될지 알 수 있어서 기다리는 재미</p>
                    <p><strong>게임 정보 제공</strong>: 현재 상태를 시각적으로 표현</p>
                    <p><strong>전략적 계획</strong>: 빌드 완료 시점을 예측하여 전략 수립</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>재사용성</strong>: 다양한 진행 상황 표시에 활용 가능</p>
                    <p><strong>성능 효율성</strong>: Mask를 사용한 효율적인 렌더링</p>
                    <p><strong>유연성</strong>: 패딩과 크기를 Inspector에서 조정 가능</p>
                    <p><strong>확장성</strong>: 다양한 스타일과 애니메이션 추가 가능</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>Mask 설정</strong>: RectTransform의 anchor와 stretch 설정 중요</p>
                    <p><strong>패딩 계산</strong>: 정확한 오프셋 계산으로 자연스러운 표시</p>
                    <p><strong>이미지 타일링</strong>: 타일링된 이미지로 자연스러운 애니메이션</p>
                    <p><strong>성능 고려</strong>: 너무 자주 업데이트하지 않도록 주의</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>건물 빌드 진행도</strong>: Command Post에서 유닛 생산 진행 상황 표시</li>
                    <li><strong>자원 수집 진행도</strong>: Worker의 자원 수집 진행 상황 표시</li>
                    <li><strong>연구 진행도</strong>: 기술 연구의 진행 상황 표시</li>
                    <li><strong>건물 건설 진행도</strong>: 건물 건설의 진행 상황 표시</li>
                    <li><strong>체력 바</strong>: 유닛과 건물의 체력 표시</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>RectTransform</strong>: UI 요소의 위치, 크기, 회전 관리</li>
                    <li><strong>Mask</strong>: 특정 영역만 보이도록 하는 UI 마스킹</li>
                    <li><strong>offsetMin/offsetMax</strong>: RectTransform의 오프셋 값</li>
                    <li><strong>Vector2</strong>: 2D 좌표와 크기 표현</li>
                    <li><strong>Mathf.Clamp01</strong>: 값을 0.0~1.0 범위로 제한</li>
                    <li><strong>패딩 계산</strong>: 정확한 위치 계산을 위한 수학</li>
                    <li><strong>Guardian Pattern</strong>: 잘못된 상태 방지</li>
                </ul>
            </div>
        </div>

        <!-- 강의 33: Building Progress Display (건물 빌드 진행도 표시) -->
        <div class="lecture-section" id="lecture-33">
            <h2 class="lecture-title">🏗️ 강의 33: Building Progress Display (건물 빌드 진행도 표시)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">실시간 진행도 표시</strong>: <span style="color: #2c3e50;">건물에서 유닛 생산 진행 상황을 실시간으로 시각화</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">사용자 경험 향상</strong>: <span style="color: #2c3e50;">플레이어가 빌드 진행도를 명확히 파악할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">이벤트 기반 아키텍처</strong>: <span style="color: #2c3e50;">효율적인 UI 업데이트를 위한 이벤트 시스템 활용</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">BuildingBuildingUI 완성</strong>: <span style="color: #2c3e50;">이전 강의에서 만든 UI 컨테이너의 실제 활용</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🏗️ 건물 빌드 진행도가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">건물에서 유닛을 만들 때 얼마나 진행되었는지 보여주는 표시예요. 마치 요리할 때 타이머처럼요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>진행 상황 확인</strong>: 언제 유닛이 완성될지 알 수 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>기다림의 즐거움</strong>: 진행도를 보면서 기다리는 재미가 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>게임 정보 제공</strong>: 현재 상태를 명확히 알 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집을 지을 때 공사 진행도를 보여주는 표시판과 같아요. 언제 완성될지 알 수 있어서 기다리는 마음이 달라져요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>BuildingBuildingUI에서 Progress Bar 연동</li>
                    <li>BaseBuilding에 진행도 추적 필드 추가</li>
                    <li>이벤트 기반 큐 업데이트 시스템 구현</li>
                    <li>RuntimeUI에서 BuildingBuildingUI 관리</li>
                    <li>실시간 진행도 계산 및 표시</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔧 BaseBuilding 확장</h3>
                
                <div class="code-block">
<span class="comment">// BaseBuilding.cs - 건물 빌드 진행도 추적</span>
<span class="comment">// BaseBuilding: 모든 건물의 기본 클래스</span>
<span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체의 기본 클래스</span>
<span class="keyword">using</span> System.Collections;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// 모든 건물의 기본 클래스</span>
    <span class="comment">// BaseBuilding: "기본 건물"이라는 의미</span>
    <span class="comment">// AbstractCommandable: 명령을 받을 수 있는 객체</span>
    <span class="keyword">public class</span> <span class="class-name">BaseBuilding</span> : <span class="class-name">AbstractCommandable</span>
    {
        <span class="comment">// 건물 큐: 생산할 유닛들을 순서대로 저장하는 큐</span>
        <span class="comment">// Queue&lt;UnitSO&gt;: FIFO(First In, First Out) 방식으로 유닛을 처리</span>
        <span class="comment">// System.Collections.Generic.Queue: C#의 표준 큐 컬렉션</span>
        <span class="keyword">private</span> <span class="class-name">Queue</span>&lt;<span class="class-name">UnitSO</span>&gt; buildingQueue = <span class="keyword">new</span> <span class="class-name">Queue</span>&lt;<span class="class-name">UnitSO</span>&gt;(<span class="number">5</span>);
        
        <span class="comment">// 최대 큐 크기: 무한정 큐가 커지는 것을 방지</span>
        <span class="comment">// const: 컴파일 타임에 값이 결정되는 상수</span>
        <span class="comment">// private: 이 클래스 내부에서만 접근 가능</span>
        <span class="keyword">private const int</span> maxQueueSize = <span class="number">5</span>;

        <span class="comment">// 큐 크기 프로퍼티: 외부에서 큐의 현재 크기를 확인할 수 있음</span>
        <span class="comment">// Expression-bodied property: 간단한 getter만 있는 프로퍼티</span>
        <span class="comment">// buildingQueue.Count: 현재 큐에 있는 유닛의 개수</span>
        <span class="keyword">public int</span> <span class="property-name">QueueSize</span> => buildingQueue.<span class="property-name">Count</span>;
        
        <span class="comment">// 현재 큐 시작 시간: 현재 빌드 중인 유닛의 시작 시간</span>
        <span class="comment">// [field: SerializeField]: Inspector에서 확인 가능하도록 함</span>
        <span class="comment">// get; private set;: 읽기는 공개, 쓰기는 내부에서만</span>
        <span class="comment">// Time.time: 게임 시작부터 경과된 시간(초)</span>
        [<span class="class-name">field</span>: <span class="class-name">SerializeField</span>] <span class="keyword">public float</span> <span class="property-name">CurrentQueueStartTime</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        
        <span class="comment">// 현재 빌드 중인 유닛: 현재 큐에서 처리 중인 유닛 정보</span>
        <span class="comment">// [field: SerializeField]: Inspector에서 확인 가능하도록 함</span>
        <span class="comment">// get; private set;: 읽기는 공개, 쓰기는 내부에서만</span>
        [<span class="class-name">field</span>: <span class="class-name">SerializeField</span>] <span class="keyword">public</span> <span class="class-name">UnitSO</span> <span class="property-name">BuildingUnit</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }

        <span class="comment">// 큐 업데이트 이벤트 델리게이트: 큐가 변경될 때 호출되는 이벤트</span>
        <span class="comment">// delegate: 함수 포인터와 같은 역할을 하는 C# 타입</span>
        <span class="comment">// UnitSO[]: 큐에 있는 모든 유닛의 배열</span>
        <span class="keyword">public delegate void</span> <span class="class-name">QueueUpdatedEvent</span>(<span class="class-name">UnitSO</span>[] unitsInQueue);
        
        <span class="comment">// 큐 업데이트 이벤트: 큐가 변경될 때 발생하는 이벤트</span>
        <span class="comment">// event: 외부에서는 구독/해제만 가능하고 직접 호출은 불가능</span>
        <span class="comment">// OnQueueUpdated: 이벤트 이름 (관례적으로 On으로 시작)</span>
        <span class="keyword">public event</span> <span class="class-name">QueueUpdatedEvent</span> <span class="property-name">OnQueueUpdated</span>;

        <span class="comment">// 유닛 빌드 메서드: 큐에 새로운 유닛을 추가</span>
        <span class="comment">// BuildUnit: "유닛 빌드"라는 의미</span>
        <span class="comment">// UnitSO unit: 빌드할 유닛의 정보</span>
        <span class="keyword">public void</span> <span class="method-name">BuildUnit</span>(<span class="class-name">UnitSO</span> unit)
        {
            <span class="comment">// Guardian Pattern: 큐가 가득 찬 경우 요청을 거부</span>
            <span class="comment">// buildingQueue.Count: 현재 큐에 있는 유닛의 개수</span>
            <span class="comment">// maxQueueSize: 허용되는 최대 큐 크기</span>
            <span class="keyword">if</span> (buildingQueue.<span class="property-name">Count</span> >= maxQueueSize)
            {
                <span class="comment">// 큐가 가득 찬 경우 에러 로그 출력</span>
                <span class="comment">// Debug.LogError: 콘솔에 빨간색 에러 메시지 출력</span>
                <span class="comment">// 이는 코드의 버그를 나타내는 신호일 수 있음</span>
                <span class="class-name">Debug</span>.<span class="method-name">LogError</span>(<span class="string">$"BuildUnit was called when the queue was already full. This is not supported."</span>);
                <span class="comment">// 메서드 조기 종료</span>
                <span class="keyword">return</span>;
            }

            <span class="comment">// 큐에 새로운 유닛 추가</span>
            <span class="comment">// Enqueue: 큐의 끝에 항목을 추가하는 메서드</span>
            buildingQueue.<span class="method-name">Enqueue</span>(unit);

            <span class="comment">// 첫 번째 유닛을 추가한 경우에만 코루틴 시작</span>
            <span class="comment">// 이미 코루틴이 실행 중인 경우 새로 시작하지 않음</span>
            <span class="comment">// buildingQueue.Count == 1: 방금 첫 번째 유닛을 추가했음을 의미</span>
            <span class="keyword">if</span> (buildingQueue.<span class="property-name">Count</span> == <span class="number">1</span>)
            {
                <span class="comment">// DoBuildUnits 코루틴 시작 (매개변수 없음)</span>
                <span class="comment">// 이 코루틴이 전체 큐를 처리함</span>
                <span class="method-name">StartCoroutine</span>(<span class="method-name">DoBuildUnits</span>());
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// 큐에 이미 유닛이 있는 경우 이벤트 발생</span>
                <span class="comment">// OnQueueUpdated?.Invoke: null 체크 후 이벤트 호출</span>
                <span class="comment">// buildingQueue.ToArray(): 큐를 배열로 변환하여 전달</span>
                OnQueueUpdated?.<span class="method-name">Invoke</span>(buildingQueue.<span class="method-name">ToArray</span>());
            }
        }

        <span class="comment">// 빌드 코루틴: 큐에 있는 모든 유닛을 순서대로 빌드</span>
        <span class="comment">// DoBuildUnits: "유닛들을 빌드한다"는 의미</span>
        <span class="comment">// IEnumerator: 코루틴의 반환 타입</span>
        <span class="keyword">private</span> <span class="class-name">IEnumerator</span> <span class="method-name">DoBuildUnits</span>()
        {
            <span class="comment">// 큐에 유닛이 있는 동안 반복</span>
            <span class="comment">// while loop: 큐가 비어있을 때까지 계속 처리</span>
            <span class="keyword">while</span> (buildingQueue.<span class="property-name">Count</span> > <span class="number">0</span>)
            {
                <span class="comment">// 현재 빌드할 유닛 설정: 큐의 첫 번째 유닛을 가져옴</span>
                <span class="comment">// Peek: 큐의 첫 번째 항목을 확인하되 제거하지 않음</span>
                <span class="comment">// BuildingUnit: 현재 빌드 중인 유닛 정보를 저장</span>
                BuildingUnit = buildingQueue.<span class="method-name">Peek</span>();
                
                <span class="comment">// 현재 큐 시작 시간 설정: 빌드 시작 시점 기록</span>
                <span class="comment">// Time.time: 게임 시작부터 경과된 시간(초)</span>
                <span class="comment">// CurrentQueueStartTime: 프로그레스 바 계산에 사용</span>
                CurrentQueueStartTime = <span class="class-name">Time</span>.<span class="property-name">time</span>;
                
                <span class="comment">// 큐 업데이트 이벤트 발생: UI에 큐 변경 알림</span>
                <span class="comment">// OnQueueUpdated?.Invoke: null 체크 후 이벤트 호출</span>
                <span class="comment">// buildingQueue.ToArray(): 큐를 배열로 변환하여 전달</span>
                OnQueueUpdated?.<span class="method-name">Invoke</span>(buildingQueue.<span class="method-name">ToArray</span>());

                <span class="comment">// 해당 유닛의 빌드 시간만큼 대기</span>
                <span class="comment">// yield return: 코루틴을 일시 정지하고 다음 프레임에 재개</span>
                <span class="comment">// WaitForSeconds: 지정된 시간(초) 동안 대기</span>
                <span class="comment">// BuildingUnit.BuildTime: 현재 빌드 중인 유닛의 빌드 시간</span>
                <span class="keyword">yield return new</span> <span class="class-name">WaitForSeconds</span>(BuildingUnit.<span class="property-name">BuildTime</span>);

                <span class="comment">// 유닛 생성</span>
                <span class="comment">// Instantiate: GameObject를 복제하여 씬에 생성</span>
                <span class="comment">// BuildingUnit.Prefab: 현재 빌드 중인 유닛의 프리팹</span>
                <span class="comment">// transform.position: 건물의 위치에서 유닛 생성</span>
                <span class="comment">// Quaternion.identity: 회전 없음 (기본 회전)</span>
                <span class="method-name">Instantiate</span>(BuildingUnit.<span class="property-name">Prefab</span>, <span class="property-name">transform</span>.<span class="property-name">position</span>, <span class="class-name">Quaternion</span>.<span class="property-name">identity</span>);

                <span class="comment">// Dequeue: 큐의 첫 번째 항목을 제거하고 반환</span>
                <span class="comment">// 빌드가 완료된 유닛을 큐에서 제거</span>
                <span class="comment">// 반환값은 사용하지 않으므로 변수에 저장하지 않음</span>
                buildingQueue.<span class="method-name">Dequeue</span>();
            }

            <span class="comment">// 모든 빌드 완료 후 빈 큐로 이벤트 발생</span>
            <span class="comment">// OnQueueUpdated?.Invoke: null 체크 후 이벤트 호출</span>
            <span class="comment">// buildingQueue.ToArray(): 빈 배열을 전달하여 빌드 완료 알림</span>
            OnQueueUpdated?.<span class="method-name">Invoke</span>(buildingQueue.<span class="method-name">ToArray</span>());
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎨 BuildingBuildingUI 구현</h3>
                
                <div class="code-block">
<span class="comment">// BuildingBuildingUI.cs - 건물 빌드 진행도 UI</span>
<span class="comment">// BuildingBuildingUI: 건물에서 유닛을 빌드할 때의 진행도를 표시하는 UI</span>
<span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
<span class="keyword">using</span> System.Collections;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> GameDevTV.RTS.UI.Components;

<span class="keyword">namespace</span> GameDevTV.RTS.UI.Containers
{
    <span class="comment">// 건물 빌드 진행도를 표시하는 UI 컨테이너</span>
    <span class="comment">// BuildingBuildingUI: "건물이 빌드하는 UI"라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">BuildingBuildingUI</span> : <span class="class-name">MonoBehaviour</span>
    {
        <span class="comment">// 프로그레스 바 참조</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// ProgressBar: 이전 강의에서 만든 프로그레스 바 컴포넌트</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">ProgressBar</span> progressBar;
        
        <span class="comment">// 현재 활성화된 건물</span>
        <span class="comment">// BaseBuilding: 현재 빌드 진행도를 추적할 건물</span>
        <span class="keyword">private</span> <span class="class-name">BaseBuilding</span> building;
        
        <span class="comment">// 빌드 코루틴 참조</span>
        <span class="comment">// Coroutine: 진행도 업데이트를 위한 코루틴</span>
        <span class="keyword">private</span> <span class="class-name">Coroutine</span> buildCoroutine;

        <span class="comment">// UI 활성화 메서드: 특정 건물에 대해 UI를 활성화</span>
        <span class="comment">// EnableFor: "~에 대해 활성화한다"는 의미</span>
        <span class="comment">// BaseBuilding item: 활성화할 건물</span>
        <span class="keyword">public void</span> <span class="method-name">EnableFor</span>(<span class="class-name">BaseBuilding</span> item)
        {
            <span class="comment">// 건물 참조 저장</span>
            <span class="comment">// building: 현재 활성화된 건물을 저장</span>
            building = item;
            
            <span class="comment">// GameObject 활성화</span>
            <span class="comment">// SetActive(true): 이 GameObject를 활성화</span>
            <span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">true</span>);
            
            <span class="comment">// 큐 업데이트 이벤트 구독</span>
            <span class="comment">// OnQueueUpdated: 큐가 변경될 때 발생하는 이벤트</span>
            <span class="comment">// HandleQueueUpdated: 이벤트 처리 메서드</span>
            building.<span class="property-name">OnQueueUpdated</span> += <span class="method-name">HandleQueueUpdated</span>;
        }

        <span class="comment">// UI 비활성화 메서드</span>
        <span class="comment">// Disable: "비활성화한다"는 의미</span>
        <span class="keyword">public void</span> <span class="method-name">Disable</span>()
        {
            <span class="comment">// 이벤트 구독 해제</span>
            <span class="comment">// building이 null이 아닌 경우에만 구독 해제</span>
            <span class="comment">// 메모리 누수 방지를 위해 반드시 필요</span>
            <span class="keyword">if</span> (building != <span class="keyword">null</span>)
            {
                building.<span class="property-name">OnQueueUpdated</span> -= <span class="method-name">HandleQueueUpdated</span>;
            }
            
            <span class="comment">// 건물 참조 초기화</span>
            <span class="comment">// building = null: 참조를 해제하여 가비지 컬렉션 대상으로 만듦</span>
            building = <span class="keyword">null</span>;
            
            <span class="comment">// 빌드 코루틴 초기화</span>
            <span class="comment">// buildCoroutine = null: 코루틴 참조를 해제</span>
            buildCoroutine = <span class="keyword">null</span>;
            
            <span class="comment">// GameObject 비활성화</span>
            <span class="comment">// SetActive(false): 이 GameObject를 비활성화</span>
            <span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">false</span>);
        }

        <span class="comment">// 큐 업데이트 이벤트 처리 메서드</span>
        <span class="comment">// HandleQueueUpdated: "큐 업데이트를 처리한다"는 의미</span>
        <span class="comment">// UnitSO[] unitsInQueue: 큐에 있는 유닛들의 배열</span>
        <span class="keyword">private void</span> <span class="method-name">HandleQueueUpdated</span>(<span class="class-name">UnitSO</span>[] unitsInQueue)
        {
            <span class="comment">// 큐에 유닛이 있고 아직 코루틴이 시작되지 않은 경우</span>
            <span class="comment">// unitsInQueue.Length == 1: 큐에 정확히 1개의 유닛이 있음</span>
            <span class="comment">// buildCoroutine == null: 아직 진행도 업데이트 코루틴이 시작되지 않음</span>
            <span class="keyword">if</span> (unitsInQueue.<span class="property-name">Length</span> == <span class="number">1</span> && buildCoroutine == <span class="keyword">null</span>)
            {
                <span class="comment">// 진행도 업데이트 코루틴 시작</span>
                <span class="comment">// StartCoroutine: 코루틴을 시작하는 Unity 메서드</span>
                <span class="comment">// UpdateUnitProgress: 진행도를 업데이트하는 코루틴</span>
                buildCoroutine = <span class="method-name">StartCoroutine</span>(<span class="method-name">UpdateUnitProgress</span>());
            }
        }

        <span class="comment">// 유닛 진행도 업데이트 코루틴</span>
        <span class="comment">// UpdateUnitProgress: "유닛 진행도를 업데이트한다"는 의미</span>
        <span class="comment">// IEnumerator: 코루틴의 반환 타입</span>
        <span class="keyword">private</span> <span class="class-name">IEnumerator</span> <span class="method-name">UpdateUnitProgress</span>()
        {
            <span class="comment">// 건물이 있고 큐에 유닛이 있는 동안 반복</span>
            <span class="comment">// building != null: 건물이 여전히 활성화되어 있음</span>
            <span class="comment">// building.QueueSize > 0: 큐에 빌드할 유닛이 있음</span>
            <span class="keyword">while</span> (building != <span class="keyword">null</span> && building.<span class="property-name">QueueSize</span> > <span class="number">0</span>)
            {
                <span class="comment">// 시작 시간과 종료 시간 계산</span>
                <span class="comment">// float startTime: 빌드 시작 시간</span>
                <span class="comment">// building.CurrentQueueStartTime: 현재 빌드 시작 시간</span>
                <span class="keyword">float</span> startTime = building.<span class="property-name">CurrentQueueStartTime</span>;
                
                <span class="comment">// float endTime: 빌드 완료 예상 시간</span>
                <span class="comment">// startTime + building.BuildingUnit.BuildTime: 시작 시간 + 빌드 시간</span>
                <span class="keyword">float</span> endTime = startTime + building.<span class="property-name">BuildingUnit</span>.<span class="property-name">BuildTime</span>;
                
                <span class="comment">// 현재 진행도 계산</span>
                <span class="comment">// Mathf.Clamp01: 값을 0.0 ~ 1.0 사이로 제한</span>
                <span class="comment">// (Time.time - startTime) / (endTime - startTime): 진행도 비율</span>
                <span class="keyword">float</span> progress = <span class="class-name">Mathf</span>.<span class="method-name">Clamp01</span>((<span class="class-name">Time</span>.<span class="property-name">time</span> - startTime) / (endTime - startTime));
                
                <span class="comment">// 프로그레스 바에 진행도 설정</span>
                <span class="comment">// progressBar.SetProgress: 프로그레스 바의 진행도를 설정</span>
                <span class="comment">// progress: 0.0 ~ 1.0 사이의 진행도 값</span>
                progressBar.<span class="method-name">SetProgress</span>(progress);
                
                <span class="comment">// 다음 프레임까지 대기</span>
                <span class="comment">// yield return null: 다음 프레임까지 대기</span>
                <span class="comment">// 매 프레임마다 진행도를 업데이트</span>
                <span class="keyword">yield return null</span>;
            }
            
            <span class="comment">// 코루틴 완료 후 참조 초기화</span>
            <span class="comment">// buildCoroutine = null: 코루틴 참조를 해제</span>
            buildCoroutine = <span class="keyword">null</span>;
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎯 핵심 알고리즘</h3>
                
                <div class="code-block">
<span class="comment">// 진행도 계산 알고리즘</span>

<span class="comment">// 1. 시간 기반 진행도 계산</span>
<span class="comment">// startTime: 빌드 시작 시간 (CurrentQueueStartTime)</span>
<span class="comment">// endTime: 빌드 완료 예상 시간 (startTime + BuildTime)</span>
<span class="comment">// currentTime: 현재 시간 (Time.time)</span>

<span class="comment">// 2. 진행도 비율 계산</span>
<span class="comment">// progress = (currentTime - startTime) / (endTime - startTime)</span>
<span class="comment">// 결과: 0.0 (시작) ~ 1.0 (완료) 사이의 값</span>

<span class="comment">// 3. 값 범위 제한</span>
<span class="comment">// Mathf.Clamp01(progress): 0.0 ~ 1.0 사이로 제한</span>
<span class="comment">// 음수나 1.0 초과 값 방지</span>

<span class="comment">// 4. 실시간 업데이트</span>
<span class="comment">// 코루틴을 사용하여 매 프레임마다 진행도 계산</span>
<span class="comment">// yield return null: 다음 프레임까지 대기</span>

<span class="comment">// 결과: 부드럽고 정확한 진행도 표시</span>
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>📊 실시간 피드백의 중요성</h4>
                    <p><strong>사용자 경험 향상</strong>: 플레이어가 빌드 진행도를 실시간으로 확인</p>
                    <p><strong>기다림의 즐거움</strong>: 언제 완성될지 알 수 있어서 기다리는 재미</p>
                    <p><strong>게임 정보 제공</strong>: 현재 상태를 명확히 시각화</p>
                    <p><strong>전략적 계획</strong>: 빌드 완료 시점을 예측하여 전략 수립</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>이벤트 기반 아키텍처</strong>: 효율적인 UI 업데이트</p>
                    <p><strong>메모리 효율성</strong>: 필요한 때만 코루틴 실행</p>
                    <p><strong>확장성</strong>: 다양한 진행도 표시에 활용 가능</p>
                    <p><strong>유지보수성</strong>: 깔끔한 코드 구조</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>이벤트 구독 해제</strong>: 메모리 누수 방지를 위해 반드시 필요</p>
                    <p><strong>코루틴 관리</strong>: 중복 실행 방지</p>
                    <p><strong>시간 계산</strong>: 정확한 진행도 계산을 위한 수학</p>
                    <p><strong>성능 고려</strong>: 매 프레임 업데이트의 성능 영향</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>건물 빌드 진행도</strong>: Command Post에서 유닛 생산 진행 상황 표시</li>
                    <li><strong>연구 진행도</strong>: 기술 연구의 진행 상황 표시</li>
                    <li><strong>건물 건설 진행도</strong>: 건물 건설의 진행 상황 표시</li>
                    <li><strong>자원 수집 진행도</strong>: Worker의 자원 수집 진행 상황 표시</li>
                    <li><strong>업그레이드 진행도</strong>: 건물 업그레이드의 진행 상황 표시</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>이벤트 기반 아키텍처</strong>: 효율적인 UI 업데이트</li>
                    <li><strong>델리게이트와 이벤트</strong>: 함수 포인터와 이벤트 시스템</li>
                    <li><strong>코루틴</strong>: 시간 기반 비동기 처리</li>
                    <li><strong>시간 계산</strong>: Time.time을 활용한 진행도 계산</li>
                    <li><strong>Mathf.Clamp01</strong>: 값을 0.0~1.0 범위로 제한</li>
                    <li><strong>메모리 관리</strong>: 이벤트 구독/해제와 참조 관리</li>
                    <li><strong>Guardian Pattern</strong>: 잘못된 상태 방지</li>
                </ul>
            </div>
        </div>

        <!-- 강의 34: Cancel Queue Items (큐 항목 취소) -->
        <div class="lecture-section" id="lecture-34">
            <h2 class="lecture-title">❌ 강의 34: Cancel Queue Items (큐 항목 취소)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">사용자 제어권 강화</strong>: <span style="color: #2c3e50;">플레이어가 빌드 큐에서 특정 유닛을 취소할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">전략적 유연성</strong>: <span style="color: #2c3e50;">게임 상황에 따라 빌드 계획을 변경할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">데이터 구조 최적화</strong>: <span style="color: #2c3e50;">Queue에서 List로 변경하여 인덱스 접근 가능</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">UI 상호작용 완성</strong>: <span style="color: #2c3e50;">빌드 큐 버튼을 통한 직관적인 취소 기능</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>❌ 큐 항목 취소가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">건물에서 유닛을 만들기로 했는데, 마음이 바뀌어서 그 유닛을 만들지 않기로 하는 거예요. 마치 주문을 취소하는 것처럼요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>전략 변경</strong>: 게임 상황이 바뀌어서 다른 유닛이 필요해요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>자원 절약</strong>: 불필요한 유닛 생산을 중단할 수 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>사용자 제어</strong>: 플레이어가 게임을 더 잘 조절할 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집을 지을 때 공사 계획을 바꾸는 것과 같아요. 이미 시작한 공사는 중단하고, 아직 시작하지 않은 공사는 취소할 수 있어요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Queue에서 List로 데이터 구조 변경</li>
                    <li>특정 인덱스 항목 제거 기능 구현</li>
                    <li>UIBuildQueueButton 컴포넌트 생성</li>
                    <li>BuildingBuildingUI에서 취소 버튼 관리</li>
                    <li>코루틴 중지 및 재시작 로직</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔧 데이터 구조 변경: Queue → List</h3>
                
                <div class="code-block">
<span class="comment">// BaseBuilding.cs - 데이터 구조 변경</span>
<span class="comment">// Queue에서 List로 변경하는 이유:</span>
<span class="comment">// 1. 특정 인덱스의 항목을 제거할 수 있음</span>
<span class="comment">// 2. 인덱스 접근이 가능함</span>
<span class="comment">// 3. Queue는 FIFO만 지원하지만 List는 유연한 조작 가능</span>

<span class="comment">// 기존 Queue 구조</span>
<span class="comment">// private Queue&lt;UnitSO&gt; buildingQueue = new Queue&lt;UnitSO&gt;(5);</span>
<span class="comment">// 문제점: 특정 인덱스의 항목을 제거할 수 없음</span>

<span class="comment">// 새로운 List 구조</span>
<span class="comment">// 건물 큐: 생산할 유닛들을 순서대로 저장하는 리스트</span>
<span class="comment">// List&lt;UnitSO&gt;: 인덱스 접근이 가능한 동적 배열</span>
<span class="comment">// Queue에서 List로 변경: 특정 인덱스의 항목을 제거할 수 있도록 함</span>
<span class="comment">// System.Collections.Generic.List: C#의 표준 리스트 컬렉션</span>
<span class="keyword">private</span> <span class="class-name">List</span>&lt;<span class="class-name">UnitSO</span>&gt; buildingQueue = <span class="keyword">new</span> <span class="class-name">List</span>&lt;<span class="class-name">UnitSO</span>&gt;(<span class="number">5</span>);

<span class="comment">// 큐 배열 프로퍼티: 외부에서 큐의 복사본을 배열로 제공</span>
<span class="comment">// Expression-bodied property: 큐의 읽기 전용 복사본 제공</span>
<span class="comment">// buildingQueue.ToArray(): 리스트를 배열로 변환하여 반환</span>
<span class="comment">// 캡슐화 유지: 외부에서 큐를 직접 수정할 수 없도록 함</span>
<span class="keyword">public</span> <span class="class-name">UnitSO</span>[] <span class="property-name">Queue</span> => buildingQueue.<span class="method-name">ToArray</span>();

<span class="comment">// 메서드 변경사항:</span>
<span class="comment">// Enqueue() → Add()</span>
<span class="comment">// Peek() → buildingQueue[0]</span>
<span class="comment">// Dequeue() → RemoveAt(0)</span>
<span class="comment">// RemoveAt(index): 특정 인덱스의 항목 제거 (새로운 기능)</span>
</div>
            </div>

            <div class="content-section">
                <h3>❌ CancelBuildingUnit 메서드</h3>
                
                <div class="code-block">
<span class="comment">// BaseBuilding.cs - 유닛 빌드 취소 메서드</span>
<span class="comment">// CancelBuildingUnit: "유닛 빌드를 취소한다"는 의미</span>
<span class="comment">// int index: 취소할 유닛의 큐 내 인덱스</span>
<span class="keyword">public void</span> <span class="method-name">CancelBuildingUnit</span>(<span class="keyword">int</span> index)
{
    <span class="comment">// Guardian Pattern: 인덱스가 유효한 범위 내에 있는지 확인</span>
    <span class="comment">// index &lt; 0: 음수 인덱스 방지</span>
    <span class="comment">// index &gt;= buildingQueue.Count: 큐 크기를 초과하는 인덱스 방지</span>
    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= buildingQueue.<span class="property-name">Count</span>)
    {
        <span class="comment">// 잘못된 인덱스로 인한 에러 로그 출력</span>
        <span class="comment">// Debug.LogError: 콘솔에 빨간색 에러 메시지 출력</span>
        <span class="comment">// 이는 코드의 버그를 나타내는 신호일 수 있음</span>
        <span class="class-name">Debug</span>.<span class="method-name">LogError</span>(<span class="string">"Attempting to cancel building a unit outside the bounds of the queue!"</span>);
        <span class="keyword">return</span>; <span class="comment">// 메서드 조기 종료</span>
    }

    <span class="comment">// 큐에서 해당 인덱스의 유닛 제거</span>
    <span class="comment">// RemoveAt: 리스트에서 특정 인덱스의 항목을 제거</span>
    <span class="comment">// Queue에서는 불가능했던 기능이 List에서는 가능</span>
    buildingQueue.<span class="method-name">RemoveAt</span>(index);

    <span class="comment">// 첫 번째 유닛(인덱스 0)을 취소한 경우 특별 처리</span>
    <span class="comment">// 현재 빌드 중인 유닛을 취소하는 경우</span>
    <span class="keyword">if</span> (index == <span class="number">0</span>)
    {
        <span class="comment">// 현재 실행 중인 모든 코루틴 중지</span>
        <span class="comment">// StopAllCoroutines: 이 MonoBehaviour에서 실행 중인 모든 코루틴 중지</span>
        <span class="comment">// 빌드 진행을 즉시 중단</span>
        <span class="method-name">StopAllCoroutines</span>();

        <span class="comment">// 큐에 아직 유닛이 남아있는 경우</span>
        <span class="keyword">if</span> (buildingQueue.<span class="property-name">Count</span> &gt; <span class="number">0</span>)
        {
            <span class="comment">// 새로운 코루틴 시작하여 남은 유닛들 빌드</span>
            <span class="comment">// StartCoroutine: 새로운 빌드 코루틴 시작</span>
            <span class="comment">// DoBuildUnits: 남은 유닛들을 순서대로 빌드</span>
            <span class="method-name">StartCoroutine</span>(<span class="method-name">DoBuildUnits</span>());
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// 큐가 비어있는 경우 빈 큐로 이벤트 발생</span>
            <span class="comment">// OnQueueUpdated?.Invoke: null 체크 후 이벤트 호출</span>
            <span class="comment">// buildingQueue.ToArray(): 빈 배열을 전달하여 빌드 완료 알림</span>
            OnQueueUpdated?.<span class="method-name">Invoke</span>(buildingQueue.<span class="method-name">ToArray</span>());
        }
    }
    <span class="keyword">else</span>
    {
        <span class="comment">// 첫 번째가 아닌 유닛을 취소한 경우</span>
        <span class="comment">// 현재 빌드 진행에는 영향을 주지 않음</span>
        <span class="comment">// 단순히 큐 업데이트 이벤트만 발생</span>
        OnQueueUpdated?.<span class="method-name">Invoke</span>(buildingQueue.<span class="method-name">ToArray</span>());
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎨 UIBuildQueueButton 컴포넌트</h3>
                
                <div class="code-block">
<span class="comment">// UIBuildQueueButton.cs - 빌드 큐 버튼 컴포넌트</span>
<span class="comment">// UIBuildQueueButton: 빌드 큐에서 특정 유닛을 취소하는 버튼</span>
<span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> UnityEngine.UI;
<span class="keyword">using</span> GameDevTV.RTS.Units;

<span class="keyword">namespace</span> GameDevTV.RTS.UI.Components
{
    <span class="comment">// 빌드 큐에서 유닛을 취소하는 버튼 컴포넌트</span>
    <span class="comment">// UIBuildQueueButton: "UI 빌드 큐 버튼"이라는 의미</span>
    <span class="comment">// MonoBehaviour: Unity 컴포넌트 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">UIBuildQueueButton</span> : <span class="class-name">MonoBehaviour</span>
    {
        <span class="comment">// 버튼 참조</span>
        <span class="comment">// Button: Unity UI 버튼 컴포넌트</span>
        <span class="keyword">private</span> <span class="class-name">Button</span> button;
        
        <span class="comment">// 아이콘 이미지 참조</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 함</span>
        <span class="comment">// Image: Unity UI 이미지 컴포넌트</span>
        [<span class="class-name">SerializeField</span>] <span class="keyword">private</span> <span class="class-name">Image</span> icon;

        <span class="comment">// 컴포넌트 초기화</span>
        <span class="comment">// Awake: GameObject가 생성될 때 한 번만 실행</span>
        <span class="keyword">private void</span> <span class="method-name">Awake</span>()
        {
            <span class="comment">// 버튼 컴포넌트 가져오기</span>
            <span class="comment">// GetComponent: 특정 컴포넌트를 찾는 Unity 메서드</span>
            <span class="comment">// Button: Unity UI 버튼 컴포넌트</span>
            button = <span class="method-name">GetComponent</span>&lt;<span class="class-name">Button</span>&gt;();
            
            <span class="comment">// 기본적으로 비활성화</span>
            <span class="comment">// interactable = false: 버튼을 클릭할 수 없도록 함</span>
            button.<span class="property-name">interactable</span> = <span class="keyword">false</span>;
        }

        <span class="comment">// 버튼 활성화 메서드: 특정 유닛에 대해 버튼을 활성화</span>
        <span class="comment">// EnableFor: "~에 대해 활성화한다"는 의미</span>
        <span class="comment">// UnitSO item: 표시할 유닛 정보</span>
        <span class="comment">// UnityAction callback: 버튼 클릭 시 실행할 콜백</span>
        <span class="keyword">public void</span> <span class="method-name">EnableFor</span>(<span class="class-name">UnitSO</span> item, <span class="class-name">UnityAction</span> callback)
        {
            <span class="comment">// 아이콘 설정</span>
            <span class="comment">// icon.sprite: 이미지 컴포넌트의 스프라이트</span>
            <span class="comment">// item.Icon: 유닛의 아이콘 스프라이트</span>
            icon.<span class="property-name">sprite</span> = item.<span class="property-name">Icon</span>;
            
            <span class="comment">// 아이콘 활성화</span>
            <span class="comment">// SetActive(true): 아이콘 GameObject를 활성화</span>
            icon.<span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">true</span>);
            
            <span class="comment">// 버튼 활성화</span>
            <span class="comment">// interactable = true: 버튼을 클릭할 수 있도록 함</span>
            button.<span class="property-name">interactable</span> = <span class="keyword">true</span>;
            
            <span class="comment">// 클릭 이벤트 추가</span>
            <span class="comment">// AddListener: 버튼 클릭 시 실행할 함수 추가</span>
            <span class="comment">// callback: 취소 기능을 수행하는 함수</span>
            button.<span class="property-name">onClick</span>.<span class="method-name">AddListener</span>(callback);
        }

        <span class="comment">// 버튼 비활성화 메서드</span>
        <span class="comment">// Disable: "비활성화한다"는 의미</span>
        <span class="keyword">public void</span> <span class="method-name">Disable</span>()
        {
            <span class="comment">// 버튼 비활성화</span>
            <span class="comment">// interactable = false: 버튼을 클릭할 수 없도록 함</span>
            button.<span class="property-name">interactable</span> = <span class="keyword">false</span>;
            
            <span class="comment">// 모든 클릭 이벤트 제거</span>
            <span class="comment">// RemoveAllListeners: 모든 이벤트 리스너 제거</span>
            <span class="comment">// 메모리 누수 방지를 위해 반드시 필요</span>
            button.<span class="property-name">onClick</span>.<span class="method-name">RemoveAllListeners</span>();
            
            <span class="comment">// 아이콘 비활성화</span>
            <span class="comment">// SetActive(false): 아이콘 GameObject를 비활성화</span>
            icon.<span class="property-name">gameObject</span>.<span class="method-name">SetActive</span>(<span class="keyword">false</span>);
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎯 핵심 알고리즘</h3>
                
                <div class="code-block">
<span class="comment">// 취소 로직 알고리즘</span>

<span class="comment">// 1. 인덱스 유효성 검사</span>
<span class="comment">// if (index &lt; 0 || index &gt;= buildingQueue.Count)</span>
<span class="comment">// 결과: 잘못된 인덱스로 인한 오류 방지</span>

<span class="comment">// 2. 항목 제거</span>
<span class="comment">// buildingQueue.RemoveAt(index)</span>
<span class="comment">// 결과: 해당 인덱스의 유닛을 큐에서 제거</span>

<span class="comment">// 3. 첫 번째 항목 취소 시 특별 처리</span>
<span class="comment">// if (index == 0)</span>
<span class="comment">// - StopAllCoroutines(): 현재 빌드 중단</span>
<span class="comment">// - if (buildingQueue.Count &gt; 0): 남은 유닛이 있으면 새 코루틴 시작</span>
<span class="comment">// - else: 빈 큐로 이벤트 발생</span>

<span class="comment">// 4. 다른 항목 취소 시</span>
<span class="comment">// - 현재 빌드 진행에는 영향 없음</span>
<span class="comment">// - 단순히 큐 업데이트 이벤트만 발생</span>

<span class="comment">// 결과: 유연하고 안전한 큐 관리</span>
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>🎮 게임플레이 향상</h4>
                    <p><strong>전략적 유연성</strong>: 게임 상황에 따라 빌드 계획 변경</p>
                    <p><strong>사용자 제어권</strong>: 플레이어가 게임을 더 잘 조절</p>
                    <p><strong>자원 효율성</strong>: 불필요한 유닛 생산 중단</p>
                    <p><strong>실수 방지</strong>: 잘못 주문한 유닛 취소 가능</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>데이터 구조 최적화</strong>: Queue에서 List로 변경</p>
                    <p><strong>인덱스 접근</strong>: 특정 위치의 항목 조작 가능</p>
                    <p><strong>코루틴 관리</strong>: 안전한 코루틴 중지 및 재시작</p>
                    <p><strong>이벤트 시스템</strong>: 효율적인 UI 업데이트</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>인덱스 검증</strong>: 잘못된 인덱스로 인한 오류 방지</p>
                    <p><strong>코루틴 관리</strong>: 중지된 코루틴의 안전한 재시작</p>
                    <p><strong>메모리 관리</strong>: 이벤트 리스너 정리</p>
                    <p><strong>UI 동기화</strong>: 큐 변경 시 UI 즉시 업데이트</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>빌드 큐 관리</strong>: Command Post에서 유닛 생산 계획 변경</li>
                    <li><strong>전략적 조정</strong>: 게임 상황에 따른 유닛 생산 우선순위 변경</li>
                    <li><strong>자원 관리</strong>: 불필요한 유닛 생산으로 인한 자원 낭비 방지</li>
                    <li><strong>실시간 대응</strong>: 적의 공격에 따른 긴급 유닛 생산</li>
                    <li><strong>사용자 경험</strong>: 직관적인 UI를 통한 쉬운 큐 관리</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>데이터 구조 선택</strong>: Queue vs List의 장단점</li>
                    <li><strong>인덱스 접근</strong>: 특정 위치 항목의 조작</li>
                    <li><strong>코루틴 관리</strong>: StopAllCoroutines와 재시작</li>
                    <li><strong>Guardian Pattern</strong>: 잘못된 입력 방지</li>
                    <li><strong>이벤트 시스템</strong>: 효율적인 UI 업데이트</li>
                    <li><strong>메모리 관리</strong>: 이벤트 리스너 정리</li>
                    <li><strong>캡슐화</strong>: 내부 데이터 보호</li>
                </ul>
            </div>
        </div>

        <!-- 강의 35: More Buildings & Units (더 많은 건물과 유닛) -->
        <div class="lecture-section" id="lecture-35">
            <h2 class="lecture-title">🏗️ 강의 35: More Buildings & Units (더 많은 건물과 유닛)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">게임 콘텐츠 확장</strong>: <span style="color: #2c3e50;">다양한 건물과 유닛을 추가하여 게임의 깊이 증가</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">ScriptableObject 활용</strong>: <span style="color: #2c3e50;">코드 없이 새로운 유닛과 건물 추가 가능</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">시스템 완성도</strong>: <span style="color: #2c3e50;">기존 시스템이 얼마나 유연하고 확장 가능한지 증명</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">실제 게임 제작</strong>: <span style="color: #2c3e50;">실제 게임에서 사용할 수 있는 완전한 시스템 구축</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🏗️ 더 많은 건물과 유닛이 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">게임에 더 많은 종류의 건물과 유닛을 추가하는 거예요. 마치 레고 블록을 더 많이 모으는 것처럼요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>게임 재미</strong>: 더 많은 선택지가 있어서 게임이 더 재미있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>전략 깊이</strong>: 다양한 유닛으로 더 복잡한 전략을 세울 수 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>시스템 검증</strong>: 만든 시스템이 잘 작동하는지 확인해요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집을 지을 때 필요한 모든 건물들(주택, 학교, 병원, 공장 등)을 준비하는 것과 같아요. 각각 다른 용도가 있어서 도시가 완성돼요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>모든 유닛과 건물의 UnitSO 생성</li>
                    <li>Prefab과 Icon 연결</li>
                    <li>Build Unit Command 생성</li>
                    <li>건물별 유닛 생산 설정</li>
                    <li>ScriptableObject 시스템의 확장성 확인</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🏗️ 추가된 건물과 유닛</h3>
                
                <div class="tech-stack">
                    <h4>🏢 건물 (Buildings)</h4>
                    <ul class="content-list">
                        <li><strong>Airport</strong>: 항공 유닛 생산 (Air Transport)</li>
                        <li><strong>Barracks</strong>: 군사 유닛 생산 (Rifleman, Grenadier)</li>
                        <li><strong>Infantry School</strong>: 보병 훈련 시설</li>
                        <li><strong>Supply Hut</strong>: 자원 저장 시설</li>
                        <li><strong>Command Post</strong>: 기본 건물 (Worker 생산)</li>
                    </ul>
                </div>

                <div class="tech-stack">
                    <h4>⚔️ 유닛 (Units)</h4>
                    <ul class="content-list">
                        <li><strong>Worker</strong>: 자원 수집 유닛</li>
                        <li><strong>Rifleman</strong>: 기본 보병 유닛</li>
                        <li><strong>Grenadier</strong>: 수류탄 투척 유닛</li>
                        <li><strong>Air Transport</strong>: 공중 수송 유닛</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>🔧 UnitSO 설정 과정</h3>
                
                <div class="code-block">
<span class="comment">// UnitSO 설정 과정</span>

<span class="comment">// 1. UnitSO 생성</span>
<span class="comment">// Right Click → Create → Units → Unit</span>
<span class="comment">// 이름: Rifleman, Grenadier, Airport, Barracks, Infantry School</span>

<span class="comment">// 2. 필수 필드 설정</span>
<span class="comment">// - Prefab: 해당 유닛/건물의 프리팹 연결</span>
<span class="comment">// - Icon: 해당 유닛/건물의 아이콘 연결</span>
<span class="comment">// - BuildTime: 빌드 시간 (테스트용으로 짧게 설정)</span>
<span class="comment">// - MaxHealth: 최대 체력</span>

<span class="comment">// 3. 폴더 구조</span>
<span class="comment">// Assets/Units/</span>
<span class="comment">// ├── Buildings/</span>
<span class="comment">// │   ├── Airport/</span>
<span class="comment">// │   │   ├── Airport.asset (UnitSO)</span>
<span class="comment">// │   │   ├── Airport.prefab</span>
<span class="comment">// │   │   └── Airport Icon.png</span>
<span class="comment">// │   ├── Barracks/</span>
<span class="comment">// │   │   ├── Barracks.asset (UnitSO)</span>
<span class="comment">// │   │   ├── Barracks.prefab</span>
<span class="comment">// │   │   └── Barracks Icon.png</span>
<span class="comment">// │   └── ...</span>
<span class="comment">// └── Rifleman/</span>
<span class="comment">//     ├── Rifleman.asset (UnitSO)</span>
<span class="comment">//     ├── Rifleman.prefab</span>
<span class="comment">//     └── Rifleman Icon.png</span>
</div>
            </div>

            <div class="content-section">
                <h3>⚔️ Build Unit Command 생성</h3>
                
                <div class="code-block">
<span class="comment">// Build Unit Command 생성 과정</span>

<span class="comment">// 1. 기존 Build Worker 복사</span>
<span class="comment">// Right Click → Duplicate</span>
<span class="comment">// 이름 변경: Build Rifleman, Build Grenadier, Build Air Transport</span>

<span class="comment">// 2. 각 Command 설정</span>
<span class="comment">// Build Rifleman:</span>
<span class="comment">// - Icon: Rifleman Icon</span>
<span class="comment">// - Unit: Rifleman UnitSO</span>
<span class="comment">// - Slot: 0 (첫 번째 슬롯)</span>

<span class="comment">// Build Grenadier:</span>
<span class="comment">// - Icon: Grenadier Icon</span>
<span class="comment">// - Unit: Grenadier UnitSO</span>
<span class="comment">// - Slot: 1 (두 번째 슬롯)</span>

<span class="comment">// Build Air Transport:</span>
<span class="comment">// - Icon: Air Transport Icon</span>
<span class="comment">// - Unit: Air Transport UnitSO</span>
<span class="comment">// - Slot: 0 (Airport의 첫 번째 슬롯)</span>

<span class="comment">// 3. 건물별 Command 할당</span>
<span class="comment">// Barracks:</span>
<span class="comment">// - Build Rifleman (Slot 0)</span>
<span class="comment">// - Build Grenadier (Slot 1)</span>

<span class="comment">// Airport:</span>
<span class="comment">// - Build Air Transport (Slot 0)</span>

<span class="comment">// Command Post:</span>
<span class="comment">// - Build Worker (Slot 0)</span>
</div>
            </div>

            <div class="content-section">
                <h3>🎯 핵심 개념</h3>
                
                <div class="code-block">
<span class="comment">// ScriptableObject 시스템의 장점</span>

<span class="comment">// 1. 코드 없이 콘텐츠 추가</span>
<span class="comment">// - 새로운 유닛 추가 시 코드 수정 불필요</span>
<span class="comment">// - Unity Editor에서만 설정으로 완료</span>

<span class="comment">// 2. 데이터와 로직 분리</span>
<span class="comment">// - UnitSO: 데이터 (Prefab, Icon, BuildTime 등)</span>
<span class="comment">// - BuildUnitCommand: 로직 (빌드 동작)</span>
<span class="comment">// - BaseBuilding: 시스템 (실제 빌드 처리)</span>

<span class="comment">// 3. 확장성과 유연성</span>
<span class="comment">// - 새로운 건물 타입 추가 용이</span>
<span class="comment">// - 새로운 유닛 타입 추가 용이</span>
<span class="comment">// - 밸런스 조정이 데이터만 수정하면 됨</span>

<span class="comment">// 4. 재사용성</span>
<span class="comment">// - BuildUnitCommand는 모든 유닛에 재사용 가능</span>
<span class="comment">// - BaseBuilding은 모든 건물에 재사용 가능</span>
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>🎮 게임 개발 관점</h4>
                    <p><strong>콘텐츠 확장</strong>: 게임의 깊이와 재미 증가</p>
                    <p><strong>시스템 검증</strong>: 만든 시스템이 실제로 잘 작동하는지 확인</p>
                    <p><strong>확장성 증명</strong>: ScriptableObject 시스템의 유연성 입증</p>
                    <p><strong>실제 게임 제작</strong>: 실제 게임에서 사용할 수 있는 완전한 시스템</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>코드 없이 콘텐츠 추가</strong>: 프로그래머 없이도 새로운 유닛 추가</p>
                    <p><strong>데이터 중심 설계</strong>: 로직과 데이터의 명확한 분리</p>
                    <p><strong>재사용성</strong>: 기존 시스템을 그대로 활용</p>
                    <p><strong>유지보수성</strong>: 밸런스 조정이 데이터만 수정하면 됨</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>일관성 유지</strong>: 모든 UnitSO에 동일한 필드 설정</p>
                    <p><strong>폴더 구조</strong>: 체계적인 파일 관리</p>
                    <p><strong>네이밍 규칙</strong>: 일관된 이름 규칙 사용</p>
                    <p><strong>테스트</strong>: 각 유닛과 건물이 정상 작동하는지 확인</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>다양한 건물</strong>: 각각 다른 용도의 건물들 (군사, 경제, 기술)</li>
                    <li><strong>다양한 유닛</strong>: 각각 다른 역할의 유닛들 (공격, 방어, 수송)</li>
                    <li><strong>전략적 깊이</strong>: 다양한 유닛 조합으로 복잡한 전략 수립</li>
                    <li><strong>확장 가능성</strong>: 새로운 유닛과 건물을 쉽게 추가할 수 있는 시스템</li>
                    <li><strong>밸런스 조정</strong>: 데이터만 수정하여 게임 밸런스 조정</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>ScriptableObject 활용</strong>: 데이터 중심 설계</li>
                    <li><strong>폴더 구조</strong>: 체계적인 파일 관리</li>
                    <li><strong>재사용성</strong>: 기존 시스템의 재활용</li>
                    <li><strong>확장성</strong>: 새로운 콘텐츠 추가의 용이성</li>
                    <li><strong>데이터와 로직 분리</strong>: 유지보수성 향상</li>
                    <li><strong>Unity Editor 활용</strong>: 코드 없이 콘텐츠 제작</li>
                    <li><strong>시스템 검증</strong>: 실제 사용 가능한 시스템 구축</li>
                </ul>
            </div>
        </div>

        <!-- 강의 36: Unity Behavior Tree (유니티 비헤이비어 트리) -->
        <div class="lecture-section" id="lecture-36">
            <h2 class="lecture-title">🌳 강의 36: Unity Behavior Tree (유니티 비헤이비어 트리)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">AI 시스템 도입</strong>: <span style="color: #2c3e50;">Unity Behavior Tree를 사용하여 더 복잡하고 유연한 AI 구현</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드와 로직 분리</strong>: <span style="color: #2c3e50;">비헤이비어 로직을 코드에서 시각적 그래프로 분리</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">확장성 향상</strong>: <span style="color: #2c3e50;">복잡한 AI 행동을 쉽게 설계하고 수정할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">시각적 디버깅</strong>: <span style="color: #2c3e50;">AI 로직을 시각적으로 확인하고 디버깅 가능</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🌳 비헤이비어 트리가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">유닛이 어떻게 행동할지 정하는 "행동 계획서"예요. 마치 로봇에게 "이렇게 해라, 저렇게 해라"라고 미리 정해놓은 규칙표와 같아요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>복잡한 행동</strong>: 유닛이 더 똑똑하게 행동할 수 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>쉬운 수정</strong>: 코드를 몰라도 행동을 바꿀 수 있어요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>시각적 확인</strong>: 유닛이 뭘 하고 있는지 눈으로 볼 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">집안일 로봇에게 "먼저 청소하고, 그 다음에 설거지하고, 마지막에 빨래하기"라고 미리 정해놓은 일정표와 같아요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Unity Behavior Tree 패키지 설치 및 이해</li>
                    <li>Behavior Graph 생성 및 설정</li>
                    <li>Blackboard 개념 이해</li>
                    <li>AbstractUnit에 BehaviorGraphAgent 통합</li>
                    <li>코드 기반 이동을 비헤이비어 트리로 마이그레이션</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🌳 Unity Behavior Tree 개요</h3>
                
                <div class="tech-stack">
                    <h4>🎮 Behavior Tree란?</h4>
                    <p><strong>정의</strong>: AI 행동을 시각적으로 설계하는 그래프 기반 시스템</p>
                    <p><strong>구성요소</strong>: 노드(Node)와 연결선(Edge)으로 구성</p>
                    <p><strong>실행방향</strong>: 위에서 아래로, 왼쪽에서 오른쪽으로 실행</p>
                    <p><strong>Unity 6</strong>: Unity의 첫 번째 공식 비헤이비어 트리 솔루션</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 노드 타입</h4>
                    <ul class="content-list">
                        <li><strong>Control Flow Nodes</strong>: 로직 흐름을 제어하는 노드 (Random, Abort 등)</li>
                        <li><strong>Action Nodes</strong>: 실제 행동을 수행하는 노드 (Move, Attack 등)</li>
                        <li><strong>Condition Nodes</strong>: 조건을 확인하는 노드 (Variable Value Changed 등)</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>📋 Blackboard 개념</h3>
                
                <div class="code-block">
<span class="comment">// Blackboard 개념</span>

<span class="comment">// 1. 정의</span>
<span class="comment">// Blackboard: 비헤이비어 트리와 코드 간의 데이터 공유 공간</span>
<span class="comment">// Animator의 Parameters와 유사한 개념</span>

<span class="comment">// 2. 장점</span>
<span class="comment">// - 코드와 비헤이비어 트리의 분리</span>
<span class="comment">// - 데이터 중심의 통신</span>
<span class="comment">// - 유연한 시스템 설계</span>

<span class="comment">// 3. 사용 예시</span>
<span class="comment">// 코드에서: graphAgent.SetVariableValue("TargetLocation", position)</span>
<span class="comment">// 비헤이비어 트리에서: TargetLocation 변수 사용</span>

<span class="comment">// 4. 변수 명명 규칙</span>
<span class="comment">// - PascalCase 사용 (TargetLocation)</span>
<span class="comment">// - 공백 없이 작성</span>
<span class="comment">// - 코드의 public 필드와 동일한 규칙</span>
</div>
            </div>

            <div class="content-section">
                <h3>🔧 AbstractUnit 통합</h3>
                
                <div class="code-block">
<span class="comment">// AbstractUnit.cs - BehaviorGraphAgent 통합</span>
<span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
<span class="comment">// BehaviorGraphAgent: 비헤이비어 트리와 상호작용하는 컴포넌트</span>

<span class="comment">// RequireComponent: 필요한 컴포넌트 자동 추가</span>
<span class="comment">// NavMeshAgent: 네비게이션 시스템과 상호작용</span>
<span class="comment">// BehaviorGraphAgent: 비헤이비어 트리 시스템과 상호작용</span>
[<span class="class-name">RequireComponent</span>(<span class="keyword">typeof</span>(<span class="class-name">NavMeshAgent</span>), <span class="keyword">typeof</span>(<span class="class-name">BehaviorGraphAgent</span>))]
<span class="keyword">public abstract class</span> <span class="class-name">AbstractUnit</span> : <span class="class-name">MonoBehaviour</span>, <span class="class-name">ISelectable</span>, <span class="class-name">IMoveable</span>
{
    <span class="comment">// NavMeshAgent 참조</span>
    <span class="comment">// NavMeshAgent: Unity의 네비게이션 시스템 컴포넌트</span>
    <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> agent;
    
    <span class="comment">// BehaviorGraphAgent 참조</span>
    <span class="comment">// BehaviorGraphAgent: Unity Behavior Tree 시스템 컴포넌트</span>
    <span class="keyword">private</span> <span class="class-name">BehaviorGraphAgent</span> graphAgent;

    <span class="comment">// 컴포넌트 초기화</span>
    <span class="comment">// Awake: GameObject 생성 시 한 번만 실행</span>
    <span class="keyword">private void</span> <span class="method-name">Awake</span>()
    {
        <span class="comment">// NavMeshAgent 컴포넌트 가져오기</span>
        <span class="comment">// GetComponent: 특정 컴포넌트를 찾는 Unity 메서드</span>
        agent = <span class="method-name">GetComponent</span>&lt;<span class="class-name">NavMeshAgent</span>&gt;();
        
        <span class="comment">// BehaviorGraphAgent 컴포넌트 가져오기</span>
        <span class="comment">// BehaviorGraphAgent: 비헤이비어 트리 실행을 담당</span>
        graphAgent = <span class="method-name">GetComponent</span>&lt;<span class="class-name">BehaviorGraphAgent</span>&gt;();
    }

    <span class="comment">// 유닛 이동 메서드: 비헤이비어 트리를 통한 이동</span>
    <span class="comment">// MoveTo: "~로 이동한다"는 의미</span>
    <span class="comment">// Vector3 position: 이동할 목표 위치</span>
    <span class="keyword">public void</span> <span class="method-name">MoveTo</span>(<span class="class-name">Vector3</span> position)
    {
        <span class="comment">// 기존 방식: 직접 NavMeshAgent 목표 설정</span>
        <span class="comment">// agent.SetDestination(position);</span>
        
        <span class="comment">// 새로운 방식: Blackboard에 목표 위치 설정</span>
        <span class="comment">// SetVariableValue: Blackboard 변수 값 설정</span>
        <span class="comment">// "TargetLocation": Blackboard 변수명 (정확히 일치해야 함)</span>
        <span class="comment">// position: 설정할 값 (Vector3 타입)</span>
        graphAgent.<span class="method-name">SetVariableValue</span>(<span class="string">"TargetLocation"</span>, position);
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🎯 비헤이비어 트리 구조</h3>
                
                <div class="code-block">
<span class="comment">// Worker BT (Behavior Tree) 구조</span>

<span class="comment">// 1. 시작 노드 (Start)</span>
<span class="comment">// - 비헤이비어 트리의 진입점</span>

<span class="comment">// 2. Abort 노드 (조건부 중단)</span>
<span class="comment">// - Variable Value Changed 조건</span>
<span class="comment">// - TargetLocation이 변경되면 현재 행동 중단</span>

<span class="comment">// 3. Move To Location 노드 (이동 액션)</span>
<span class="comment">// - Agent: Self (자기 자신)</span>
<span class="comment">// - Target: TargetLocation (Blackboard 변수)</span>
<span class="comment">// - Speed: 3.5 (이동 속도)</span>

<span class="comment">// 실행 흐름:</span>
<span class="comment">// Start → Abort → Move To Location</span>
<span class="comment">// ↓</span>
<span class="comment">// TargetLocation 변경 시</span>
<span class="comment">// Abort가 트리거되어 새로운 Move To Location 실행</span>
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>🎮 게임 개발 관점</h4>
                    <p><strong>복잡한 AI</strong>: 더 정교하고 지능적인 유닛 행동</p>
                    <p><strong>시각적 설계</strong>: 코드 없이 AI 로직 설계 가능</p>
                    <p><strong>디버깅 용이</strong>: 실행 중인 AI 상태를 시각적으로 확인</p>
                    <p><strong>확장성</strong>: 새로운 행동 패턴을 쉽게 추가</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>코드와 로직 분리</strong>: 비헤이비어 로직을 시각적 그래프로 분리</p>
                    <p><strong>Blackboard 시스템</strong>: 데이터 중심의 유연한 통신</p>
                    <p><strong>재사용성</strong>: 동일한 비헤이비어 트리를 여러 유닛에 적용</p>
                    <p><strong>유지보수성</strong>: 비헤이비어 수정이 코드 변경 없이 가능</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>변수명 정확성</strong>: Blackboard 변수명이 정확히 일치해야 함</p>
                    <p><strong>실행 순서</strong>: 비헤이비어 트리는 순차적으로 실행됨</p>
                    <p><strong>Abort 조건</strong>: 새로운 명령 시 이전 행동 중단 필요</p>
                    <p><strong>성능 고려</strong>: 복잡한 트리는 성능에 영향을 줄 수 있음</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>복잡한 전술</strong>: 다양한 상황에 따른 유닛 행동 패턴</li>
                    <li><strong>자동 전투</strong>: 적을 발견했을 때 자동 공격 행동</li>
                    <li><strong>자원 수집</strong>: Worker의 지능적인 자원 수집 로직</li>
                    <li><strong>편대 비행</strong>: Air Transport의 편대 유지 행동</li>
                    <li><strong>방어 행동</strong>: 건물 공격 시 자동 방어 행동</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>Unity Behavior Tree</strong>: Unity 6의 공식 비헤이비어 트리 시스템</li>
                    <li><strong>BehaviorGraphAgent</strong>: 비헤이비어 트리 실행 컴포넌트</li>
                    <li><strong>Blackboard</strong>: 데이터 공유 공간</li>
                    <li><strong>Control Flow Nodes</strong>: 로직 흐름 제어</li>
                    <li><strong>Action Nodes</strong>: 실제 행동 수행</li>
                    <li><strong>Abort 조건</strong>: 행동 중단 및 재시작</li>
                    <li><strong>SetVariableValue</strong>: Blackboard 변수 설정</li>
                </ul>
            </div>
        </div>

        <!-- 강의 37: Custom Behavior Nodes (커스텀 비헤이비어 노드) -->
        <div class="lecture-section" id="lecture-37">
            <h2 class="lecture-title">🔧 강의 37: Custom Behavior Nodes (커스텀 비헤이비어 노드)</h2>
            
            <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">커스텀 노드 생성</strong>: <span style="color: #2c3e50;">Unity Behavior Tree에서 기본 노드 대신 커스텀 노드 사용</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">NavMeshAgent 보호</strong>: <span style="color: #2c3e50;">런타임에 NavMeshAgent 설정이 덮어씌워지는 문제 해결</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">세밀한 제어</strong>: <span style="color: #2c3e50;">이동 로직을 더 정교하게 제어할 수 있도록</span></p>
                <p style="margin: 8px 0;"><strong style="color: #2c3e50;">확장성 향상</strong>: <span style="color: #2c3e50;">나만의 비헤이비어 노드를 만들어 복잡한 AI 구현</span></p>
            </div>
            
            <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                <p style="margin: 8px 0; color: #155724;"><strong>🔧 커스텀 노드가 뭐야?</strong></p>
                <p style="margin: 8px 0; color: #155724;">Unity에서 제공하는 기본 노드 대신, 우리가 직접 만든 "맞춤형 행동 노드"예요. 마치 레고 블록을 직접 만드는 것과 같아요!</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🎯 왜 필요한가요?</strong></p>
                <p style="margin: 8px 0; color: #155724;">• <strong>문제 해결</strong>: 기본 노드가 우리 설정을 망가뜨리는 문제를 해결해요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>정확한 제어</strong>: 유닛이 정확히 우리가 원하는 대로 움직여요</p>
                <p style="margin: 8px 0; color: #155724;">• <strong>맞춤형 기능</strong>: 우리 게임에 딱 맞는 특별한 행동을 만들 수 있어요</p>
                
                <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                <p style="margin: 8px 0; color: #155724;">기성품 청소기 대신 우리 집에 딱 맞는 맞춤형 청소기를 만드는 것과 같아요!</p>
            </div>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Unity Behavior Tree에서 커스텀 노드 생성 방법</li>
                    <li>NodeDescription 어트리뷰트 이해</li>
                    <li>Action 클래스 상속 및 구현</li>
                    <li>Status 시스템 이해 (Running, Success, Failure)</li>
                    <li>NavMeshAgent 설정 보호 방법</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔧 커스텀 노드 생성 과정</h3>
                
                <div class="tech-stack">
                    <h4>🎮 Unity Editor에서 노드 생성</h4>
                    <ol class="content-list">
                        <li><strong>Space 키</strong>: 비헤이비어 그래프에서 노드 추가 메뉴 열기</li>
                        <li><strong>Actions → Create New Action</strong>: 새로운 액션 노드 생성</li>
                        <li><strong>이름 설정</strong>: "Move to Target Location"</li>
                        <li><strong>카테고리</strong>: "Action/Navigation"</li>
                        <li><strong>설명 작성</strong>: "[Agent] moves to [TargetLocation]"</li>
                    </ol>
                </div>

                <div class="tech-stack">
                    <h4>🤖 AI 기반 코드 생성</h4>
                    <p><strong>자동 분류</strong>: Unity가 자연어 설명을 분석하여 변수 타입 자동 결정</p>
                    <p><strong>Blackboard 연동</strong>: 대괄호로 감싼 변수명이 자동으로 Blackboard와 연결</p>
                    <p><strong>보일러플레이트 코드</strong>: 기본적인 클래스 구조와 어트리뷰트 자동 생성</p>
                </div>
            </div>

            <div class="content-section">
                <h3>📝 생성된 커스텀 노드 코드</h3>
                
                <div class="code-block">
<span class="comment">// MoveToTargetLocationAction.cs - 커스텀 이동 노드</span>
<span class="comment">// Unity Behavior Tree의 Action 클래스를 상속받아 커스텀 노드 구현</span>

<span class="comment">// 네임스페이스: GameDevTV.RTS.Behavior</span>
<span class="comment">// Behavior 폴더에 위치하여 비헤이비어 관련 클래스들을 그룹화</span>
<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 설정</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior 내부 시스템을 위한 어트리뷰트</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: 비헤이비어 트리 에디터에서 노드 정보 표시</span>
    <span class="comment">// name: 노드 이름 (에디터에서 표시)</span>
    <span class="comment">// story: 노드 설명 (자연어로 작성)</span>
    <span class="comment">// category: 노드 카테고리 (메뉴 구조)</span>
    <span class="comment">// id: 고유 식별자 (Unity Behavior 내부 사용)</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Move to Target Location"</span>, 
                     <span class="parameter">story</span>: <span class="string">"[Agent] moves to [TargetLocation] ."</span>, 
                     <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, 
                     <span class="parameter">id</span>: <span class="string">"c96373f56a4b683d189e362795d042fa"</span>)]
    
    <span class="comment">// partial class: 클래스가 여러 파일에 나뉘어 정의될 수 있음</span>
    <span class="comment">// Unity Behavior가 자동으로 추가 코드를 생성할 수 있도록 함</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetLocationAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// SerializeReference: Blackboard 변수를 인스펙터에서 설정 가능하도록</span>
        <span class="comment">// BlackboardVariable&lt;T&gt;: Blackboard의 특정 타입 변수 참조</span>
        <span class="comment">// Agent: 이동할 유닛 (GameObject 타입)</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="field-name">Agent</span>;
        
        <span class="comment">// TargetLocation: 이동할 목표 위치 (Vector3 타입)</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">Vector3</span>&gt; <span class="field-name">TargetLocation</span>;

        <span class="comment">// NavMeshAgent 참조</span>
        <span class="comment">// 실제 이동을 담당하는 Unity 컴포넌트</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>;

        <span class="comment">// OnStart: 노드가 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status 반환: Running, Success, Failure 중 하나</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// Agent GameObject에서 NavMeshAgent 컴포넌트 가져오기</span>
            <span class="comment">// TryGetComponent: 컴포넌트가 있으면 true, 없으면 false 반환</span>
            <span class="comment">// out agent: 컴포넌트를 agent 변수에 저장</span>
            <span class="keyword">if</span> (!<span class="field-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// NavMeshAgent가 없으면 실패 반환</span>
                <span class="comment">// 이 노드는 더 이상 실행되지 않음</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// 이미 목표 위치에 있는지 확인</span>
            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.stoppingDistance: NavMeshAgent의 정지 거리</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.<span class="method-name">Distance</span>(<span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, <span class="field-name">TargetLocation</span>.<span class="property-name">Value</span>) &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// 이미 목표 위치에 있으면 성공 반환</span>
                <span class="comment">// OnUpdate는 호출되지 않음</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// 목표 위치로 이동 시작</span>
            <span class="comment">// SetDestination: NavMeshAgent에게 목표 위치 설정</span>
            <span class="field-name">agent</span>.<span class="method-name">SetDestination</span>(<span class="field-name">TargetLocation</span>.<span class="property-name">Value</span>);

            <span class="comment">// 실행 중 상태 반환</span>
            <span class="comment">// OnUpdate가 계속 호출됨</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 노드가 실행 중일 때 매 프레임 호출</span>
        <span class="comment">// 이동 상태를 확인하고 적절한 Status 반환</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// 목표 위치에 도달했는지 확인</span>
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="keyword">if</span> (<span class="field-name">agent</span>.<span class="property-name">remainingDistance</span> &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// 목표에 도달했으면 성공 반환</span>
                <span class="comment">// 이 노드의 실행이 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// 아직 이동 중이면 계속 실행</span>
            <span class="comment">// 다음 프레임에 다시 OnUpdate 호출</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }
    }
}
</div>
            </div>

            <div class="content-section">
                <h3>🔄 Status 시스템 이해</h3>
                
                <div class="tech-stack">
                    <h4>📊 Status 종류</h4>
                    <ul class="content-list">
                        <li><strong>Running</strong>: 노드가 실행 중 (OnUpdate 계속 호출)</li>
                        <li><strong>Success</strong>: 노드가 성공적으로 완료됨</li>
                        <li><strong>Failure</strong>: 노드가 실패함 (다음 노드로 진행 안됨)</li>
                        <li><strong>Waiting</strong>: 대기 상태 (이 강의에서는 사용 안함)</li>
                    </ul>
                </div>

                <div class="tech-stack">
                    <h4>🎯 실행 흐름</h4>
                    <ol class="content-list">
                        <li><strong>OnStart</strong>: 노드 시작 시 한 번만 호출</li>
                        <li><strong>Status.Running</strong> 반환 시 → <strong>OnUpdate</strong> 계속 호출</li>
                        <li><strong>Status.Success</strong> 반환 시 → 다음 노드로 진행</li>
                        <li><strong>Status.Failure</strong> 반환 시 → 노드 실행 중단</li>
                    </ol>
                </div>
            </div>

            <div class="content-section">
                <h3>🔧 AbstractUnit 개선</h3>
                
                <div class="code-block">
<span class="comment">// AbstractUnit.cs - 초기 위치 설정 추가</span>
<span class="comment">// 유닛이 생성될 때 원점(0,0,0)으로 이동하는 문제 해결</span>

<span class="keyword">protected virtual void</span> <span class="method-name">Awake</span>()
{
    <span class="comment">// 컴포넌트 초기화</span>
    <span class="field-name">agent</span> = <span class="method-name">GetComponent</span>&lt;<span class="class-name">NavMeshAgent</span>&gt;();
    <span class="field-name">graphAgent</span> = <span class="method-name">GetComponent</span>&lt;<span class="class-name">BehaviorGraphAgent</span>&gt;();
    
    <span class="comment">// 현재 위치로 이동 설정</span>
    <span class="comment">// 유닛이 생성되자마자 원점으로 이동하는 문제 방지</span>
    <span class="method-name">MoveTo</span>(<span class="property-name">transform</span>.<span class="property-name">position</span>);
}

<span class="keyword">protected override void</span> <span class="method-name">Start</span>()
{
    <span class="comment">// 부모 클래스의 Start 메서드 호출</span>
    <span class="keyword">base</span>.<span class="method-name">Start</span>();
    
    <span class="comment">// 유닛 스폰 이벤트 발생</span>
    <span class="class-name">Bus</span>&lt;<span class="class-name">UnitSpawnEvent</span>&gt;.<span class="method-name">Raise</span>(<span class="keyword">new</span> <span class="class-name">UnitSpawnEvent</span>(<span class="keyword">this</span>));
    
    <span class="comment">// 런타임에 스폰된 유닛도 현재 위치로 이동 설정</span>
    <span class="comment">// 건물에서 생성된 유닛이 올바른 위치에 머물도록</span>
    <span class="method-name">MoveTo</span>(<span class="property-name">transform</span>.<span class="property-name">position</span>);
}
</div>
            </div>

            <div class="content-section">
                <h3>❓ 왜 필요한가?</h3>
                
                <div class="tech-stack">
                    <h4>🎮 게임 개발 관점</h4>
                    <p><strong>NavMeshAgent 보호</strong>: 기본 노드가 런타임에 설정을 덮어씌우는 문제 해결</p>
                    <p><strong>정확한 제어</strong>: 유닛의 이동 속도, 정지 거리 등을 정확히 제어</p>
                    <p><strong>성능 최적화</strong>: 불필요한 설정 변경 방지</p>
                    <p><strong>디버깅 용이</strong>: 커스텀 로직으로 문제 원인 파악 쉬움</p>
                </div>

                <div class="tech-stack">
                    <h4>🔧 기술적 장점</h4>
                    <p><strong>세밀한 제어</strong>: 이동 로직의 모든 부분을 직접 제어 가능</p>
                    <p><strong>확장성</strong>: 복잡한 이동 패턴을 쉽게 추가</p>
                    <p><strong>재사용성</strong>: 다른 유닛 타입에도 동일한 노드 사용 가능</p>
                    <p><strong>유지보수성</strong>: 이동 관련 버그 수정이 용이</p>
                </div>

                <div class="tech-stack">
                    <h4>⚠️ 주의사항</h4>
                    <p><strong>Status 관리</strong>: 올바른 Status 반환이 중요</p>
                    <p><strong>성능 고려</strong>: OnUpdate에서 무거운 연산 피하기</p>
                    <p><strong>에러 처리</strong>: NavMeshAgent가 없는 경우 처리</p>
                    <p><strong>경로 계산</strong>: SetDestination 후 즉시 remainingDistance 확인 주의</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>복잡한 이동 패턴</strong>: 지형을 고려한 스마트한 이동</li>
                    <li><strong>편대 비행</strong>: Air Transport의 편대 유지 이동</li>
                    <li><strong>자원 수집</strong>: Worker의 효율적인 자원 수집 경로</li>
                    <li><strong>전투 이동</strong>: 적을 피하면서 이동하는 전술적 이동</li>
                    <li><strong>건물 회피</strong>: 건물을 피해서 이동하는 지능적 경로</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🔑 핵심 기술 개념</h3>
                <ul class="content-list">
                    <li><strong>Custom Action Node</strong>: Unity Behavior Tree의 커스텀 액션 노드</li>
                    <li><strong>NodeDescription</strong>: 노드 메타데이터 정의</li>
                    <li><strong>BlackboardVariable</strong>: Blackboard 변수 참조</li>
                    <li><strong>Status System</strong>: Running, Success, Failure 상태 관리</li>
                    <li><strong>OnStart/OnUpdate</strong>: 노드 생명주기 메서드</li>
                    <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                    <li><strong>NavMeshAgent 보호</strong>: 런타임 설정 덮어쓰기 방지</li>
                </ul>
            </div>
        </div>

    </div>
</body>
</html>
