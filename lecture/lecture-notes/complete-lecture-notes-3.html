<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URTS 강의 노트 - 3페이지</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .lecture-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }
        
        .lecture-title {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.8em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .lecture-goal {
            background: #e8f4fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .lecture-goal h3 {
            color: #2980b9;
            margin-top: 0;
        }
        
        .content-section {
            margin: 25px 0;
        }
        
        .content-section h3 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        
        .tech-stack {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #17a2b8;
        }
        
        .tech-stack h4 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .content-list {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .content-list li {
            margin: 8px 0;
            color: #2c3e50;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre;
        }
        
        .code-block .comment {
            color: #95a5a6;
            font-style: italic;
        }
        
        .code-block .keyword {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .code-block .class-name {
            color: #3498db;
            font-weight: bold;
        }
        
        .code-block .method-name {
            color: #f39c12;
            font-weight: bold;
        }
        
        .code-block .property-name {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .code-block .field-name {
            color: #9b59b6;
        }
        
        .code-block .string {
            color: #e67e22;
        }
        
        .code-block .number {
            color: #e67e22;
        }
        
        .code-block .parameter {
            color: #f39c12;
        }
        
        .info-box {
            background: #e8f5e8;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .info-box h4 {
            color: #27ae60;
            margin-top: 0;
        }
        
        .warning-box {
            background: #fdf2e9;
            border: 2px solid #e67e22;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .warning-box h4 {
            color: #e67e22;
            margin-top: 0;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .toc ul {
            list-style: none;
            padding: 0;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        
        .toc a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 URTS 강의 노트</h1>
            <p>Unity RTS 게임 개발 강의 정리 - 3페이지</p>
        </div>
        
        <div class="content">
            <!-- 목차 -->
            <div class="toc">
                <h3>📚 목차</h3>
                <ul>
                    <li><a href="#lecture-39">🎯 강의 39: Unit Commands in Behavior Tree</a></li>
                    <li><a href="#lecture-40">⛏️ 강의 40: Gathering Supplies with Behavior Tree</a></li>
                    <li><a href="#lecture-41">🏠 강의 41: Return Supplies to Command Post</a></li>
                    <li><a href="#lecture-42">🚶 강의 42: Smooth Gathering Movement</a></li>
                    <li><a href="#lecture-43">🎯 강의 43: Pick Better Gathering Locations</a></li>
                </ul>
            </div>

            <!-- 강의 39: Unit Commands in Behavior Tree (Behavior Tree에서 유닛 명령) -->
            <div class="lecture-section" id="lecture-39">
                <h2 class="lecture-title">🎯 강의 39: Unit Commands in Behavior Tree (Behavior Tree에서 유닛 명령)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">명령 체계 구축</strong>: <span style="color: #2c3e50;">유닛의 다양한 행동을 체계적으로 관리할 수 있는 명령 시스템</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">확장성 향상</strong>: <span style="color: #2c3e50;">새로운 유닛 기능을 쉽게 추가할 수 있는 구조</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">반응성 개선</strong>: <span style="color: #2c3e50;">명령 변경 시 즉시 반응하는 유닛 시스템</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드 분리</strong>: <span style="color: #2c3e50;">Behavior Tree와 명령 로직의 명확한 분리</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🎯 명령이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">게임에서 유닛에게 "이동해!", "멈춰!", "공격해!" 같은 지시를 내리는 시스템이에요. 마치 리모컨으로 TV를 조작하는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 왜 필요한가요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>다양한 행동</strong>: 유닛이 할 수 있는 여러 가지 행동을 관리해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>즉시 반응</strong>: 새로운 명령을 내리면 바로 행동을 바꿔요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>체계적 관리</strong>: 모든 명령을 하나의 시스템으로 관리해요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">집에서 "TV 켜줘!", "라디오 꺼줘!" 같은 명령을 내리는 것처럼, 게임에서도 유닛에게 명령을 내려요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>UnitCommands 열거형 생성 및 설정</li>
                        <li>Behavior Tree에서 Switch 노드 활용</li>
                        <li>StopAgentAction 커스텀 노드 구현</li>
                        <li>StopCommand 액션 베이스 구현</li>
                        <li>명령 변경 시 즉시 반응하는 시스템</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🎯 명령 체계 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>UnitCommands</strong>: 유닛 명령 열거형 (Stop, Move)</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기 처리</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>StopAgentAction</strong>: 유닛 정지 커스텀 노드</li>
                            <li><strong>StopCommand</strong>: 정지 명령 액션 베이스</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 명령 처리 플로우</h4>
                        <ol class="content-list">
                            <li><strong>명령 설정</strong>: Blackboard에 명령 값 설정</li>
                            <li><strong>Abort 트리거</strong>: 명령 변경 시 현재 실행 중단</li>
                            <li><strong>Switch 분기</strong>: 명령에 따라 다른 브랜치 실행</li>
                            <li><strong>액션 실행</strong>: 해당 명령의 행동 수행</li>
                            <li><strong>상태 관리</strong>: 명령 완료 또는 대기</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 UnitCommands 열거형</h3>
                    
                    <div class="code-block">
<span class="comment">// UnitCommands.cs - 유닛 명령 열거형</span>
<span class="comment">// BlackboardEnum: Unity Behavior Tree에서 사용할 수 있는 열거형</span>

<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// BlackboardEnum: Unity Behavior Tree의 Blackboard에서 사용할 수 있도록 하는 속성</span>
    <span class="comment">// 이 속성이 있으면 Behavior Tree 에디터에서 이 열거형을 선택할 수 있음</span>
    [<span class="class-name">BlackboardEnum</span>]
    
    <span class="comment">// UnitCommands: 유닛이 수행할 수 있는 명령들의 열거형</span>
    <span class="comment">// enum: 상수들의 집합을 정의하는 C# 키워드</span>
    <span class="keyword">public enum</span> <span class="class-name">UnitCommands</span>
    {
        <span class="comment">// Stop: 유닛을 정지시키는 명령</span>
        <span class="comment">// 첫 번째 값이므로 기본값은 0</span>
        <span class="property-name">Stop</span>,
        
        <span class="comment">// Move: 유닛을 이동시키는 명령</span>
        <span class="comment">// 두 번째 값이므로 기본값은 1</span>
        <span class="property-name">Move</span>
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🛑 StopAgentAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// StopAgentAction.cs - 유닛 정지 액션 노드</span>
<span class="comment">// Unity Behavior Tree의 커스텀 액션 노드</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트 (Agent는 Blackboard 변수)</span>
    <span class="comment">// category: 노드가 속할 카테고리</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Stop Agent"</span>, <span class="parameter">story</span>: <span class="string">"[Agent] stops moving."</span>, <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, <span class="parameter">id</span>: <span class="string">"b4af498b0656fc524515ec0b094c06a9"</span>)]
    
    <span class="comment">// StopAgentAction: 유닛을 정지시키는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">StopAgentAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 정지시킬 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// Agent.Value: Blackboard에서 가져온 GameObject</span>
            <span class="comment">// TryGetComponent: 해당 GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 agent 변수에 저장</span>
            <span class="keyword">if</span> (<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// ResetPath: NavMeshAgent의 현재 경로를 초기화하고 정지</span>
                <span class="comment">// 이동 중이던 유닛을 즉시 정지시킴</span>
                <span class="field-name">agent</span>.<span class="method-name">ResetPath</span>();
                
                <span class="comment">// Success: 액션이 성공적으로 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Failure: NavMeshAgent를 찾을 수 없어서 액션 실패</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 StopCommand 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// StopCommand.cs - 정지 명령 액션 베이스</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Commands</span>
{
    <span class="comment">// CreateAssetMenu: Unity Editor에서 이 클래스로부터 ScriptableObject를 생성할 수 있게 함</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: Unity Editor 메뉴에서의 경로</span>
    <span class="comment">// order: 메뉴에서의 순서 (낮을수록 위에 표시)</span>
    [<span class="class-name">CreateAssetMenu</span>(<span class="parameter">fileName</span> = <span class="string">"Stop Action"</span>, <span class="parameter">menuName</span> = <span class="string">"AI/Commands/Stop"</span>, <span class="parameter">order</span> = <span class="number">101</span>)]
    
    <span class="comment">// StopCommand: 유닛을 정지시키는 명령</span>
    <span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">StopCommand</span> : <span class="class-name">ActionBase</span>
    {
        <span class="comment">// CanHandle: 이 명령을 처리할 수 있는지 확인</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="comment">// 반환값: 이 명령을 처리할 수 있으면 true, 아니면 false</span>
        <span class="keyword">public override bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// context.Commandable: 명령을 받을 수 있는 객체</span>
            <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
            <span class="comment">// is: 타입 확인 연산자</span>
            <span class="keyword">return</span> <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">is</span> <span class="class-name">AbstractUnit</span>;
        }

        <span class="comment">// Handle: 실제 명령을 처리하는 메서드</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// AbstractUnit으로 타입 캐스팅</span>
            <span class="comment">// CanHandle에서 이미 AbstractUnit인지 확인했으므로 안전한 캐스팅</span>
            <span class="class-name">AbstractUnit</span> <span class="field-name">unit</span> = (<span class="class-name">AbstractUnit</span>)<span class="field-name">context</span>.<span class="property-name">Commandable</span>;
            
            <span class="comment">// unit.Stop(): 유닛의 정지 메서드 호출</span>
            <span class="comment">// 이 메서드는 Blackboard에 Stop 명령을 설정함</span>
            <span class="field-name">unit</span>.<span class="method-name">Stop</span>();
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔄 Behavior Tree 구조</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Stop 브랜치</strong>: StopAgentAction 실행</li>
                            <li><strong>Move 브랜치</strong>: MoveToTargetLocationAction 실행</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 즉시 반응 시스템</h4>
                        <ul class="content-list">
                            <li><strong>명령 변경 감지</strong>: Abort 노드가 명령 변경을 감지</li>
                            <li><strong>현재 실행 중단</strong>: 진행 중인 액션을 즉시 중단</li>
                            <li><strong>새 명령 실행</strong>: 변경된 명령에 따라 새로운 액션 시작</li>
                            <li><strong>상태 초기화</strong>: 이전 상태를 정리하고 새 상태로 전환</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>명령 체계</strong>: 유닛의 다양한 행동을 체계적으로 관리</p>
                        <p><strong>반응성</strong>: 플레이어 명령에 즉시 반응하는 유닛</p>
                        <p><strong>확장성</strong>: 새로운 유닛 기능을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 유닛이 동일한 명령 체계 사용</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>열거형 활용</strong>: 명령을 타입 안전하게 관리</p>
                        <p><strong>Switch 노드</strong>: 명령에 따른 분기 처리</p>
                        <p><strong>Abort 시스템</strong>: 명령 변경 시 즉시 반응</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>명령 순서</strong>: Blackboard 값 설정 후 명령 설정</p>
                        <p><strong>네임스페이스</strong>: 열거형 생성 후 네임스페이스 이동</p>
                        <p><strong>노드 연결</strong>: Behavior Tree에서 올바른 연결 확인</p>
                        <p><strong>상태 관리</strong>: 명령 변경 시 이전 상태 정리</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 명령</strong>: 이동, 정지, 공격, 수집, 건설 등</li>
                        <li><strong>명령 우선순위</strong>: 긴급 명령이 일반 명령보다 우선</li>
                        <li><strong>명령 취소</strong>: 진행 중인 명령을 취소할 수 있는 기능</li>
                        <li><strong>명령 대기열</strong>: 여러 명령을 순서대로 실행</li>
                        <li><strong>조건부 명령</strong>: 특정 조건에서만 실행되는 명령</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>UnitCommands</strong>: 유닛 명령 열거형</li>
                        <li><strong>BlackboardEnum</strong>: Behavior Tree에서 사용 가능한 열거형</li>
                        <li><strong>Switch 노드</strong>: 명령에 따른 분기 처리</li>
                        <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                        <li><strong>StopAgentAction</strong>: 유닛 정지 커스텀 노드</li>
                        <li><strong>StopCommand</strong>: 정지 명령 액션 베이스</li>
                        <li><strong>ResetPath</strong>: NavMeshAgent 경로 초기화</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 40: Gathering Supplies with Behavior Tree (Behavior Tree로 자원 수집) -->
            <div class="lecture-section" id="lecture-40">
                <h2 class="lecture-title">⛏️ 강의 40: Gathering Supplies with Behavior Tree (Behavior Tree로 자원 수집)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자원 수집 구현</strong>: <span style="color: #2c3e50;">Worker가 Behavior Tree를 사용해서 자원을 수집하는 시스템 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">명령 확장</strong>: <span style="color: #2c3e50;">기존 명령 체계에 Gather 명령 추가</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">커스텀 노드</strong>: <span style="color: #2c3e50;">자원 수집을 위한 전용 Behavior Tree 노드 생성</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">레이어 시스템</strong>: <span style="color: #2c3e50;">자원과 상호작용할 수 있는 레이어 설정</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>⛏️ 자원 수집이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker가 미네랄이나 가스에 가서 캐는 시스템이에요. 마치 광부가 광산에서 광물을 캐는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>명령 내리기</strong>: Worker에게 "자원 캐!" 명령을 내려요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>이동하기</strong>: Worker가 자원 위치로 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>수집하기</strong>: 자원을 캐서 가져와요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>반복하기</strong>: 자원이 남아있으면 계속 캐요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">집에서 "장보기 가!"라고 하면 가게에 가서 필요한 것들을 사는 것처럼, 게임에서도 Worker가 자원을 캐러 가요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>UnitCommands에 Gather 명령 추가</li>
                        <li>GatherCommand 액션 베이스 구현</li>
                        <li>GatherSuppliesAction 커스텀 노드 생성</li>
                        <li>Worker 클래스에 Gather 메서드 추가</li>
                        <li>Supplies 레이어 설정 및 상호작용 시스템</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>⛏️ 자원 수집 시스템 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>Gather 명령</strong>: UnitCommands 열거형에 추가</li>
                            <li><strong>GatherCommand</strong>: 자원 수집 명령 액션 베이스</li>
                            <li><strong>GatherSuppliesAction</strong>: 자원 수집 Behavior Tree 노드</li>
                            <li><strong>Worker.Gather()</strong>: Worker의 자원 수집 메서드</li>
                            <li><strong>Supplies 레이어</strong>: 자원과 상호작용할 수 있는 레이어</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 자원 수집 플로우</h4>
                        <ol class="content-list">
                            <li><strong>명령 내리기</strong>: Gather 버튼 클릭 후 자원 클릭</li>
                            <li><strong>이동</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 시작</strong>: BeginGather() 호출</li>
                            <li><strong>수집 대기</strong>: BaseGatherTime만큼 대기</li>
                            <li><strong>수집 완료</strong>: EndGather() 호출하여 자원 획득</li>
                            <li><strong>반복</strong>: 자원이 남아있으면 다시 수집</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 GatherCommand 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherCommand.cs - 자원 수집 명령 액션 베이스</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Commands</span>
{
    <span class="comment">// CreateAssetMenu: Unity Editor에서 이 클래스로부터 ScriptableObject를 생성할 수 있게 함</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: Unity Editor 메뉴에서의 경로</span>
    <span class="comment">// order: 메뉴에서의 순서 (낮을수록 위에 표시)</span>
    [<span class="class-name">CreateAssetMenu</span>(<span class="parameter">fileName</span> = <span class="string">"Gather Action"</span>, <span class="parameter">menuName</span> = <span class="string">"AI/Commands/Gather"</span>, <span class="parameter">order</span> = <span class="number">105</span>)]
    
    <span class="comment">// GatherCommand: 자원을 수집하는 명령</span>
    <span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">GatherCommand</span> : <span class="class-name">ActionBase</span>
    {
        <span class="comment">// CanHandle: 이 명령을 처리할 수 있는지 확인</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="comment">// 반환값: 이 명령을 처리할 수 있으면 true, 아니면 false</span>
        <span class="keyword">public override bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// context.Commandable: 명령을 받을 수 있는 객체</span>
            <span class="comment">// Worker: 자원을 수집할 수 있는 유닛</span>
            <span class="comment">// is: 타입 확인 연산자</span>
            <span class="keyword">return</span> <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">is</span> <span class="class-name">Worker</span> 
                <span class="comment">// context.Hit.collider: 클릭한 객체의 Collider</span>
                <span class="comment">// null이 아니어야 함 (뭔가를 클릭했는지 확인)</span>
                &amp;&amp; <span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span> != <span class="keyword">null</span> 
                <span class="comment">// TryGetComponent: 해당 객체에서 GatherableSupply 컴포넌트를 가져옴</span>
                <span class="comment">// out _: discard 패턴, 값을 받지만 사용하지 않음</span>
                &amp;&amp; <span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">GatherableSupply</span> <span class="keyword">_</span>);
        }

        <span class="comment">// Handle: 실제 명령을 처리하는 메서드</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// Worker로 타입 캐스팅</span>
            <span class="comment">// CanHandle에서 이미 Worker인지 확인했으므로 안전한 캐스팅</span>
            <span class="class-name">Worker</span> <span class="field-name">worker</span> = <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">as</span> <span class="class-name">Worker</span>;
            
            <span class="comment">// worker.Gather(): Worker의 자원 수집 메서드 호출</span>
            <span class="comment">// context.Hit.collider.GetComponent: 클릭한 객체에서 GatherableSupply 컴포넌트 가져오기</span>
            <span class="field-name">worker</span>.<span class="method-name">Gather</span>(<span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span>.<span class="method-name">GetComponent</span>&lt;<span class="class-name">GatherableSupply</span>&gt;());
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🏗️ GatherSuppliesAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherSuppliesAction.cs - 자원 수집 액션 노드</span>
<span class="comment">// Unity Behavior Tree의 커스텀 액션 노드</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (새로운 커스텀 카테고리)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Gather Supplies"</span>, <span class="parameter">story</span>: <span class="string">"[Unit] gathers [Amount] supplies from [GatherableSupplies] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Units"</span>, <span class="parameter">id</span>: <span class="string">"3b941d7ae99d1e36b7d806875379c977"</span>)]
    
    <span class="comment">// GatherSuppliesAction: 자원을 수집하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">GatherSuppliesAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Unit: 자원을 수집할 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Unit</span>;
        
        <span class="comment">// Amount: 수집할 자원의 양</span>
        <span class="comment">// int: 정수형 (자원은 정수 단위로 관리)</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; <span class="property-name">Amount</span>;
        
        <span class="comment">// GatherableSupplies: 수집할 자원 객체</span>
        <span class="comment">// GatherableSupply: 수집 가능한 자원의 타입</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GatherableSupply</span>&gt; <span class="property-name">GatherableSupplies</span>;

        <span class="comment">// enterTime: 자원 수집을 시작한 시간</span>
        <span class="comment">// Time.time과 비교하여 수집 시간을 계산</span>
        <span class="keyword">private float</span> <span class="field-name">enterTime</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// enterTime을 현재 시간으로 설정</span>
            <span class="comment">// Time.time: 게임 시작 후 경과된 시간 (초 단위)</span>
            <span class="field-name">enterTime</span> = <span class="class-name">Time</span>.<span class="property-name">time</span>;

            <span class="comment">// GatherableSupplies.Value: Blackboard에서 가져온 자원 객체</span>
            <span class="comment">// BeginGather(): 자원 수집을 시작하고 Busy 상태로 변경</span>
            <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">BeginGather</span>();
            
            <span class="comment">// Running: 아직 수집이 완료되지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 주기적으로 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// 수집 시간이 완료되었는지 확인</span>
            <span class="comment">// GatherableSupplies.Value.Supply.BaseGatherTime: 자원의 기본 수집 시간</span>
            <span class="comment">// enterTime: 수집을 시작한 시간</span>
            <span class="comment">// Time.time: 현재 시간</span>
            <span class="comment">// 수집 시간 + 시작 시간이 현재 시간보다 작거나 같으면 수집 완료</span>
            <span class="keyword">if</span> (<span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="property-name">Supply</span>.<span class="property-name">BaseGatherTime</span> + <span class="field-name">enterTime</span> &lt;= <span class="class-name">Time</span>.<span class="property-name">time</span>)
            {
                <span class="comment">// 수집 완료</span>
                <span class="comment">// EndGather(): 수집을 완료하고 실제 수집된 양을 반환</span>
                <span class="comment">// Busy 상태를 false로 변경하고 자원에서 수집한 양만큼 차감</span>
                <span class="keyword">int</span> <span class="field-name">amountGathered</span> = <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">EndGather</span>();
                
                <span class="comment">// Success: 수집이 성공적으로 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 수집 시간이 완료되지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔧 Worker 클래스 확장</h3>
                    
                    <div class="code-block">
<span class="comment">// Worker.cs - Worker 클래스에 Gather 메서드 추가</span>
<span class="comment">// AbstractUnit을 상속받아 Worker만의 특별한 기능 추가</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// Worker: 자원을 수집할 수 있는 유닛</span>
    <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">Worker</span> : <span class="class-name">AbstractUnit</span>
    {
        <span class="comment">// Gather: 자원을 수집하는 메서드</span>
        <span class="comment">// GatherableSupply: 수집할 자원 객체</span>
        <span class="keyword">public void</span> <span class="method-name">Gather</span>(<span class="class-name">GatherableSupply</span> <span class="field-name">supply</span>)
        {
            <span class="comment">// Blackboard에 자원 정보 설정</span>
            <span class="comment">// graphAgent: AbstractUnit에서 상속받은 BehaviorGraphAgent</span>
            <span class="comment">// SetVariableValue: Blackboard에 변수 값 설정</span>
            
            <span class="comment">// Supply: 수집할 자원 객체를 Blackboard에 설정</span>
            <span class="comment">// "Supply": Blackboard 변수 이름 (대소문자 중요)</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Supply"</span>, <span class="field-name">supply</span>);
            
            <span class="comment">// TargetLocation: 자원의 위치를 목표 위치로 설정</span>
            <span class="comment">// supply.transform.position: 자원의 현재 위치</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"TargetLocation"</span>, <span class="field-name">supply</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>);
            
            <span class="comment">// Command: 명령을 Gather로 설정</span>
            <span class="comment">// UnitCommands.Gather: 수집 명령</span>
            <span class="comment">// 이 명령 설정이 Behavior Tree를 트리거하여 수집 행동 시작</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Command"</span>, <span class="class-name">UnitCommands</span>.<span class="property-name">Gather</span>);
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 수집 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 수집 프로세스</h4>
                        <ul class="content-list">
                            <li><strong>이동 단계</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 시작</strong>: BeginGather() 호출하여 Busy 상태 설정</li>
                            <li><strong>수집 대기</strong>: BaseGatherTime만큼 대기</li>
                            <li><strong>수집 완료</strong>: EndGather() 호출하여 자원 획득</li>
                            <li><strong>상태 정리</strong>: Busy 상태 해제 및 자원 차감</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎯 레이어 시스템</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 레이어 설정</h4>
                        <ul class="content-list">
                            <li><strong>Supplies 레이어</strong>: 자원 전용 레이어 생성</li>
                            <li><strong>Interactable Layers</strong>: 상호작용 가능한 레이어들</li>
                            <li><strong>Layer Collision Matrix</strong>: 레이어 간 충돌 설정</li>
                            <li><strong>PlayerInput 업데이트</strong>: 자원과 상호작용 가능하도록 수정</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 PlayerInput 수정</h4>
                        <ul class="content-list">
                            <li><strong>Interactable Layers</strong>: Units, Buildings, Supplies</li>
                            <li><strong>Layer Mask 조합</strong>: Interactable | Floor Layers</li>
                            <li><strong>CanHandle 체크</strong>: 명령 처리 가능 여부 확인</li>
                            <li><strong>안전한 명령 실행</strong>: 처리할 수 없는 명령 방지</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>경제 시스템</strong>: RTS 게임의 핵심인 자원 수집 메커니즘</p>
                        <p><strong>자동화</strong>: Worker가 지능적으로 자원을 수집</p>
                        <p><strong>확장성</strong>: 다양한 자원 타입을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 수집 행동이 동일한 패턴으로 동작</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>Behavior Tree 활용</strong>: 시각적이고 직관적인 AI 로직</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                        <p><strong>시간 기반 로직</strong>: Time.time을 사용한 정확한 타이밍</p>
                        <p><strong>레이어 시스템</strong>: 체계적인 상호작용 관리</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>Blackboard 변수명</strong>: 대소문자와 정확한 이름 사용</p>
                        <p><strong>레이어 설정</strong>: 자원을 올바른 레이어에 배치</p>
                        <p><strong>시간 계산</strong>: enterTime과 현재 시간의 정확한 비교</p>
                        <p><strong>상태 관리</strong>: BeginGather와 EndGather의 올바른 호출</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 자원</strong>: 미네랄, 가스, 에너지, 금속 등</li>
                        <li><strong>자원 등급</strong>: 일반, 희귀, 전설 등급의 자원</li>
                        <li><strong>수집 효율</strong>: Worker 레벨에 따른 수집 속도 차이</li>
                        <li><strong>자원 보호</strong>: 중요한 자원을 보호하는 방어 시설</li>
                        <li><strong>자동 수집</strong>: Worker가 알아서 가장 가까운 자원 찾기</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>GatherCommand</strong>: 자원 수집 명령 액션 베이스</li>
                        <li><strong>GatherSuppliesAction</strong>: 자원 수집 커스텀 노드</li>
                        <li><strong>Worker.Gather()</strong>: Worker의 자원 수집 메서드</li>
                        <li><strong>Time.time</strong>: 게임 시간 기반 타이밍</li>
                        <li><strong>BeginGather/EndGather</strong>: 자원 수집 상태 관리</li>
                        <li><strong>Supplies 레이어</strong>: 자원 전용 레이어</li>
                        <li><strong>Interactable Layers</strong>: 상호작용 가능한 레이어</li>
                        <li><strong>Sequence 노드</strong>: 순차적 실행을 위한 노드</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 41: Return Supplies to Command Post (자원을 Command Post로 반환) -->
            <div class="lecture-section" id="lecture-41">
                <h2 class="lecture-title">🏠 강의 41: Return Supplies to Command Post (자원을 Command Post로 반환)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자원 반환 시스템</strong>: <span style="color: #2c3e50;">Worker가 수집한 자원을 가장 가까운 Command Post로 반환하는 시스템 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">완전한 수집 사이클</strong>: <span style="color: #2c3e50;">자원 수집 → 반환의 완전한 사이클 완성</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">AI 탐색 시스템</strong>: <span style="color: #2c3e50;">Physics.OverlapSphere를 사용한 가장 가까운 건물 찾기</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">커스텀 노드 확장</strong>: <span style="color: #2c3e50;">FindClosestCommandPost와 MoveToTargetGameObject 노드 추가</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 자원 반환이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker가 미네랄을 캐서 집(Command Post)으로 가져가는 시스템이에요. 마치 장보기에서 사온 것들을 집에 가져가는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집</strong>: Worker가 미네랄을 캐요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>가까운 집 찾기</strong>: 가장 가까운 Command Post를 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>집으로 이동</strong>: Command Post로 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 반환</strong>: 수집한 자원을 Command Post에 넣어요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>반복</strong>: 다시 자원을 캐러 가요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기에서 사온 것들을 집에 가져가서 냉장고에 넣는 것처럼, 게임에서도 Worker가 캔 자원을 Command Post에 저장해요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>GatherSuppliesAction에서 수집량을 Blackboard에 저장</li>
                        <li>FindClosestCommandPostAction 커스텀 노드 구현</li>
                        <li>MoveToTargetGameObjectAction 커스텀 노드 구현</li>
                        <li>Behavior Tree에 자원 반환 시퀀스 추가</li>
                        <li>Physics.OverlapSphere를 사용한 건물 탐색</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🏠 자원 반환 시스템 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>SupplyAmountHeld</strong>: 수집한 자원량을 저장하는 Blackboard 변수</li>
                            <li><strong>FindClosestCommandPostAction</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObjectAction</strong>: GameObject로 이동하는 노드</li>
                            <li><strong>CommandPost</strong>: 찾은 Command Post를 저장하는 변수</li>
                            <li><strong>SearchRadius</strong>: 탐색 반경 설정</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 자원 반환 플로우</h4>
                        <ol class="content-list">
                            <li><strong>자원 수집</strong>: GatherSuppliesAction에서 자원 수집</li>
                            <li><strong>수집량 저장</strong>: SupplyAmountHeld에 수집량 저장</li>
                            <li><strong>Command Post 찾기</strong>: FindClosestCommandPostAction 실행</li>
                            <li><strong>Command Post로 이동</strong>: MoveToTargetGameObjectAction 실행</li>
                            <li><strong>자원 반환</strong>: Command Post에 자원 전달 (다음 강의)</li>
                            <li><strong>반복</strong>: 다시 자원 수집으로 돌아감</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 GatherSuppliesAction 수정</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherSuppliesAction.cs - 수집량을 Blackboard에 저장하도록 수정</span>
<span class="comment">// OnUpdate 메서드에서 수집 완료 시 수집량을 Blackboard에 저장</span>

<span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
{
    <span class="comment">// 수집 시간이 완료되었는지 확인</span>
    <span class="keyword">if</span> (<span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="property-name">Supply</span>.<span class="property-name">BaseGatherTime</span> + <span class="field-name">enterTime</span> &lt;= <span class="class-name">Time</span>.<span class="property-name">time</span>)
    {
        <span class="comment">// 수집 완료</span>
        <span class="comment">// EndGather(): 수집을 완료하고 실제 수집된 양을 반환</span>
        <span class="comment">// Busy 상태를 false로 변경하고 자원에서 수집한 양만큼 차감</span>
        <span class="keyword">int</span> <span class="field-name">amountGathered</span> = <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">EndGather</span>();
        
        <span class="comment">// 수집량을 Blackboard에 저장</span>
        <span class="comment">// Amount: Blackboard의 SupplyAmountHeld 변수</span>
        <span class="comment">// 이 값은 다음 액션에서 사용됨</span>
        <span class="property-name">Amount</span>.<span class="property-name">Value</span> = <span class="field-name">amountGathered</span>;
        
        <span class="comment">// Success: 수집이 성공적으로 완료됨</span>
        <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
    }

    <span class="comment">// Running: 아직 수집 시간이 완료되지 않았으므로 계속 실행 중</span>
    <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔍 FindClosestCommandPostAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// FindClosestCommandPostAction.cs - 가장 가까운 Command Post 찾기</span>
<span class="comment">// Physics.OverlapSphere를 사용하여 주변 건물 탐색</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">System.Collections.Generic</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Units)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Find Closest Command Post"</span>, <span class="parameter">story</span>: <span class="string">"[Unit] finds nearest [CommandPost] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Units"</span>, <span class="parameter">id</span>: <span class="string">"df019f9861776b3b31754a035175faf5"</span>)]
    
    <span class="comment">// FindClosestCommandPostAction: 가장 가까운 Command Post를 찾는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">FindClosestCommandPostAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Unit: Command Post를 찾을 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Unit</span>;
        
        <span class="comment">// CommandPost: 찾은 Command Post를 저장할 변수</span>
        <span class="comment">// GameObject: Command Post의 GameObject</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">CommandPost</span>;
        
        <span class="comment">// SearchRadius: 탐색 반경</span>
        <span class="comment">// float: 실수형 (탐색 반경은 미터 단위)</span>
        <span class="comment">// new(10): 기본값 10으로 초기화</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">float</span>&gt; <span class="property-name">SearchRadius</span> = <span class="keyword">new</span>(<span class="number">10</span>);
        
        <span class="comment">// CommandPostBuilding: Command Post의 UnitSO</span>
        <span class="comment">// UnitSO: 건물의 ScriptableObject</span>
        <span class="comment">// 이 값을 사용하여 Command Post인지 확인</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">UnitSO</span>&gt; <span class="property-name">CommandPostBuilding</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// Physics.OverlapSphere: 구체 모양의 영역에서 Collider들을 찾음</span>
            <span class="comment">// Unit.Value.transform.position: 유닛의 현재 위치</span>
            <span class="comment">// SearchRadius.Value: 탐색 반경</span>
            <span class="comment">// LayerMask.GetMask("Buildings"): Buildings 레이어만 검사</span>
            <span class="comment">// 반환값: 해당 영역에 있는 모든 Collider 배열</span>
            <span class="class-name">Collider</span>[] <span class="field-name">colliders</span> = <span class="class-name">Physics</span>.<span class="method-name">OverlapSphere</span>(
                <span class="property-name">Unit</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, 
                <span class="property-name">SearchRadius</span>.<span class="property-name">Value</span>, 
                <span class="class-name">LayerMask</span>.<span class="method-name">GetMask</span>(<span class="string">"Buildings"</span>));

            <span class="comment">// nearbyCommandPosts: 주변의 Command Post들을 저장할 리스트</span>
            <span class="comment">// List&lt;BaseBuilding&gt;: BaseBuilding 타입의 리스트</span>
            <span class="comment">// new(): 빈 리스트로 초기화</span>
            <span class="class-name">List</span>&lt;<span class="class-name">BaseBuilding</span>&gt; <span class="field-name">nearbyCommandPosts</span> = <span class="keyword">new</span>();

            <span class="comment">// foreach: 배열의 각 요소를 순회</span>
            <span class="comment">// collider: 현재 검사 중인 Collider</span>
            <span class="keyword">foreach</span>(<span class="class-name">Collider</span> <span class="field-name">collider</span> <span class="keyword">in</span> <span class="field-name">colliders</span>)
            {
                <span class="comment">// TryGetComponent: 해당 GameObject에서 BaseBuilding 컴포넌트를 가져옴</span>
                <span class="comment">// out building: 가져온 BaseBuilding을 저장할 변수</span>
                <span class="comment">// building.UnitSO.Equals: 건물의 UnitSO가 Command Post인지 확인</span>
                <span class="comment">// CommandPostBuilding.Value: Blackboard에서 가져온 Command Post의 UnitSO</span>
                <span class="keyword">if</span> (<span class="field-name">collider</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">BaseBuilding</span> <span class="field-name">building</span>) 
                        &amp;&amp; <span class="field-name">building</span>.<span class="property-name">UnitSO</span>.<span class="method-name">Equals</span>(<span class="property-name">CommandPostBuilding</span>.<span class="property-name">Value</span>))
                {
                    <span class="comment">// Command Post인 경우 리스트에 추가</span>
                    <span class="field-name">nearbyCommandPosts</span>.<span class="method-name">Add</span>(<span class="field-name">building</span>);
                }
            }

            <span class="comment">// 주변에 Command Post가 없는 경우</span>
            <span class="keyword">if</span> (<span class="field-name">nearbyCommandPosts</span>.<span class="property-name">Count</span> == <span class="number">0</span>)
            {
                <span class="comment">// Failure: Command Post를 찾을 수 없음</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// Command Post를 찾은 경우</span>
            <span class="comment">// CommandPost.Value: Blackboard의 CommandPost 변수에 저장</span>
            <span class="comment">// nearbyCommandPosts[0].gameObject: 첫 번째 Command Post의 GameObject</span>
            <span class="comment">// 현재는 가장 가까운 것이 아닌 첫 번째 것을 선택 (단순화)</span>
            <span class="property-name">CommandPost</span>.<span class="property-name">Value</span> = <span class="field-name">nearbyCommandPosts</span>[<span class="number">0</span>].<span class="property-name">gameObject</span>;

            <span class="comment">// Success: Command Post를 성공적으로 찾음</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🚶 MoveToTargetGameObjectAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// MoveToTargetGameObjectAction.cs - GameObject로 이동하는 액션 노드</span>
<span class="comment">// MoveToTargetLocationAction과 유사하지만 GameObject의 위치로 이동</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Move to Target GameObject"</span>, <span class="parameter">story</span>: <span class="string">"[Agent] moves to [TargetGameObject] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, <span class="parameter">id</span>: <span class="string">"f07a8fab1fc459315f3380eef35b2aa0"</span>)]
    
    <span class="comment">// MoveToTargetGameObjectAction: GameObject로 이동하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetGameObjectAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 이동할 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// TargetGameObject: 이동할 목표 GameObject</span>
        <span class="comment">// GameObject: 목표가 되는 GameObject</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">TargetGameObject</span>;

        <span class="comment">// agent: NavMeshAgent 컴포넌트</span>
        <span class="comment">// private: 외부에서 접근할 수 없음</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// Failure: NavMeshAgent가 없으면 실패</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// targetPosition: 목표 GameObject의 위치</span>
            <span class="comment">// TargetGameObject.Value.transform.position: 목표 GameObject의 현재 위치</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span> = <span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>;
            
            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.transform.position: 현재 위치</span>
            <span class="comment">// targetPosition: 목표 위치</span>
            <span class="comment">// agent.stoppingDistance: 정지 거리</span>
            <span class="comment">// 이미 목표에 가까이 있으면 성공</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.<span class="method-name">Distance</span>(<span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, <span class="field-name">targetPosition</span>) &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 이미 목표에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// SetDestination: NavMeshAgent에게 목표 위치 설정</span>
            <span class="comment">// targetPosition: 이동할 목표 위치</span>
            <span class="field-name">agent</span>.<span class="method-name">SetDestination</span>(<span class="field-name">targetPosition</span>);
            
            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 주기적으로 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="comment">// 목표에 도달했는지 확인</span>
            <span class="keyword">if</span> (<span class="field-name">agent</span>.<span class="property-name">remainingDistance</span> &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 목표에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 목표에 도달하지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 완전한 수집 사이클</h4>
                        <ul class="content-list">
                            <li><strong>이동 단계</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 단계</strong>: 자원을 수집하고 수집량 저장</li>
                            <li><strong>탐색 단계</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>반환 단계</strong>: Command Post로 이동</li>
                            <li><strong>반복</strong>: 다시 자원 수집으로 돌아감</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Blackboard 변수 설정</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 필요한 Blackboard 변수들</h4>
                        <ul class="content-list">
                            <li><strong>SupplyAmountHeld</strong>: 수집한 자원량 (int)</li>
                            <li><strong>CommandPost</strong>: 찾은 Command Post (GameObject)</li>
                            <li><strong>SearchRadius</strong>: 탐색 반경 (float, 기본값 10)</li>
                            <li><strong>CommandPostBuilding</strong>: Command Post의 UnitSO</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 변수 연결</h4>
                        <ul class="content-list">
                            <li><strong>GatherSupplies → SupplyAmountHeld</strong>: 수집량 저장</li>
                            <li><strong>FindClosestCommandPost → CommandPost</strong>: 찾은 Command Post 저장</li>
                            <li><strong>MoveToTargetGameObject → CommandPost</strong>: Command Post로 이동</li>
                            <li><strong>CommandPostBuilding</strong>: Command Post 식별용</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>완전한 경제 시스템</strong>: 자원 수집 → 반환의 완전한 사이클</p>
                        <p><strong>자동화</strong>: Worker가 지능적으로 자원을 수집하고 반환</p>
                        <p><strong>확장성</strong>: 다양한 건물 타입을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 수집 행동이 동일한 패턴으로 동작</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>Physics 시스템 활용</strong>: OverlapSphere로 효율적인 탐색</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                        <p><strong>Blackboard 활용</strong>: 노드 간 데이터 공유</p>
                        <p><strong>레이어 시스템</strong>: Buildings 레이어로 정확한 탐색</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>UnitSO 접근</strong>: BaseBuilding의 UnitSO를 public으로 변경</p>
                        <p><strong>레이어 설정</strong>: 건물을 올바른 레이어에 배치</p>
                        <p><strong>탐색 반경</strong>: 적절한 SearchRadius 설정</p>
                        <p><strong>성능 고려</strong>: 너무 많은 건물이 있으면 성능 저하</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 건물</strong>: Command Post, Supply Depot, Refinery 등</li>
                        <li><strong>자원 저장소</strong>: 각 건물마다 다른 자원 저장</li>
                        <li><strong>우선순위 시스템</strong>: 가장 가까운 건물이 아닌 가장 효율적인 건물</li>
                        <li><strong>자원 전송</strong>: 건물 간 자원 이동 시스템</li>
                        <li><strong>자동 배치</strong>: Worker가 알아서 최적의 건물 찾기</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>Physics.OverlapSphere</strong>: 구체 영역에서 Collider 탐색</li>
                        <li><strong>LayerMask.GetMask</strong>: 특정 레이어만 검사</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                        <li><strong>UnitSO.Equals</strong>: ScriptableObject 비교</li>
                        <li><strong>Blackboard 변수</strong>: 노드 간 데이터 공유</li>
                        <li><strong>Sequence 노드</strong>: 순차적 실행을 위한 노드</li>
                        <li><strong>GameObject 이동</strong>: Vector3가 아닌 GameObject로 이동</li>
                        <li><strong>탐색 반경</strong>: 효율적인 건물 탐색</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 42: Smooth Gathering Movement (부드러운 자원 수집 이동) -->
            <div class="lecture-section" id="lecture-42">
                <h2 class="lecture-title">🚶 강의 42: Smooth Gathering Movement (부드러운 자원 수집 이동)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">부드러운 이동</strong>: <span style="color: #2c3e50;">Worker들이 자원을 수집할 때 더 부드럽게 움직이도록 개선</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">Obstacle Avoidance 조정</strong>: <span style="color: #2c3e50;">자원 수집 시 다른 유닛들을 무시하고 통과할 수 있도록 설정</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">게임플레이 개선</strong>: <span style="color: #2c3e50;">StarCraft와 같은 RTS 게임의 수집 행동 패턴 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">동적 설정</strong>: <span style="color: #2c3e50;">Behavior Tree에서 상황에 따라 NavMesh Agent 설정 변경</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🚶 부드러운 이동이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker들이 자원을 캐러 갈 때 다른 Worker들을 피해서 돌아다니지 않고, 그냥 통과해서 가는 시스템이에요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집 시</strong>: 다른 Worker들을 무시하고 통과해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>일반 이동 시</strong>: 다른 유닛들을 피해서 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자동 전환</strong>: 상황에 따라 자동으로 바뀌어요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기 갈 때는 다른 사람들을 피해서 돌아다니지만, 급할 때는 그냥 지나가는 것처럼, 게임에서도 상황에 따라 다르게 움직여요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>NavMesh Agent의 Obstacle Avoidance 개념 이해</li>
                        <li>SetAgentAvoidanceAction 커스텀 노드 구현</li>
                        <li>Behavior Tree에서 동적으로 avoidance 설정 변경</li>
                        <li>자원 수집 시와 일반 이동 시 다른 설정 적용</li>
                        <li>게임플레이 개선을 위한 이동 최적화</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🚶 Obstacle Avoidance 시스템</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 Obstacle Avoidance 타입</h4>
                        <ul class="content-list">
                            <li><strong>No Obstacle Avoidance (0)</strong>: 다른 유닛을 무시하고 통과</li>
                            <li><strong>Low Quality (1)</strong>: 낮은 품질의 회피</li>
                            <li><strong>Medium Quality (2)</strong>: 중간 품질의 회피</li>
                            <li><strong>Good Quality (3)</strong>: 좋은 품질의 회피</li>
                            <li><strong>High Quality (4)</strong>: 높은 품질의 회피 (기본값)</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 상황별 설정</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시</strong>: No Obstacle Avoidance (0) - 다른 Worker 무시</li>
                            <li><strong>일반 이동 시</strong>: High Quality (4) - 다른 유닛 회피</li>
                            <li><strong>전투 시</strong>: High Quality (4) - 전술적 이동</li>
                            <li><strong>건설 시</strong>: Medium Quality (2) - 적당한 회피</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 SetAgentAvoidanceAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// SetAgentAvoidanceAction.cs - NavMesh Agent의 Obstacle Avoidance 설정</span>
<span class="comment">// Behavior Tree에서 동적으로 avoidance 품질을 변경</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(
        <span class="parameter">name</span>: <span class="string">"Set Agent Avoidance"</span>, 
        <span class="parameter">story</span>: <span class="string">"Set [Agent] avoidance quality to [AvoidanceQuality] ."</span>, 
        <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, 
        <span class="parameter">id</span>: <span class="string">"3a4f7ab7967bf186b0c645339d0ace1e"</span>
    )]
    
    <span class="comment">// SetAgentAvoidanceAction: NavMesh Agent의 Obstacle Avoidance를 설정하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">SetAgentAvoidanceAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 설정할 NavMesh Agent가 있는 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// AvoidanceQuality: 설정할 avoidance 품질 (0-4)</span>
        <span class="comment">// int: 정수형 (0=No, 1=Low, 2=Medium, 3=Good, 4=High)</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; <span class="property-name">AvoidanceQuality</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="comment">// AvoidanceQuality > 4: 유효하지 않은 높은 값</span>
            <span class="comment">// AvoidanceQuality < 0: 유효하지 않은 낮은 값</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>) || 
                <span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span> > <span class="number">4</span> || 
                <span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span> &lt; <span class="number">0</span>)
            {
                <span class="comment">// Failure: NavMeshAgent가 없거나 유효하지 않은 avoidance 품질</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// obstacleAvoidanceType: NavMesh Agent의 obstacle avoidance 타입</span>
            <span class="comment">// (ObstacleAvoidanceType): int를 ObstacleAvoidanceType enum으로 캐스팅</span>
            <span class="comment">// AvoidanceQuality.Value: Blackboard에서 가져온 avoidance 품질 값</span>
            <span class="field-name">agent</span>.<span class="property-name">obstacleAvoidanceType</span> = (<span class="class-name">ObstacleAvoidanceType</span>)<span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span>;

            <span class="comment">// Success: avoidance 품질을 성공적으로 설정함</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>SetAgentAvoidance (0)</strong>: 자원 수집 시 No Obstacle Avoidance</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                            <li><strong>SetAgentAvoidance (4)</strong>: 일반 이동 시 High Quality</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 이동 최적화 프로세스</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시작</strong>: Obstacle Avoidance를 0으로 설정</li>
                            <li><strong>자원으로 이동</strong>: 다른 Worker들을 무시하고 통과</li>
                            <li><strong>자원 수집</strong>: 부드럽게 자원 수집</li>
                            <li><strong>Command Post로 이동</strong>: 다른 Worker들을 무시하고 통과</li>
                            <li><strong>일반 이동 복원</strong>: Obstacle Avoidance를 4로 설정</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Blackboard 변수 설정</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 필요한 Blackboard 변수들</h4>
                        <ul class="content-list">
                            <li><strong>AvoidanceQuality</strong>: 설정할 avoidance 품질 (int)</li>
                            <li><strong>Agent</strong>: NavMesh Agent가 있는 GameObject</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 변수 연결</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시</strong>: AvoidanceQuality = 0 (No Obstacle Avoidance)</li>
                            <li><strong>일반 이동 시</strong>: AvoidanceQuality = 4 (High Quality)</li>
                            <li><strong>Agent</strong>: Self (현재 유닛)</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>자연스러운 수집</strong>: StarCraft와 같은 RTS 게임의 수집 행동 패턴</p>
                        <p><strong>성능 최적화</strong>: 불필요한 회피 계산 제거</p>
                        <p><strong>사용자 경험</strong>: 더 부드럽고 직관적인 이동</p>
                        <p><strong>게임플레이 개선</strong>: 자원 수집이 더 효율적으로</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>동적 설정</strong>: Behavior Tree에서 상황에 따라 설정 변경</p>
                        <p><strong>간단한 구현</strong>: 단순하지만 효과적인 솔루션</p>
                        <p><strong>유연성</strong>: 다양한 상황에 적용 가능</p>
                        <p><strong>성능</strong>: 불필요한 계산 제거</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>유효성 검사</strong>: 0-4 범위 내의 값만 허용</p>
                        <p><strong>NavMeshAgent 확인</strong>: 컴포넌트 존재 여부 확인</p>
                        <p><strong>타입 캐스팅</strong>: int를 ObstacleAvoidanceType으로 안전하게 변환</p>
                        <p><strong>상황별 적용</strong>: 적절한 시점에 설정 변경</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 이동 모드</strong>: 수집, 전투, 건설, 탐색 모드</li>
                        <li><strong>상황별 최적화</strong>: 각 상황에 맞는 이동 설정</li>
                        <li><strong>성능 최적화</strong>: 불필요한 회피 계산 제거</li>
                        <li><strong>사용자 경험</strong>: 더 부드럽고 직관적인 이동</li>
                        <li><strong>전술적 이동</strong>: 전투 시와 평시 이동 구분</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>ObstacleAvoidanceType</strong>: NavMesh Agent의 회피 타입</li>
                        <li><strong>SetAgentAvoidanceAction</strong>: avoidance 설정 커스텀 노드</li>
                        <li><strong>동적 설정</strong>: Behavior Tree에서 런타임 설정 변경</li>
                        <li><strong>타입 캐스팅</strong>: int를 enum으로 안전하게 변환</li>
                        <li><strong>유효성 검사</strong>: 입력값 범위 확인</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                        <li><strong>상황별 최적화</strong>: 각 상황에 맞는 이동 설정</li>
                        <li><strong>게임플레이 개선</strong>: 더 자연스러운 이동 패턴</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 43: Pick Better Gathering Locations (더 나은 자원 수집 위치 선택) -->
            <div class="lecture-section" id="lecture-43">
                <h2 class="lecture-title">🎯 강의 43: Pick Better Gathering Locations (더 나은 자원 수집 위치 선택)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">최적화된 위치 선택</strong>: <span style="color: #2c3e50;">Worker들이 자원과 Command Post의 가장 가까운 지점을 선택하도록 개선</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">Collider 활용</strong>: <span style="color: #2c3e50;">Collider.ClosestPoint API를 사용하여 정확한 위치 계산</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자연스러운 이동</strong>: <span style="color: #2c3e50;">RTS 게임다운 직관적이고 효율적인 이동 패턴</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">성능 개선</strong>: <span style="color: #2c3e50;">불필요한 우회 이동 제거로 더 빠른 자원 수집</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🎯 더 나은 위치 선택이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker들이 자원을 캐러 갈 때, 자원의 뒤쪽이 아니라 가장 가까운 쪽으로 가도록 하는 시스템이에요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집 시</strong>: 자원에서 가장 가까운 지점을 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>Command Post 반환 시</strong>: Command Post에서 가장 가까운 지점을 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>Collider 활용</strong>: 물체의 모양을 고려해서 정확한 위치를 계산해요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기 갈 때 가게의 뒷문이 아니라 앞문으로 가는 것처럼, 게임에서도 가장 가까운 곳으로 가요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>Collider.ClosestPoint API 이해 및 활용</li>
                        <li>MoveToTargetGameObjectAction 개선</li>
                        <li>Worker.Gather() 메서드 업데이트</li>
                        <li>Behavior Tree Blackboard 변수 추가</li>
                        <li>더 직관적인 자원 수집 위치 선택</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🎯 문제점과 해결책</h3>
                    
                    <div class="tech-stack">
                        <h4>❌ 기존 문제점</h4>
                        <ul class="content-list">
                            <li><strong>임의의 위치 선택</strong>: 자원의 중심점에서 동일한 거리의 4개 지점 중 랜덤 선택</li>
                            <li><strong>비효율적인 이동</strong>: Worker가 자원의 뒤쪽으로 돌아가는 경우</li>
                            <li><strong>불필요한 우회</strong>: Command Post 반환 시에도 비효율적인 경로</li>
                            <li><strong>부자연스러운 동작</strong>: RTS 게임다운 직관적이지 않은 이동</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>✅ 개선된 해결책</h4>
                        <ul class="content-list">
                            <li><strong>ClosestPoint API</strong>: Collider에서 가장 가까운 지점 계산</li>
                            <li><strong>최적화된 경로</strong>: Worker 위치를 고려한 최단 경로</li>
                            <li><strong>자연스러운 이동</strong>: 직관적이고 효율적인 이동 패턴</li>
                            <li><strong>성능 향상</strong>: 불필요한 이동 시간 단축</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 MoveToTargetGameObjectAction 개선</h3>
                    
                    <div class="code-block">
<span class="comment">// MoveToTargetGameObjectAction.cs - 개선된 GameObject 이동 액션</span>
<span class="comment">// Collider.ClosestPoint를 사용하여 최적의 위치 선택</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(
        <span class="parameter">name</span>: <span class="string">"Move to Target GameObject"</span>, 
        <span class="parameter">story</span>: <span class="string">"[Agent] moves to [TargetGameObject] ."</span>, 
        <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, 
        <span class="parameter">id</span>: <span class="string">"f07a8fab1fc459315f3380eef35b2aa0"</span>
    )]
    
    <span class="comment">// MoveToTargetGameObjectAction: GameObject로 이동하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetGameObjectAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 이동할 NavMesh Agent가 있는 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// TargetGameObject: 이동할 대상 GameObject</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">TargetGameObject</span>;

        <span class="comment">// agent: NavMesh Agent 컴포넌트 참조</span>
        <span class="comment">// private: 클래스 내부에서만 접근 가능</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// Failure: NavMeshAgent가 없는 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// GetTargetPosition: 최적의 목표 위치를 계산하는 메서드</span>
            <span class="comment">// Vector3: 3차원 벡터 (x, y, z 좌표)</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span> = <span class="method-name">GetTargetPosition</span>();

            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
            <span class="comment">// agent.stoppingDistance: NavMesh Agent의 정지 거리</span>
            <span class="comment">// <=: 작거나 같음 비교 연산자</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.<span class="method-name">Distance</span>(
                <span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, 
                <span class="field-name">targetPosition</span>
            ) &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 이미 목표 위치에 도달한 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// SetDestination: NavMesh Agent의 목표 위치 설정</span>
            <span class="comment">// targetPosition: 계산된 최적의 목표 위치</span>
            <span class="field-name">agent</span>.<span class="method-name">SetDestination</span>(<span class="field-name">targetPosition</span>);
            
            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 매 프레임 호출되는 메서드</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="keyword">if</span> (<span class="field-name">agent</span>.<span class="property-name">remainingDistance</span> &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 목표 위치에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 이동 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// GetTargetPosition: 최적의 목표 위치를 계산하는 private 메서드</span>
        <span class="comment">// private: 클래스 내부에서만 호출 가능</span>
        <span class="comment">// Vector3: 반환 타입 (3차원 벡터)</span>
        <span class="keyword">private</span> <span class="class-name">Vector3</span> <span class="method-name">GetTargetPosition</span>()
        {
            <span class="comment">// targetPosition: 계산될 목표 위치를 저장할 변수</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span>;
            
            <span class="comment">// TryGetComponent: TargetGameObject에서 Collider 컴포넌트를 가져옴</span>
            <span class="comment">// out collider: 가져온 Collider를 저장할 변수</span>
            <span class="keyword">if</span> (<span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">Collider</span> <span class="field-name">collider</span>))
            {
                <span class="comment">// ClosestPoint: Collider에서 가장 가까운 지점을 계산</span>
                <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
                <span class="comment">// 반환값: Collider 표면에서 Agent에 가장 가까운 지점</span>
                <span class="field-name">targetPosition</span> = <span class="field-name">collider</span>.<span class="method-name">ClosestPoint</span>(<span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>);
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// Collider가 없는 경우: GameObject의 transform.position 사용</span>
                <span class="comment">// TargetGameObject.Value.transform.position: GameObject의 중심 위치</span>
                <span class="field-name">targetPosition</span> = <span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>;
            }

            <span class="comment">// 계산된 목표 위치 반환</span>
            <span class="keyword">return</span> <span class="field-name">targetPosition</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔧 Worker.Gather() 메서드 업데이트</h3>
                    
                    <div class="code-block">
<span class="comment">// Worker.cs - 개선된 자원 수집 메서드</span>
<span class="comment">// TargetGameObject를 사용하여 더 정확한 위치 설정</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// Worker: AbstractUnit을 상속하고 IGatherer 인터페이스를 구현</span>
    <span class="comment">// IGatherer: 자원 수집 기능을 제공하는 인터페이스</span>
    <span class="keyword">public class</span> <span class="class-name">Worker</span> : <span class="class-name">AbstractUnit</span>, <span class="class-name">IGatherer</span>
    {
        <span class="comment">// Gather: 자원 수집을 시작하는 메서드</span>
        <span class="comment">// public: 외부에서 호출 가능</span>
        <span class="comment">// void: 반환값 없음</span>
        <span class="comment">// GatherableSupply supply: 수집할 자원 객체</span>
        <span class="keyword">public void</span> <span class="method-name">Gather</span>(<span class="class-name">GatherableSupply</span> <span class="field-name">supply</span>)
        {
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Supply": Blackboard 변수 이름</span>
            <span class="comment">// supply: 설정할 값 (GatherableSupply 객체)</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Supply"</span>, <span class="field-name">supply</span>);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "TargetGameObject": Blackboard 변수 이름</span>
            <span class="comment">// supply.gameObject: 수집할 자원의 GameObject</span>
            <span class="comment">// 이전: TargetLocation (Vector3) 사용</span>
            <span class="comment">// 개선: TargetGameObject (GameObject) 사용으로 Collider.ClosestPoint 활용 가능</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"TargetGameObject"</span>, <span class="field-name">supply</span>.<span class="property-name">gameObject</span>);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Command": Blackboard 변수 이름</span>
            <span class="comment">// UnitCommands.Gather: 수집 명령</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Command"</span>, <span class="class-name">UnitCommands</span>.<span class="property-name">Gather</span>);
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 Blackboard 변수</h4>
                        <ul class="content-list">
                            <li><strong>TargetGameObject</strong>: 이동할 대상 GameObject (GameObject)</li>
                            <li><strong>TargetLocation</strong>: 이동할 위치 (Vector3) - 기존 유지</li>
                            <li><strong>Supply</strong>: 수집할 자원 (GatherableSupply)</li>
                            <li><strong>Command</strong>: 현재 명령 (UnitCommands)</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 업데이트된 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>SetAgentAvoidance (0)</strong>: 자원 수집 시 No Obstacle Avoidance</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetGameObject</strong>: 자원 GameObject로 이동 (개선됨)</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post GameObject로 이동 (개선됨)</li>
                            <li><strong>SetAgentAvoidance (4)</strong>: 일반 이동 시 High Quality</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Collider.ClosestPoint API</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 API 설명</h4>
                        <ul class="content-list">
                            <li><strong>Collider.ClosestPoint(Vector3 point)</strong>: Collider 표면에서 가장 가까운 지점 반환</li>
                            <li><strong>매개변수</strong>: 기준점이 되는 Vector3 위치</li>
                            <li><strong>반환값</strong>: Collider 표면에서 가장 가까운 Vector3 위치</li>
                            <li><strong>용도</strong>: 정확한 접근 지점 계산</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 활용 예시</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집</strong>: Worker 위치에서 자원 Collider까지의 최단 지점</li>
                            <li><strong>건물 접근</strong>: 유닛 위치에서 건물 Collider까지의 최단 지점</li>
                            <li><strong>장애물 회피</strong>: 장애물 주변의 안전한 경로 계산</li>
                            <li><strong>정확한 배치</strong>: 객체 주변의 정확한 배치 위치</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>직관적인 이동</strong>: RTS 게임다운 자연스러운 이동 패턴</p>
                        <p><strong>효율성</strong>: 불필요한 우회 이동 제거</p>
                        <p><strong>사용자 경험</strong>: 예측 가능하고 합리적인 유닛 동작</p>
                        <p><strong>게임플레이</strong>: 더 빠르고 효율적인 자원 수집</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>정확한 계산</strong>: Collider의 실제 모양을 고려한 위치 계산</p>
                        <p><strong>유연성</strong>: 다양한 크기와 모양의 객체에 적용 가능</p>
                        <p><strong>성능</strong>: Unity 내장 API 사용으로 최적화된 성능</p>
                        <p><strong>확장성</strong>: 다른 이동 시나리오에도 적용 가능</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>Collider 존재 확인</strong>: TryGetComponent로 안전한 접근</p>
                        <p><strong>폴백 로직</strong>: Collider가 없는 경우 기존 방식 사용</p>
                        <p><strong>성능 고려</strong>: 매 프레임 호출 시 성능 영향 고려</p>
                        <p><strong>정확도</strong>: Collider의 복잡도에 따른 계산 정확도</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>정확한 건물 접근</strong>: 건물의 입구나 특정 지점으로 정확한 접근</li>
                        <li><strong>자원 수집 최적화</strong>: 자원에서 가장 효율적인 수집 지점 선택</li>
                        <li><strong>전투 위치 계산</strong>: 적 건물이나 유닛에 대한 최적의 공격 위치</li>
                        <li><strong>건설 위치 선택</strong>: 건물 건설 시 가장 적절한 위치 계산</li>
                        <li><strong>탐색 최적화</strong>: 탐색 대상에 대한 효율적인 접근 경로</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>Collider.ClosestPoint</strong>: Collider에서 가장 가까운 지점 계산 API</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 접근 방법</li>
                        <li><strong>폴백 로직</strong>: 대안적 처리 방식 제공</li>
                        <li><strong>Blackboard 변수</strong>: Behavior Tree의 데이터 통신</li>
                        <li><strong>GameObject vs Vector3</strong>: 위치 정보의 표현 방식 차이</li>
                        <li><strong>최적화된 경로</strong>: 효율적인 이동 경로 계산</li>
                        <li><strong>RTS 게임 패턴</strong>: 전략 게임의 표준적인 이동 방식</li>
                        <li><strong>사용자 경험</strong>: 직관적이고 예측 가능한 동작</li>
                    </ul>
                </div>
            </div>

        </div>
        
        <!-- Lecture 44: Smart Gathering -->
        <div class="lecture-section">
            <h2 id="lecture-44">강의 44: Smart Gathering - 지능적인 자원 수집</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>기존 시스템에서는 Worker가 지정된 자원에만 집착해서, 그 자원이 다른 Worker에 의해 사용 중이면 계속 기다리기만 했습니다. 이는 비효율적이고 Worker들이 제대로 활용되지 않는 문제가 있었습니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 여러 명이 같은 과자 봉지를 두고 싸우는 것과 같습니다. 한 명이 과자를 먹고 있으면 다른 사람들은 그냥 기다려야 했어요. 하지만 이제는 주변에 다른 과자 봉지가 있는지 살펴보고, 비어있는 과자 봉지로 가서 먹을 수 있게 됩니다!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. MoveToGatherableSupplyAction</h4>
                <p>기존의 단순한 이동 대신, 지능적인 자원 선택 로직을 포함한 새로운 액션:</p>
                
                <div class="code-block">
<span class="comment">// MoveToGatherableSupplyAction.cs - 지능적인 자원 수집 액션</span>
<span class="comment">// 바쁘지 않은 자원을 찾아서 이동하는 스마트한 시스템</span>

<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> System;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> Action = Unity.Behavior.Action;
<span class="keyword">using</span> Unity.Properties;
<span class="keyword">using</span> UnityEngine.AI;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.Linq;
<span class="keyword">using</span> GameDevTV.RTS.Utilities;

<span class="keyword">namespace</span> GameDevTV.RTS.Behavior
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [Serializable, GeneratePropertyBag]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [NodeDescription(
        name: <span class="string">"Move to GatherableSupply"</span>, 
        story: <span class="string">"[Agent] moves to [Supply] or nearby not busy supply."</span>, 
        category: <span class="string">"Action/Navigation"</span>, 
        id: <span class="string">"b9248f874f11b1a358e671809522dbfc"</span>
    )]
    
    <span class="comment">// MoveToGatherableSupplyAction: 지능적인 자원 수집을 위한 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToGatherableSupplyAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 이동할 NavMesh Agent가 있는 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// Supply: 수집할 자원 객체</span>
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GatherableSupply</span>&gt; <span class="property-name">Supply</span>;
        
        <span class="comment">// SearchRadius: 주변 자원을 찾을 반경</span>
        <span class="comment">// float: 실수형 (미터 단위)</span>
        <span class="comment">// new(7f): 기본값 7미터로 초기화</span>
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">float</span>&gt; <span class="property-name">SearchRadius</span> = <span class="keyword">new</span>(<span class="number">7f</span>);

        <span class="comment">// agent: NavMesh Agent 컴포넌트 참조</span>
        <span class="comment">// private: 클래스 내부에서만 접근 가능</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> agent;
        
        <span class="comment">// suppliesMask: Supplies 레이어 마스크</span>
        <span class="comment">// LayerMask: 레이어 마스크 타입</span>
        <span class="keyword">private</span> <span class="class-name">LayerMask</span> suppliesMask;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnStart()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="keyword">if</span> (!Agent.Value.TryGetComponent(<span class="keyword">out</span> agent))
            {
                <span class="comment">// Failure: NavMeshAgent가 없는 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Failure;
            }

            <span class="comment">// LayerMask.GetMask: "Supplies" 레이어의 마스크를 가져옴</span>
            <span class="comment">// 이렇게 하면 Supplies 레이어에 있는 객체만 검사</span>
            suppliesMask = <span class="class-name">LayerMask</span>.GetMask(<span class="string">"Supplies"</span>);

            <span class="comment">// GetTargetPosition: 현재 자원의 최적 위치를 계산</span>
            <span class="class-name">Vector3</span> targetPosition = GetTargetPosition();

            <span class="comment">// SetDestination: NavMesh Agent의 목표 위치 설정</span>
            <span class="comment">// targetPosition: 계산된 목표 위치</span>
            agent.SetDestination(targetPosition);
            
            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 매 프레임 호출되는 메서드</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnUpdate()
        {
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="comment">// >=: 크거나 같음 비교 연산자</span>
            <span class="keyword">if</span> (agent.remainingDistance >= agent.stoppingDistance)
            {
                <span class="comment">// Running: 아직 목표에 도달하지 못함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
            }

            <span class="comment">// IsBusy: 자원이 다른 Worker에 의해 사용 중인지 확인</span>
            <span class="comment">// Amount: 자원의 남은 양</span>
            <span class="comment">// !: 논리 부정 연산자</span>
            <span class="comment">// &&: 논리 AND 연산자</span>
            <span class="keyword">if</span> (!Supply.Value.IsBusy && Supply.Value.Amount > <span class="number">0</span>)
            {
                <span class="comment">// Success: 자원이 사용 가능하고 양이 남아있음</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Success;
            }

            <span class="comment">// Physics.OverlapSphere: 구체 모양의 영역에서 Collider들을 찾음</span>
            <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
            <span class="comment">// SearchRadius: 탐색 반경</span>
            <span class="comment">// suppliesMask: Supplies 레이어만 검사</span>
            <span class="comment">// .Where(): LINQ 확장 메서드로 조건에 맞는 요소만 필터링</span>
            <span class="comment">// .ToArray(): 필터링된 결과를 배열로 변환</span>
            <span class="class-name">Collider</span>[] colliders = <span class="class-name">Physics</span>.OverlapSphere(
                agent.transform.position,
                SearchRadius,
                suppliesMask
            ).Where(collider => 
                    <span class="comment">// TryGetComponent: Collider에서 GatherableSupply 컴포넌트를 가져옴</span>
                    <span class="comment">// out supply: 가져온 GatherableSupply를 저장할 변수</span>
                    collider.TryGetComponent(<span class="keyword">out</span> <span class="class-name">GatherableSupply</span> supply)
                    <span class="comment">// !supply.IsBusy: 자원이 사용 중이 아님</span>
                    && !supply.IsBusy
                    <span class="comment">// supply.Supply.Equals: 같은 타입의 자원인지 확인</span>
                    <span class="comment">// Supply.Value.Supply: 원래 목표했던 자원의 타입</span>
                    && supply.Supply.Equals(Supply.Value.Supply)
            ).ToArray();

            <span class="comment">// colliders.Length: 찾은 자원의 개수</span>
            <span class="keyword">if</span> (colliders.Length > <span class="number">0</span>)
            {
                <span class="comment">// Array.Sort: 배열을 정렬</span>
                <span class="comment">// colliders: 정렬할 Collider 배열</span>
                <span class="comment">// ClosestColliderComparer: 거리 기준으로 정렬하는 비교자</span>
                <span class="comment">// agent.transform.position: 거리 계산의 기준점</span>
                <span class="class-name">Array</span>.Sort(colliders, <span class="keyword">new</span> <span class="class-name">ClosestColliderComparer</span>(agent.transform.position));

                <span class="comment">// colliders[0]: 가장 가까운 자원 (정렬 후 첫 번째)</span>
                <span class="comment">// GetComponent: Collider에서 GatherableSupply 컴포넌트를 가져옴</span>
                <span class="comment">// Supply.Value: Blackboard의 Supply 변수에 새로운 자원 설정</span>
                Supply.Value = colliders[<span class="number">0</span>].GetComponent&lt;<span class="class-name">GatherableSupply</span>&gt;();
                
                <span class="comment">// SetDestination: 새로운 자원으로 이동</span>
                <span class="comment">// GetTargetPosition: 새로운 자원의 최적 위치 계산</span>
                agent.SetDestination(GetTargetPosition());
                
                <span class="comment">// Running: 새로운 자원으로 이동 중</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
            }

            <span class="comment">// Failure: 주변에 사용 가능한 자원이 없음</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Failure;
        }

        <span class="comment">// GetTargetPosition: 최적의 목표 위치를 계산하는 private 메서드</span>
        <span class="comment">// private: 클래스 내부에서만 호출 가능</span>
        <span class="comment">// Vector3: 반환 타입 (3차원 벡터)</span>
        <span class="keyword">private</span> <span class="class-name">Vector3</span> GetTargetPosition()
        {
            <span class="comment">// targetPosition: 계산될 목표 위치를 저장할 변수</span>
            <span class="class-name">Vector3</span> targetPosition;
            
            <span class="comment">// TryGetComponent: Supply GameObject에서 Collider 컴포넌트를 가져옴</span>
            <span class="comment">// out collider: 가져온 Collider를 저장할 변수</span>
            <span class="keyword">if</span> (Supply.Value.TryGetComponent(<span class="keyword">out</span> <span class="class-name">Collider</span> collider))
            {
                <span class="comment">// ClosestPoint: Collider에서 가장 가까운 지점을 계산</span>
                <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
                <span class="comment">// 반환값: Collider 표면에서 Agent에 가장 가까운 지점</span>
                targetPosition = collider.ClosestPoint(agent.transform.position);
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// Collider가 없는 경우: GameObject의 transform.position 사용</span>
                <span class="comment">// Supply.Value.transform.position: 자원 GameObject의 중심 위치</span>
                targetPosition = Supply.Value.transform.position;
            }

            <span class="comment">// 계산된 목표 위치 반환</span>
            <span class="keyword">return</span> targetPosition;
        }
    }
}</div>
                
                <h4>2. ClosestColliderComparer</h4>
                <p>거리 기준으로 Collider들을 정렬하는 유틸리티 클래스:</p>
                
                <div class="code-block">
<pre><code>// ClosestColliderComparer.cs - 거리 기준 Collider 정렬기
// 가장 가까운 자원을 찾기 위한 비교자

using System.Collections.Generic;
using UnityEngine;

namespace GameDevTV.RTS.Utilities
{
    // ClosestColliderComparer: Collider들을 거리 기준으로 정렬하는 구조체
    // struct: 값 타입 (메모리 효율적)
    // IComparer<Collider>: Collider 비교를 위한 인터페이스 구현
    public struct ClosestColliderComparer : IComparer<Collider>
    {
        // targetPosition: 거리 계산의 기준점
        // private: 구조체 내부에서만 접근 가능
        // Vector3: 3차원 벡터 (x, y, z 좌표)
        private Vector3 targetPosition;

        // 생성자: 기준점을 받아서 초기화
        // public: 외부에서 호출 가능
        // Vector3 position: 거리 계산의 기준점
        public ClosestColliderComparer(Vector3 position)
        {
            // targetPosition: 기준점 저장
            targetPosition = position;
        }

        // Compare: 두 Collider를 비교하는 메서드
        // public: 외부에서 호출 가능
        // int: 반환 타입 (음수, 0, 양수)
        // Collider x, y: 비교할 두 Collider
        public int Compare(Collider x, Collider y)
        {
            // sqrMagnitude: 벡터의 제곱 크기 (거리 계산에 효율적)
            // transform.position: Collider의 위치
            // -: 벡터 빼기 연산
            // CompareTo: 두 값을 비교하여 정렬 순서 결정
            return (x.transform.position - targetPosition).sqrMagnitude
                .CompareTo((y.transform.position - targetPosition).sqrMagnitude);
        }
    }
}</code></pre>
                </div>
                
                <h3>🔄 동작 과정</h3>
                <ol>
                    <li><strong>초기 이동</strong>: 지정된 자원으로 이동 시작</li>
                    <li><strong>도달 확인</strong>: 자원에 도달했는지 확인</li>
                    <li><strong>사용 가능성 체크</strong>: 자원이 사용 가능하고 양이 남아있는지 확인</li>
                    <li><strong>대안 탐색</strong>: 사용 불가능하면 주변 7미터 내에서 같은 타입의 사용 가능한 자원 탐색</li>
                    <li><strong>가장 가까운 자원 선택</strong>: ClosestColliderComparer로 가장 가까운 자원 선택</li>
                    <li><strong>새로운 목표로 이동</strong>: 선택된 자원으로 이동</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>효율성 향상</strong>: Worker들이 더 이상 한 자원에만 집착하지 않음</li>
                    <li><strong>자동 분산</strong>: 여러 Worker가 같은 자원을 타겟팅해도 자동으로 분산됨</li>
                    <li><strong>대기 시간 단축</strong>: 바쁜 자원을 기다리지 않고 다른 자원으로 이동</li>
                    <li><strong>자연스러운 동작</strong>: 실제 RTS 게임과 같은 지능적인 자원 수집</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>LINQ 활용</strong>: Where()와 ToArray()로 효율적인 필터링</li>
                    <li><strong>커스텀 비교자</strong>: ClosestColliderComparer로 거리 기준 정렬</li>
                    <li><strong>LayerMask 최적화</strong>: Supplies 레이어만 검사하여 성능 향상</li>
                    <li><strong>동적 목표 변경</strong>: Blackboard의 Supply 변수를 실시간으로 업데이트</li>
                </ul>
            </div>
        </div>
        
        <!-- Lecture 45: Gathering Edge Cases -->
        <div class="lecture-section">
            <h2 id="lecture-45">강의 45: Gathering Edge Cases - 자원 수집 엣지 케이스 해결</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>기존 자원 수집 시스템에는 여러 엣지 케이스들이 있었습니다. Worker가 자원을 수집하는 중에 새로운 명령을 받으면 자원이 계속 "busy" 상태로 남아있거나, 자원이 완전히 고갈되어 파괴된 후에도 참조하려고 시도하는 등의 문제가 발생했습니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 여러 명이 같은 과자 봉지를 두고 싸우는 상황에서, 한 명이 과자를 먹고 있는데 다른 사람이 "그만 먹어!"라고 외치면, 과자 봉지가 계속 "사용 중"이라고 표시되어 아무도 먹을 수 없게 되는 것과 같습니다. 이제는 "그만 먹어!"라고 하면 과자 봉지가 다시 사용 가능해지고, 과자가 다 떨어지면 봉지가 사라져도 문제없이 다른 과자를 찾을 수 있게 됩니다!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. IGatherable 인터페이스 확장</h4>
                <p>자원 수집을 중단할 수 있는 `AbortGather` 메서드 추가:</p>
                
                <div class="code-block">
<pre><code>// IGatherable.cs - 자원 수집 인터페이스 확장
// 수집 중단 기능 추가

namespace GameDevTV.RTS.Environment
{
    // IGatherable: 수집 가능한 객체를 위한 인터페이스
    // interface: 클래스가 구현해야 하는 메서드들을 정의
    public interface IGatherable
    {
        // Supply: 자원의 타입 (ScriptableObject)
        // SupplySO: 자원 타입을 정의하는 ScriptableObject
        public SupplySO Supply { get; }
        
        // Amount: 자원의 남은 양
        // int: 정수형 (자원의 개수)
        public int Amount { get; }
        
        // IsBusy: 자원이 다른 Worker에 의해 사용 중인지 확인
        // bool: 불린형 (true/false)
        public bool IsBusy { get; }

        // BeginGather: 자원 수집을 시작하는 메서드
        // bool: 수집 시작 성공 여부 반환
        public bool BeginGather();
        
        // EndGather: 자원 수집을 완료하는 메서드
        // int: 수집한 자원의 양 반환
        public int EndGather();
        
        // AbortGather: 자원 수집을 중단하는 메서드 (새로 추가)
        // void: 반환값 없음
        // 수집 중단 시 자원을 해제하지만 수집량은 주지 않음
        public void AbortGather();
    }
}</code></pre>
                </div>
                
                <h4>2. GatherableSupply.AbortGather 구현</h4>
                <p>자원 수집 중단 시 `IsBusy` 상태만 해제하는 간단한 구현:</p>
                
                <div class="code-block">
<pre><code>// GatherableSupply.cs - 자원 수집 중단 메서드 구현
// AbortGather 메서드 추가

using UnityEngine;

namespace GameDevTV.RTS.Environment
{
    // GatherableSupply: MonoBehaviour를 상속하고 IGatherable 인터페이스를 구현
    // MonoBehaviour: Unity의 기본 컴포넌트 클래스
    // IGatherable: 수집 가능한 객체 인터페이스
    public class GatherableSupply : MonoBehaviour, IGatherable
    {
        // Supply: 자원의 타입 (ScriptableObject)
        // [field: SerializeField]: Unity Inspector에서 설정 가능하도록 하는 속성
        // get; private set;: 외부에서는 읽기만 가능, 내부에서만 설정 가능
        [field: SerializeField] 
        public SupplySO Supply { get; private set; }
        
        // Amount: 자원의 남은 양
        [field: SerializeField] 
        public int Amount { get; private set; }
        
        // IsBusy: 자원이 다른 Worker에 의해 사용 중인지 확인
        [field: SerializeField] 
        public bool IsBusy { get; private set; }

        // Start: Unity의 생명주기 메서드 (게임 시작 시 한 번 호출)
        private void Start()
        {
            // Supply.MaxAmount: ScriptableObject에서 정의된 최대 자원량
            // Amount: 현재 자원량을 최대량으로 초기화
            Amount = Supply.MaxAmount;
        }

        // BeginGather: 자원 수집을 시작하는 메서드
        // bool: 수집 시작 성공 여부 반환
        public bool BeginGather()
        {
            // IsBusy: 이미 다른 Worker가 사용 중인지 확인
            if (IsBusy)
            {
                // false: 수집 시작 실패 (이미 사용 중)
                return false;
            }

            // IsBusy: 자원을 사용 중으로 표시
            IsBusy = true;
            
            // true: 수집 시작 성공
            return true;
        }

        // EndGather: 자원 수집을 완료하는 메서드
        // int: 수집한 자원의 양 반환
        public int EndGather()
        {
            // IsBusy: 자원 사용 상태 해제
            IsBusy = false;
            
            // Mathf.Min: 두 값 중 작은 값 반환
            // Supply.AmountPerGather: 한 번에 수집할 수 있는 자원량
            // Amount: 현재 남은 자원량
            int amountGathered = Mathf.Min(Supply.AmountPerGather, Amount);
            
            // Amount: 수집한 만큼 자원량 감소
            Amount -= amountGathered;

            // Amount <= 0: 자원이 모두 고갈된 경우
            if (Amount <= 0)
            {
                // Destroy: GameObject를 파괴
                // gameObject: 현재 컴포넌트가 붙어있는 GameObject
                Destroy(gameObject);
            }

            // amountGathered: 실제로 수집한 자원량 반환
            return amountGathered;
        }

        // AbortGather: 자원 수집을 중단하는 메서드 (새로 추가)
        // void: 반환값 없음
        public void AbortGather()
        {
            // IsBusy: 자원 사용 상태만 해제
            // 자원량은 감소시키지 않음 (수집 중단이므로)
            IsBusy = false;
        }
    }
}</code></pre>
                </div>
                
                <h4>3. GatherSuppliesAction 개선</h4>
                <p>`OnEnd` 메서드에서 성공/실패에 따른 적절한 처리:</p>
                
                <div class="code-block">
<pre><code>// GatherSuppliesAction.cs - 개선된 자원 수집 액션
// OnEnd 메서드에서 성공/실패에 따른 적절한 처리

using GameDevTV.RTS.Environment;
using System;
using Unity.Behavior;
using UnityEngine;
using Action = Unity.Behavior.Action;
using Unity.Properties;

namespace GameDevTV.RTS.Behavior
{
    // Serializable: Unity에서 직렬화 가능하도록 하는 속성
    // GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성
    [Serializable, GeneratePropertyBag]
    
    // NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의
    [NodeDescription(
        name: "Gather Supplies", 
        story: "[Unit] gathers [Amount] supplies from [GatherableSupplies] .", 
        category: "Action/Units", 
        id: "3b941d7ae99d1e36b7d806875379c977"
    )]
    
    // GatherSuppliesAction: 자원 수집을 수행하는 액션 노드
    public partial class GatherSuppliesAction : Action
    {
        // Unit: 자원을 수집할 유닛의 GameObject
        [SerializeReference] 
        public BlackboardVariable<GameObject> Unit;
        
        // Amount: 수집한 자원의 양을 저장할 변수
        [SerializeReference] 
        public BlackboardVariable<int> Amount;
        
        // GatherableSupplies: 수집할 자원 객체
        [SerializeReference] 
        public BlackboardVariable<GatherableSupply> GatherableSupplies;

        // enterTime: 수집 시작 시간을 저장할 변수
        // private: 클래스 내부에서만 접근 가능
        // float: 실수형 (시간)
        private float enterTime;

        // OnStart: 액션이 시작될 때 호출되는 메서드
        protected override Status OnStart()
        {
            // GatherableSupplies.Value == null: 자원 객체가 없는 경우
            if (GatherableSupplies.Value == null) 
            {
                // Failure: 자원이 없으므로 수집 불가
                return Status.Failure;
            }
            
            // Time.time: 게임 시작 후 경과 시간
            // enterTime: 수집 시작 시간 저장
            enterTime = Time.time;

            // BeginGather: 자원 수집 시작
            // GatherableSupplies.Value: 수집할 자원 객체
            GatherableSupplies.Value.BeginGather();
            
            // Running: 수집을 시작했으므로 계속 실행 중
            return Status.Running;
        }

        // OnUpdate: 액션이 실행 중일 때 매 프레임 호출되는 메서드
        protected override Status OnUpdate()
        {
            // Supply.BaseGatherTime: 자원 타입별 기본 수집 시간
            // enterTime: 수집 시작 시간
            // Time.time: 현재 시간
            // <=: 작거나 같음 비교 연산자
            if (GatherableSupplies.Value.Supply.BaseGatherTime + enterTime <= Time.time)
            {
                // Success: 수집 시간이 완료됨
                return Status.Success;
            }

            // Running: 아직 수집 중
            return Status.Running;
        }

        // OnEnd: 액션이 종료될 때 호출되는 메서드 (성공/실패 관계없이 항상 호출)
        // protected override void: 상위 클래스의 메서드를 재정의
        protected override void OnEnd()
        {
            // GatherableSupplies.Value == null: 자원 객체가 파괴된 경우
            if (GatherableSupplies.Value == null) 
            {
                // return: 아무것도 하지 않고 종료
                return;
            }

            // CurrentStatus: 현재 액션의 상태
            // Status.Success: 성공적으로 완료된 경우
            if (CurrentStatus == Status.Success)
            {
                // EndGather: 자원 수집 완료 처리
                // Amount.Value: Blackboard의 Amount 변수에 수집량 저장
                Amount.Value = GatherableSupplies.Value.EndGather();
            }
            else
            {
                // AbortGather: 자원 수집 중단 처리
                // 새로운 명령을 받거나 실패한 경우 자원을 해제
                GatherableSupplies.Value.AbortGather();
            }
        }
    }
}</code></pre>
                </div>
                
                <h4>4. MoveToGatherableSupplyAction 강화</h4>
                <p>자원이 파괴된 경우를 대비한 null 체크와 자동 재타겟팅:</p>
                
                <div class="code-block">
<pre><code>// MoveToGatherableSupplyAction.cs - 강화된 자원 이동 액션
// null 체크와 자동 재타겟팅 기능 추가

using GameDevTV.RTS.Environment;
using System;
using Unity.Behavior;
using UnityEngine;
using Action = Unity.Behavior.Action;
using Unity.Properties;
using UnityEngine.AI;
using System.Collections.Generic;
using System.Linq;
using GameDevTV.RTS.Utilities;

namespace GameDevTV.RTS.Behavior
{
    [Serializable, GeneratePropertyBag]
    [NodeDescription(
        name: "Move to GatherableSupply", 
        story: "[Agent] moves to [Supply] or nearby not busy supply.", 
        category: "Action/Navigation", 
        id: "b9248f874f11b1a358e671809522dbfc"
    )]
    
    public partial class MoveToGatherableSupplyAction : Action
    {
        [SerializeReference] 
        public BlackboardVariable<GameObject> Agent;
        
        [SerializeReference] 
        public BlackboardVariable<GatherableSupply> Supply;
        
        [SerializeReference] 
        public BlackboardVariable<float> SearchRadius = new(7f);

        // agent: NavMesh Agent 컴포넌트 참조
        private NavMeshAgent agent;
        
        // suppliesMask: Supplies 레이어 마스크
        private LayerMask suppliesMask;
        
        // supplySO: 자원 타입을 저장하는 변수 (자원이 파괴되어도 타입 정보 유지)
        private SupplySO supplySO;

        protected override Status OnStart()
        {
            // LayerMask.GetMask: "Supplies" 레이어의 마스크를 가져옴
            suppliesMask = LayerMask.GetMask("Supplies");

            // HasValidInputs: 입력값들이 유효한지 확인
            if (!HasValidInputs())
            {
                // Failure: 유효하지 않은 입력
                return Status.Failure;
            }

            // GetTargetPosition: 현재 자원의 최적 위치를 계산
            Vector3 targetPosition = GetTargetPosition();

            // SetDestination: NavMesh Agent의 목표 위치 설정
            agent.SetDestination(targetPosition);
            
            // Running: 이동을 시작했으므로 계속 실행 중
            return Status.Running;
        }

        protected override Status OnUpdate()
        {
            // remainingDistance: 목표까지 남은 거리
            // stoppingDistance: 정지 거리
            if (agent.remainingDistance >= agent.stoppingDistance)
            {
                // Running: 아직 목표에 도달하지 못함
                return Status.Running;
            }

            // Supply.Value != null: 자원 객체가 존재하는 경우
            // !Supply.Value.IsBusy: 자원이 사용 중이 아님
            // Supply.Value.Amount > 0: 자원의 양이 남아있음
            if (Supply.Value != null && 
                !Supply.Value.IsBusy && 
                Supply.Value.Amount > 0)
            {
                // Success: 자원이 사용 가능하고 양이 남아있음
                return Status.Success;
            }
            
            // FindNearbyNotBusyColliders: 주변의 사용 가능한 자원들을 찾음
            Collider[] colliders = FindNearbyNotBusyColliders();

            // colliders.Length > 0: 사용 가능한 자원이 있는 경우
            if (colliders.Length > 0)
            {
                // Array.Sort: 거리 기준으로 정렬
                // ClosestColliderComparer: 거리 비교자
                Array.Sort(colliders, new ClosestColliderComparer(agent.transform.position));

                // colliders[0]: 가장 가까운 자원
                // GetComponent: Collider에서 GatherableSupply 컴포넌트를 가져옴
                // Supply.Value: Blackboard의 Supply 변수에 새로운 자원 설정
                Supply.Value = colliders[0].GetComponent<GatherableSupply>();
                
                // SetDestination: 새로운 자원으로 이동
                agent.SetDestination(GetTargetPosition());
                
                // Running: 새로운 자원으로 이동 중
                return Status.Running;
            }

            // Failure: 주변에 사용 가능한 자원이 없음
            return Status.Failure;
        }

        // HasValidInputs: 입력값들이 유효한지 확인하는 private 메서드
        private bool HasValidInputs()
        {
            // TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴
            // Supply.Value == null && supplySO == null: 자원 객체도 없고 타입 정보도 없는 경우
            if (!Agent.Value.TryGetComponent(out agent) || 
                (Supply.Value == null && supplySO == null))
            {
                // false: 유효하지 않은 입력
                return false;
            }

            // Supply.Value != null: 자원 객체가 존재하는 경우
            if (Supply.Value != null)
            {
                // supplySO: 자원 타입 정보 저장 (자원이 파괴되어도 타입 정보 유지)
                supplySO = Supply.Value.Supply;
            }
            else
            {
                // FindNearbyNotBusyColliders: 주변의 사용 가능한 자원들을 찾음
                Collider[] colliders = FindNearbyNotBusyColliders();
                
                // colliders.Length > 0: 사용 가능한 자원이 있는 경우
                if (colliders.Length > 0)
                {
                    // Array.Sort: 거리 기준으로 정렬
                    Array.Sort(colliders, new ClosestColliderComparer(agent.transform.position));
                    
                    // colliders[0]: 가장 가까운 자원
                    // GetComponent: Collider에서 GatherableSupply 컴포넌트를 가져옴
                    Supply.Value = colliders[0].GetComponent<GatherableSupply>();
                }
                else
                {
                    // false: 주변에 사용 가능한 자원이 없음
                    return false;
                }
            }

            // true: 모든 입력이 유효함
            return true;
        }

        // FindNearbyNotBusyColliders: 주변의 사용 가능한 자원들을 찾는 private 메서드
        private Collider[] FindNearbyNotBusyColliders()
        {
            // Physics.OverlapSphere: 구체 모양의 영역에서 Collider들을 찾음
            // .Where(): LINQ 확장 메서드로 조건에 맞는 요소만 필터링
            // .ToArray(): 필터링된 결과를 배열로 변환
            return Physics.OverlapSphere(
                agent.transform.position,
                SearchRadius,
                suppliesMask
            ).Where(collider =>
                    // TryGetComponent: Collider에서 GatherableSupply 컴포넌트를 가져옴
                    collider.TryGetComponent(out GatherableSupply supply)
                    // !supply.IsBusy: 자원이 사용 중이 아님
                    && !supply.IsBusy
                    // supply.Supply.Equals: 같은 타입의 자원인지 확인
                    // supplySO: 저장된 자원 타입 정보
                    && supply.Supply.Equals(supplySO)
            ).ToArray();
        }

        // GetTargetPosition: 최적의 목표 위치를 계산하는 private 메서드
        private Vector3 GetTargetPosition()
        {
            // targetPosition: 계산될 목표 위치를 저장할 변수
            Vector3 targetPosition;
            
            // TryGetComponent: Supply GameObject에서 Collider 컴포넌트를 가져옴
            if (Supply.Value.TryGetComponent(out Collider collider))
            {
                // ClosestPoint: Collider에서 가장 가까운 지점을 계산
                targetPosition = collider.ClosestPoint(agent.transform.position);
            }
            else
            {
                // Collider가 없는 경우: GameObject의 transform.position 사용
                targetPosition = Supply.Value.transform.position;
            }

            // 계산된 목표 위치 반환
            return targetPosition;
        }
    }
}</code></pre>
                </div>
                
                <h4>5. MoveToTargetGameObjectAction 보호</h4>
                <p>간단한 null 체크로 GameObject 파괴 상황 대비:</p>
                
                <div class="code-block">
<pre><code>// MoveToTargetGameObjectAction.cs - null 체크 추가
// GameObject 파괴 상황 대비

protected override Status OnStart()
{
    // TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴
    // TargetGameObject.Value == null: 목표 GameObject가 파괴된 경우
    if (!Agent.Value.TryGetComponent(out agent) || 
        TargetGameObject.Value == null)
    {
        // Failure: NavMeshAgent가 없거나 목표 GameObject가 파괴됨
        return Status.Failure;
    }

    // GetTargetPosition: 목표 GameObject의 최적 위치를 계산
    Vector3 targetPosition = GetTargetPosition();

    // Vector3.Distance: 두 점 사이의 거리 계산
    // agent.stoppingDistance: NavMesh Agent의 정지 거리
    if (Vector3.Distance(agent.transform.position, targetPosition) <= agent.stoppingDistance)
    {
        // Success: 이미 목표 위치에 도달한 경우
        return Status.Success;
    }

    // SetDestination: NavMesh Agent의 목표 위치 설정
    agent.SetDestination(targetPosition);
    
    // Running: 이동을 시작했으므로 계속 실행 중
    return Status.Running;
}</code></pre>
                </div>
                
                <h3>🔄 해결된 엣지 케이스들</h3>
                <ol>
                    <li><strong>명령 변경 시 자원 잠금</strong>: `AbortGather`로 자원을 즉시 해제</li>
                    <li><strong>자원 파괴 후 참조</strong>: null 체크로 안전한 처리</li>
                    <li><strong>자원 고갈 시 대안 탐색</strong>: 자동으로 주변 자원 재탐색</li>
                    <li><strong>타입 정보 유지</strong>: `supplySO` 변수로 자원 타입 보존</li>
                    <li><strong>우선순위 조정</strong>: Gather 명령이 Move 명령보다 우선</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>안정성 향상</strong>: null 참조 예외 없이 안전한 동작</li>
                    <li><strong>사용자 경험 개선</strong>: 우클릭으로 바로 자원 수집 가능</li>
                    <li><strong>자동 복구</strong>: 자원이 고갈되어도 자동으로 다른 자원 탐색</li>
                    <li><strong>명령 중단 처리</strong>: 새로운 명령 시 이전 자원을 안전하게 해제</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>OnEnd 보장</strong>: Behavior Tree의 OnEnd는 항상 호출됨</li>
                    <li><strong>상태 기반 처리</strong>: CurrentStatus에 따른 성공/실패 구분</li>
                    <li><strong>타입 정보 캐싱</strong>: 자원 파괴 후에도 타입 정보 유지</li>
                    <li><strong>자동 재타겟팅</strong>: 자원이 없어지면 주변 자원 자동 탐색</li>
                    <li><strong>Guardian Pattern</strong>: null 체크로 안전한 처리</li>
                </ul>
            </div>
        </div>
        
        <!-- Lecture 46: Animation Synchronization -->
        <div class="lecture-section">
            <h2 id="lecture-46">강의 46: Animation Synchronization - 애니메이션 동기화</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>기존 시스템에서는 Worker들이 움직이고 자원을 수집할 때 애니메이션이 제대로 동기화되지 않았습니다. RTS 게임에서는 많은 유닛들이 동시에 움직이므로 성능을 고려한 효율적인 애니메이션 시스템이 필요합니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 연극에서 배우들이 대사만 하고 몸짓은 하지 않는 것과 같아요! 이제는 Worker들이 실제로 뛰어다니고 자원을 캐는 모습을 보여줍니다. 마치 실제 사람처럼 걸을 때는 걷는 애니메이션, 뛸 때는 뛰는 애니메이션, 일할 때는 일하는 애니메이션을 보여줘요!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. AnimationConstants 유틸리티 클래스</h4>
                <p>애니메이션 파라미터 해시를 캐싱하여 성능을 최적화:</p>
                
                <div class="code-block">
<span class="comment">// AnimationConstants.cs - 애니메이션 파라미터 상수</span>
<span class="comment">// 성능 최적화를 위한 해시 캐싱</span>

<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Utilities
{
    <span class="comment">// AnimationConstants: 애니메이션 파라미터 해시를 캐싱하는 정적 클래스</span>
    <span class="comment">// static: 인스턴스를 생성하지 않고 클래스 이름으로 직접 접근</span>
    <span class="comment">// public: 외부에서 접근 가능</span>
    <span class="keyword">public static class</span> <span class="class-name">AnimationConstants</span>
    {
        <span class="comment">// SPEED: 이동 속도 애니메이션 파라미터</span>
        <span class="comment">// public static int: 정적 정수 변수 (모든 인스턴스가 공유)</span>
        <span class="comment">// Animator.StringToHash: 문자열을 정수 해시로 변환 (성능 최적화)</span>
        <span class="comment">// "Speed": Animator Controller에서 정의된 파라미터 이름</span>
        <span class="keyword">public static int</span> <span class="property-name">SPEED</span> = <span class="class-name">Animator</span>.StringToHash(<span class="string">"Speed"</span>);
        
        <span class="comment">// IS_GATHERING: 자원 수집 상태 애니메이션 파라미터</span>
        <span class="comment">// "IsGathering": Animator Controller에서 정의된 불린 파라미터 이름</span>
        <span class="keyword">public static int</span> <span class="property-name">IS_GATHERING</span> = <span class="class-name">Animator</span>.StringToHash(<span class="string">"IsGathering"</span>);
    }
}</div>
                
                <h4>2. MoveToTargetLocationAction 애니메이션 동기화</h4>
                <p>이동 액션에서 속도 기반 애니메이션 제어:</p>
                
                <div class="code-block">
<span class="comment">// MoveToTargetLocationAction.cs - 애니메이션 동기화가 추가된 이동 액션</span>
<span class="comment">// NavMesh Agent의 속도에 따른 애니메이션 제어</span>

<span class="keyword">using</span> System;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> Action = Unity.Behavior.Action;
<span class="keyword">using</span> Unity.Properties;
<span class="keyword">using</span> UnityEngine.AI;
<span class="keyword">using</span> GameDevTV.RTS.Utilities;

<span class="keyword">namespace</span> GameDevTV.RTS.Behavior
{
    [Serializable, GeneratePropertyBag]
    [NodeDescription(
        name: <span class="string">"Move to Target Location"</span>, 
        story: <span class="string">"[Agent] moves to [TargetLocation] ."</span>, 
        category: <span class="string">"Action/Navigation"</span>, 
        id: <span class="string">"c96373f56a4b683d189e362795d042fa"</span>
    )]
    
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetLocationAction</span> : <span class="class-name">Action</span>
    {
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">Vector3</span>&gt; <span class="property-name">TargetLocation</span>;

        <span class="comment">// agent: NavMesh Agent 컴포넌트 참조</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> agent;
        
        <span class="comment">// animator: Animator 컴포넌트 참조 (새로 추가)</span>
        <span class="keyword">private</span> <span class="class-name">Animator</span> animator;

        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnStart()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="keyword">if</span> (!Agent.Value.TryGetComponent(<span class="keyword">out</span> agent))
            {
                <span class="comment">// Failure: NavMeshAgent가 없는 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Failure;
            }

            <span class="comment">// TryGetComponent: Agent GameObject에서 Animator 컴포넌트를 가져옴</span>
            <span class="comment">// Animator가 없어도 액션은 실패하지 않음 (애니메이션만 없을 뿐)</span>
            Agent.Value.TryGetComponent(<span class="keyword">out</span> animator);

            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.stoppingDistance: NavMesh Agent의 정지 거리</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.Distance(agent.transform.position, TargetLocation.Value) <= agent.stoppingDistance)
            {
                <span class="comment">// Success: 이미 목표 위치에 도달한 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Success;
            }

            <span class="comment">// SetDestination: NavMesh Agent의 목표 위치 설정</span>
            agent.SetDestination(TargetLocation.Value);

            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
        }

        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnUpdate()
        {
            <span class="comment">// animator != null: Animator 컴포넌트가 있는 경우</span>
            <span class="keyword">if</span> (animator != <span class="keyword">null</span>)
            {
                <span class="comment">// SetFloat: Animator의 float 파라미터 설정</span>
                <span class="comment">// AnimationConstants.SPEED: 캐싱된 해시 값 (성능 최적화)</span>
                <span class="comment">// agent.velocity.magnitude: NavMesh Agent의 현재 속도 크기</span>
                animator.SetFloat(<span class="class-name">AnimationConstants</span>.SPEED, agent.velocity.magnitude);
            }
            
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="keyword">if</span> (agent.remainingDistance <= agent.stoppingDistance)
            {
                <span class="comment">// Success: 목표 위치에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Success;
            }

            <span class="comment">// Running: 아직 이동 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
        }

        <span class="comment">// OnEnd: 액션이 종료될 때 호출되는 메서드</span>
        <span class="keyword">protected override void</span> OnEnd()
        {
            <span class="comment">// animator != null: Animator 컴포넌트가 있는 경우</span>
            <span class="keyword">if</span> (animator != <span class="keyword">null</span>)
            {
                <span class="comment">// SetFloat: 속도를 0으로 설정하여 Idle 상태로 전환</span>
                <span class="comment">// 액션 종료 시 애니메이션을 정지 상태로 리셋</span>
                animator.SetFloat(<span class="class-name">AnimationConstants</span>.SPEED, <span class="number">0</span>);
            }
        }
    }
}</div>
                
                <h4>3. GatherSuppliesAction 애니메이션 동기화</h4>
                <p>자원 수집 액션에서 수집 상태 애니메이션 제어:</p>
                
                <div class="code-block">
<span class="comment">// GatherSuppliesAction.cs - 애니메이션 동기화가 추가된 자원 수집 액션</span>
<span class="comment">// 수집 상태에 따른 애니메이션 제어</span>

<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> System;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> Action = Unity.Behavior.Action;
<span class="keyword">using</span> Unity.Properties;
<span class="keyword">using</span> GameDevTV.RTS.Utilities;

<span class="keyword">namespace</span> GameDevTV.RTS.Behavior
{
    [Serializable, GeneratePropertyBag]
    [NodeDescription(
        name: <span class="string">"Gather Supplies"</span>, 
        story: <span class="string">"[Unit] gathers [Amount] supplies from [GatherableSupplies] ."</span>, 
        category: <span class="string">"Action/Units"</span>, 
        id: <span class="string">"3b941d7ae99d1e36b7d806875379c977"</span>
    )]
    
    <span class="keyword">public partial class</span> <span class="class-name">GatherSuppliesAction</span> : <span class="class-name">Action</span>
    {
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Unit</span>;
        
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; <span class="property-name">Amount</span>;
        
        [SerializeReference] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GatherableSupply</span>&gt; <span class="property-name">GatherableSupplies</span>;

        <span class="comment">// animator: Animator 컴포넌트 참조 (새로 추가)</span>
        <span class="keyword">private</span> <span class="class-name">Animator</span> animator;
        
        <span class="comment">// enterTime: 수집 시작 시간을 저장할 변수</span>
        <span class="keyword">private</span> <span class="keyword">float</span> enterTime;

        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnStart()
        {
            <span class="comment">// GatherableSupplies.Value == null: 자원 객체가 없는 경우</span>
            <span class="keyword">if</span> (GatherableSupplies.Value == <span class="keyword">null</span>) 
            {
                <span class="comment">// Failure: 자원이 없으므로 수집 불가</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Failure;
            }
            
            <span class="comment">// Time.time: 게임 시작 후 경과 시간</span>
            <span class="comment">// enterTime: 수집 시작 시간 저장</span>
            enterTime = <span class="class-name">Time</span>.time;

            <span class="comment">// TryGetComponent: Unit GameObject에서 Animator 컴포넌트를 가져옴</span>
            <span class="keyword">if</span> (Unit.Value.TryGetComponent(<span class="keyword">out</span> animator))
            {
                <span class="comment">// SetBool: Animator의 bool 파라미터 설정</span>
                <span class="comment">// AnimationConstants.IS_GATHERING: 캐싱된 해시 값</span>
                <span class="comment">// true: 수집 상태로 애니메이션 전환</span>
                animator.SetBool(<span class="class-name">AnimationConstants</span>.IS_GATHERING, <span class="keyword">true</span>);
            }
            
            <span class="comment">// BeginGather: 자원 수집 시작</span>
            GatherableSupplies.Value.BeginGather();
            
            <span class="comment">// Running: 수집을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
        }

        <span class="keyword">protected override</span> <span class="class-name">Status</span> OnUpdate()
        {
            <span class="comment">// Supply.BaseGatherTime: 자원 타입별 기본 수집 시간</span>
            <span class="comment">// enterTime: 수집 시작 시간</span>
            <span class="comment">// Time.time: 현재 시간</span>
            <span class="keyword">if</span> (GatherableSupplies.Value.Supply.BaseGatherTime + enterTime <= <span class="class-name">Time</span>.time)
            {
                <span class="comment">// Success: 수집 시간이 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.Success;
            }

            <span class="comment">// Running: 아직 수집 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.Running;
        }

        <span class="keyword">protected override void</span> OnEnd()
        {
            <span class="comment">// animator != null: Animator 컴포넌트가 있는 경우</span>
            <span class="keyword">if</span> (animator != <span class="keyword">null</span>)
            {
                <span class="comment">// SetBool: 수집 상태를 false로 설정하여 일반 상태로 전환</span>
                <span class="comment">// 액션 종료 시 애니메이션을 정지 상태로 리셋</span>
                animator.SetBool(<span class="class-name">AnimationConstants</span>.IS_GATHERING, <span class="keyword">false</span>);
            }

            <span class="comment">// GatherableSupplies.Value == null: 자원 객체가 파괴된 경우</span>
            <span class="keyword">if</span> (GatherableSupplies.Value == <span class="keyword">null</span>) 
            {
                <span class="comment">// return: 아무것도 하지 않고 종료</span>
                <span class="keyword">return</span>;
            }

            <span class="comment">// CurrentStatus: 현재 액션의 상태</span>
            <span class="comment">// Status.Success: 성공적으로 완료된 경우</span>
            <span class="keyword">if</span> (CurrentStatus == <span class="class-name">Status</span>.Success)
            {
                <span class="comment">// EndGather: 자원 수집 완료 처리</span>
                <span class="comment">// Amount.Value: Blackboard의 Amount 변수에 수집량 저장</span>
                Amount.Value = GatherableSupplies.Value.EndGather();
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// AbortGather: 자원 수집 중단 처리</span>
                <span class="comment">// 새로운 명령을 받거나 실패한 경우 자원을 해제</span>
                GatherableSupplies.Value.AbortGather();
            }
        }
    }
}</div>
                
                <h3>🔄 동작 과정</h3>
                <ol>
                    <li><strong>이동 시작</strong>: `MoveToTargetLocationAction`에서 `agent.velocity.magnitude`로 속도 설정</li>
                    <li><strong>이동 중</strong>: 매 프레임마다 현재 속도에 따라 걷기/뛰기 애니메이션 전환</li>
                    <li><strong>이동 완료</strong>: `OnEnd`에서 속도를 0으로 설정하여 Idle 상태로 전환</li>
                    <li><strong>수집 시작</strong>: `GatherSuppliesAction`에서 `IsGathering = true`로 수집 애니메이션 시작</li>
                    <li><strong>수집 완료</strong>: `OnEnd`에서 `IsGathering = false`로 일반 상태로 전환</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>시각적 피드백</strong>: Worker들이 실제로 움직이고 일하는 모습을 보여줌</li>
                    <li><strong>상태 구분</strong>: 이동, 수집, 대기 상태를 애니메이션으로 명확히 구분</li>
                    <li><strong>자연스러운 동작</strong>: 속도에 따른 걷기/뛰기 전환이 자연스러움</li>
                    <li><strong>성능 최적화</strong>: Update 루프 없이 Behavior Tree 액션에서만 애니메이션 제어</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>성능 최적화</strong>: `Animator.StringToHash`로 해시 캐싱하여 문자열 비교 비용 제거</li>
                    <li><strong>Behavior Tree 통합</strong>: 애니메이션 로직을 Behavior Tree 액션에 통합</li>
                    <li><strong>Update 루프 제거</strong>: MonoBehaviour Update 없이 액션 기반 애니메이션 제어</li>
                    <li><strong>안전한 처리</strong>: Animator가 없어도 액션은 정상 동작</li>
                    <li><strong>상태 관리</strong>: `OnEnd`에서 애니메이션 상태를 안전하게 리셋</li>
                </ul>
                
                <h3>📊 성능 비교</h3>
                <div class="info-box">
                    <h4>🚀 성능 최적화 전략</h4>
                    <ul>
                        <li><strong>기존 방식</strong>: 각 유닛마다 Update 루프에서 애니메이션 파라미터 설정</li>
                        <li><strong>개선된 방식</strong>: Behavior Tree 액션에서만 필요할 때 애니메이션 제어</li>
                        <li><strong>해시 캐싱</strong>: `StringToHash`로 문자열 비교 비용 제거</li>
                        <li><strong>조건부 실행</strong>: Animator가 있을 때만 애니메이션 로직 실행</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- Lecture 47: Behavior Events -->
        <div class="lecture-section">
            <h2 id="lecture-47">강의 47: Behavior Events - Behavior Tree 이벤트 시스템</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>기존 시스템에서는 Worker가 자원을 수집해도 실제로 플레이어에게 자원이 전달되지 않았습니다. Behavior Tree 내부에서 일어나는 일과 게임의 나머지 부분(UI, 자원 저장소 등)을 연결하기 위해 Behavior Events 시스템이 필요합니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 우체부가 편지를 배달하는 것과 같아요! Worker가 자원을 수집하면 "편지(이벤트)"를 보내서 "우체부(Behavior Events)"가 게임의 다른 부분들에게 "자원을 수집했어요!"라고 알려줍니다. 그러면 UI가 업데이트되고 플레이어의 자원 저장소에 자원이 추가돼요!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. GatherSuppliesEventChannel</h4>
                <p>Behavior Tree에서 자원 수집 이벤트를 전송하는 이벤트 채널:</p>
                
                <div class="code-block">
<span class="comment">// GatherSuppliesEventChannel.cs - Behavior Tree 이벤트 채널</span>
<span class="comment">// Behavior Tree와 게임 코드 간의 통신을 위한 델리게이트 시스템</span>

<span class="keyword">using</span> System;
<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> Unity.Properties;

<span class="keyword">namespace</span> GameDevTV.RTS.Behavior
{
    <span class="comment">// CreateAssetMenu: Unity 에디터에서 생성 가능한 ScriptableObject</span>
    <span class="comment">// EventChannelDescription: Behavior Tree 에디터에서 이벤트 채널 설명</span>
    [CreateAssetMenu(menuName = <span class="string">"Behavior/Event Channels/GatherSuppliesEventChannel"</span>)]
    [Serializable, GeneratePropertyBag]
    [EventChannelDescription(
        name: <span class="string">"GatherSuppliesEventChannel"</span>, 
        message: <span class="string">"[Self] gathers [Amount] [Supplies] ."</span>, 
        category: <span class="string">"Events"</span>, 
        id: <span class="string">"005c0743a2e96d985e33a1feeef75d29"</span>
    )]
    
    <span class="comment">// GatherSuppliesEventChannel: 자원 수집 이벤트를 전송하는 이벤트 채널</span>
    <span class="comment">// EventChannelBase: Unity Behavior Tree의 기본 이벤트 채널 클래스</span>
    <span class="keyword">public partial class</span> <span class="class-name">GatherSuppliesEventChannel</span> : <span class="class-name">EventChannelBase</span>
    {
        <span class="comment">// GatherSuppliesEventChannelEventHandler: 자원 수집 이벤트 델리게이트</span>
        <span class="comment">// delegate: 함수 포인터와 같은 역할을 하는 타입</span>
        <span class="comment">// GameObject Self: 이벤트를 발생시킨 객체</span>
        <span class="comment">// int Amount: 수집한 자원의 양</span>
        <span class="comment">// SupplySO Supplies: 수집한 자원의 타입</span>
        <span class="keyword">public delegate void</span> <span class="class-name">GatherSuppliesEventChannelEventHandler</span>(<span class="class-name">GameObject</span> Self, <span class="keyword">int</span> Amount, <span class="class-name">SupplySO</span> Supplies);
        
        <span class="comment">// Event: 실제 이벤트 델리게이트 인스턴스</span>
        <span class="comment">// event: 외부에서 직접 할당할 수 없도록 보호</span>
        <span class="keyword">public event</span> <span class="class-name">GatherSuppliesEventChannelEventHandler</span> Event;

        <span class="comment">// SendEventMessage: 이벤트를 전송하는 public 메서드</span>
        <span class="comment">// ?.: null 조건부 연산자 (Event가 null이 아니면 Invoke 호출)</span>
        <span class="keyword">public void</span> SendEventMessage(<span class="class-name">GameObject</span> Self, <span class="keyword">int</span> Amount, <span class="class-name">SupplySO</span> Supplies)
        {
            Event?.Invoke(Self, Amount, Supplies);
        }

        <span class="comment">// SendEventMessage: Behavior Tree에서 호출되는 오버라이드 메서드</span>
        <span class="comment">// BlackboardVariable[]: Behavior Tree의 Blackboard 변수 배열</span>
        <span class="keyword">public override void</span> SendEventMessage(<span class="class-name">BlackboardVariable</span>[] messageData)
        {
            <span class="comment">// messageData[0]: Self (GameObject)</span>
            <span class="comment">// as: 안전한 타입 캐스팅 (실패 시 null 반환)</span>
            <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; SelfBlackboardVariable = messageData[<span class="number">0</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt;;
            <span class="comment">// ?: null 조건부 연산자</span>
            <span class="comment">// ??: null 병합 연산자 (왼쪽이 null이면 오른쪽 값 사용)</span>
            <span class="keyword">var</span> Self = SelfBlackboardVariable != <span class="keyword">null</span> ? SelfBlackboardVariable.Value : <span class="keyword">default</span>(<span class="class-name">GameObject</span>);

            <span class="comment">// messageData[1]: Amount (int)</span>
            <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; AmountBlackboardVariable = messageData[<span class="number">1</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt;;
            <span class="keyword">var</span> Amount = AmountBlackboardVariable != <span class="keyword">null</span> ? AmountBlackboardVariable.Value : <span class="keyword">default</span>(<span class="keyword">int</span>);

            <span class="comment">// messageData[2]: Supplies (SupplySO)</span>
            <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">SupplySO</span>&gt; SuppliesBlackboardVariable = messageData[<span class="number">2</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">SupplySO</span>&gt;;
            <span class="keyword">var</span> Supplies = SuppliesBlackboardVariable != <span class="keyword">null</span> ? SuppliesBlackboardVariable.Value : <span class="keyword">default</span>(<span class="class-name">SupplySO</span>);

            <span class="comment">// Event?.Invoke: 이벤트가 등록되어 있으면 호출</span>
            Event?.Invoke(Self, Amount, Supplies);
        }

        <span class="comment">// CreateEventHandler: Behavior Tree에서 이벤트 핸들러 생성</span>
        <span class="comment">// callback: 이벤트 발생 시 실행될 콜백 함수</span>
        <span class="keyword">public override</span> <span class="class-name">Delegate</span> CreateEventHandler(<span class="class-name">BlackboardVariable</span>[] vars, <span class="class-name">System.Action</span> callback)
        {
            <span class="comment">// 람다 표현식으로 델리게이트 생성</span>
            <span class="class-name">GatherSuppliesEventChannelEventHandler</span> del = (Self, Amount, Supplies) =>
            {
                <span class="comment">// vars[0]: Self 변수에 값 할당</span>
                <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; var0 = vars[<span class="number">0</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt;;
                <span class="keyword">if</span> (var0 != <span class="keyword">null</span>)
                    var0.Value = Self;

                <span class="comment">// vars[1]: Amount 변수에 값 할당</span>
                <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; var1 = vars[<span class="number">1</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt;;
                <span class="keyword">if</span> (var1 != <span class="keyword">null</span>)
                    var1.Value = Amount;

                <span class="comment">// vars[2]: Supplies 변수에 값 할당</span>
                <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">SupplySO</span>&gt; var2 = vars[<span class="number">2</span>] <span class="keyword">as</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">SupplySO</span>&gt;;
                <span class="keyword">if</span> (var2 != <span class="keyword">null</span>)
                    var2.Value = Supplies;

                <span class="comment">// callback: 이벤트 발생 시 실행될 콜백</span>
                callback();
            };
            <span class="keyword">return</span> del;
        }

        <span class="comment">// RegisterListener: 이벤트 리스너 등록</span>
        <span class="keyword">public override void</span> RegisterListener(<span class="class-name">Delegate</span> del)
        {
            <span class="comment">// +=: 이벤트에 델리게이트 추가</span>
            Event += del <span class="keyword">as</span> <span class="class-name">GatherSuppliesEventChannelEventHandler</span>;
        }

        <span class="comment">// UnregisterListener: 이벤트 리스너 해제</span>
        <span class="keyword">public override void</span> UnregisterListener(<span class="class-name">Delegate</span> del)
        {
            <span class="comment">// -=: 이벤트에서 델리게이트 제거</span>
            Event -= del <span class="keyword">as</span> <span class="class-name">GatherSuppliesEventChannelEventHandler</span>;
        }
    }
}</div>
                
                <h4>2. SupplyEvent</h4>
                <p>Event Bus를 통해 전송되는 자원 수집 이벤트:</p>
                
                <div class="code-block">
<span class="comment">// SupplyEvent.cs - 자원 수집 이벤트</span>
<span class="comment">// Event Bus를 통해 게임의 다른 부분에 자원 수집 알림</span>

<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> GameDevTV.RTS.EventBus;

<span class="keyword">namespace</span> GameDevTV.RTS.Events
{
    <span class="comment">// SupplyEvent: 자원 수집 이벤트 구조체</span>
    <span class="comment">// struct: 값 타입으로 성능 최적화</span>
    <span class="comment">// IEvent: Event Bus 시스템의 인터페이스</span>
    <span class="keyword">public struct</span> <span class="class-name">SupplyEvent</span> : <span class="class-name">IEvent</span>
    {
        <span class="comment">// Amount: 수집한 자원의 양</span>
        <span class="comment">// { get; private set; }: 읽기 전용 프로퍼티</span>
        <span class="keyword">public int</span> <span class="property-name">Amount</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        
        <span class="comment">// Supply: 수집한 자원의 타입</span>
        <span class="keyword">public</span> <span class="class-name">SupplySO</span> <span class="property-name">Supply</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }

        <span class="comment">// 생성자: 이벤트 데이터 초기화</span>
        <span class="comment">// amount: 수집한 자원의 양</span>
        <span class="comment">// supply: 수집한 자원의 타입</span>
        <span class="keyword">public</span> <span class="class-name">SupplyEvent</span>(<span class="keyword">int</span> amount, <span class="class-name">SupplySO</span> supply)
        {
            <span class="comment">// Amount: 수집한 자원의 양 저장</span>
            Amount = amount;
            <span class="comment">// Supply: 수집한 자원의 타입 저장</span>
            Supply = supply;
        }
    }
}</div>
                
                <h4>3. Worker 이벤트 처리</h4>
                <p>Worker에서 Behavior Tree 이벤트를 받아 Event Bus로 전달:</p>
                
                <div class="code-block">
<span class="comment">// Worker.cs - Behavior Tree 이벤트 처리</span>
<span class="comment">// Behavior Tree와 Event Bus 간의 브리지 역할</span>

<span class="keyword">using</span> GameDevTV.RTS.Behavior;
<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> GameDevTV.RTS.EventBus;
<span class="keyword">using</span> GameDevTV.RTS.Events;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;

                <div class="code-block">
<span class="comment">// Worker.cs - Behavior Tree 이벤트 처리</span>
<span class="comment">// Behavior Tree와 Event Bus 간의 브리지 역할</span>

<span class="keyword">using</span> GameDevTV.RTS.Behavior;
<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> GameDevTV.RTS.EventBus;
<span class="keyword">using</span> GameDevTV.RTS.Events;
<span class="keyword">using</span> Unity.Behavior;
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// Worker: AbstractUnit을 상속하고 IGatherer 인터페이스를 구현</span>
    <span class="keyword">public class</span> <span class="class-name">Worker</span> : <span class="class-name">AbstractUnit</span>, <span class="class-name">IGatherer</span>
    {
        <span class="comment">// Start: Unity 생명주기 메서드</span>
        <span class="comment">// protected override: 상위 클래스의 메서드를 재정의</span>
        <span class="keyword">protected override void</span> Start()
        {
            <span class="comment">// base.Start(): 상위 클래스의 Start 메서드 호출</span>
            <span class="comment">// AbstractUnit의 Start에서 Behavior Tree 초기화</span>
            base.Start();
            
            <span class="comment">// GetVariable: Behavior Tree의 Blackboard에서 변수 가져오기</span>
            <span class="comment">// "GatherSuppliesEvent": Blackboard에 등록된 이벤트 채널 이름</span>
            <span class="comment">// out: 출력 매개변수로 변수에 값 할당</span>
            <span class="keyword">if</span> (graphAgent.GetVariable(<span class="string">"GatherSuppliesEvent"</span>, <span class="keyword">out</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GatherSuppliesEventChannel</span>&gt; eventChannelVariable))
            {
                <span class="comment">// Event +=: 이벤트에 핸들러 등록</span>
                <span class="comment">// HandleGatherSupplies: 이벤트 발생 시 호출될 메서드</span>
                eventChannelVariable.Value.Event += HandleGatherSupplies;
            }
        }

        <span class="comment">// Gather: 자원 수집을 시작하는 메서드</span>
        <span class="comment">// public: 외부에서 호출 가능</span>
        <span class="comment">// void: 반환값 없음</span>
        <span class="comment">// GatherableSupply supply: 수집할 자원 객체</span>
        <span class="keyword">public void</span> Gather(<span class="class-name">GatherableSupply</span> supply)
        {
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Supply": Blackboard 변수 이름</span>
            <span class="comment">// supply: 설정할 값 (GatherableSupply 객체)</span>
            graphAgent.SetVariableValue(<span class="string">"Supply"</span>, supply);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "TargetGameObject": Blackboard 변수 이름</span>
            <span class="comment">// supply.gameObject: 수집할 자원의 GameObject</span>
            graphAgent.SetVariableValue(<span class="string">"TargetGameObject"</span>, supply.gameObject);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Command": Blackboard 변수 이름</span>
            <span class="comment">// UnitCommands.Gather: 수집 명령</span>
            graphAgent.SetVariableValue(<span class="string">"Command"</span>, <span class="class-name">UnitCommands</span>.Gather);
        }

        <span class="comment">// HandleGatherSupplies: Behavior Tree 이벤트 핸들러</span>
        <span class="comment">// private: 클래스 내부에서만 호출 가능</span>
        <span class="comment">// void: 반환값 없음</span>
        <span class="comment">// GameObject self: 이벤트를 발생시킨 객체</span>
        <span class="comment">// int amount: 수집한 자원의 양</span>
        <span class="comment">// SupplySO supply: 수집한 자원의 타입</span>
        <span class="keyword">private void</span> HandleGatherSupplies(<span class="class-name">GameObject</span> self, <span class="keyword">int</span> amount, <span class="class-name">SupplySO</span> supply)
        {
            <span class="comment">// Bus<SupplyEvent>.Raise: Event Bus를 통해 SupplyEvent 전송</span>
            <span class="comment">// new SupplyEvent: 새로운 SupplyEvent 인스턴스 생성</span>
            <span class="comment">// amount: 수집한 자원의 양</span>
            <span class="comment">// supply: 수집한 자원의 타입</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">SupplyEvent</span>&gt;.Raise(<span class="keyword">new</span> <span class="class-name">SupplyEvent</span>(amount, supply));
        }
    }
}</div>
                
                <h3>🔄 동작 과정</h3>
                <ol>
                    <li><strong>자원 수집 완료</strong>: `GatherSuppliesAction`에서 자원 수집 완료</li>
                    <li><strong>이벤트 전송</strong>: Behavior Tree에서 `GatherSuppliesEventChannel`로 이벤트 전송</li>
                    <li><strong>Worker 수신</strong>: `Worker.HandleGatherSupplies`에서 이벤트 수신</li>
                    <li><strong>Event Bus 전달</strong>: `SupplyEvent`를 Event Bus로 전송</li>
                    <li><strong>게임 시스템 업데이트</strong>: UI, 자원 저장소 등이 이벤트 수신하여 업데이트</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>자원 전달</strong>: Worker가 수집한 자원이 실제로 플레이어에게 전달됨</li>
                    <li><strong>UI 업데이트</strong>: 자원 수집 시 UI가 실시간으로 업데이트</li>
                    <li><strong>시스템 연결</strong>: Behavior Tree와 게임 시스템 간의 완전한 연결</li>
                    <li><strong>확장성</strong>: 새로운 이벤트 타입을 쉽게 추가 가능</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>델리게이트 시스템</strong>: Behavior Tree 내부의 이벤트 통신</li>
                    <li><strong>Event Bus 연동</strong>: Behavior Tree와 게임 시스템 간의 브리지</li>
                    <li><strong>타입 안전성</strong>: 강타입 이벤트 시스템으로 런타임 오류 방지</li>
                    <li><strong>디커플링</strong>: Behavior Tree와 게임 로직의 완전한 분리</li>
                    <li><strong>확장성</strong>: 새로운 이벤트 채널을 쉽게 추가 가능</li>
                </ul>
                
                <h3>📊 이벤트 흐름도</h3>
                <div class="info-box">
                    <h4>🔄 Behavior Tree → Event Bus 흐름</h4>
                    <ol>
                        <li><strong>GatherSuppliesAction</strong>: 자원 수집 완료</li>
                        <li><strong>Send Event Message</strong>: Behavior Tree에서 이벤트 전송</li>
                        <li><strong>GatherSuppliesEventChannel</strong>: 이벤트 채널을 통해 전달</li>
                        <li><strong>Worker.HandleGatherSupplies</strong>: 이벤트 수신</li>
                        <li><strong>SupplyEvent</strong>: Event Bus로 이벤트 전송</li>
                        <li><strong>게임 시스템</strong>: UI, 자원 저장소 등 업데이트</li>
                    </ol>
                </div>
            </div>
        </div>
        
        <!-- Lecture 48: Player Supplies -->
        <div class="lecture-section">
            <h2 id="lecture-48">강의 48: Player Supplies - 플레이어 자원 시스템</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>Worker가 자원을 수집해도 플레이어가 실제로 얼마나 가지고 있는지 알 수 없었습니다. UI에 자원 수량을 표시하고, 게임의 다른 부분에서도 쉽게 접근할 수 있는 자원 관리 시스템이 필요합니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 지갑에 돈이 얼마나 있는지 확인하는 것과 같아요! Worker가 자원을 수집하면 "지갑(Supplies)"에 자원이 쌓이고, 화면 위쪽에 "미네랄: 50개, 가스: 30개"처럼 보여줍니다. 그리고 게임의 다른 부분에서도 "미네랄이 충분한가?"를 쉽게 확인할 수 있어요!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. Supplies 클래스</h4>
                <p>플레이어의 자원을 관리하고 UI를 업데이트하는 MonoBehaviour:</p>
                
                <div class="code-block">
<span class="comment">// Supplies.cs - 플레이어 자원 관리 시스템</span>
<span class="comment">// 자원 수량 관리 및 UI 업데이트</span>

<span class="keyword">using</span> System;
<span class="keyword">using</span> GameDevTV.RTS.Environment;
<span class="keyword">using</span> GameDevTV.RTS.EventBus;
<span class="keyword">using</span> GameDevTV.RTS.Events;
<span class="keyword">using</span> TMPro;
<span class="keyword">using</span> UnityEngine;

<span class="keyword">namespace</span> GameDevTV.RTS.Player
{
    <span class="comment">// Supplies: 플레이어의 자원을 관리하는 MonoBehaviour</span>
    <span class="comment">// MonoBehaviour: Unity의 기본 컴포넌트 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">Supplies</span> : <span class="class-name">MonoBehaviour</span>
    {
        <span class="comment">// UI 텍스트 컴포넌트들</span>
        <span class="comment">// [SerializeField]: Unity Inspector에서 설정 가능</span>
        <span class="comment">// private: 클래스 내부에서만 접근 가능</span>
        <span class="comment">// TextMeshProUGUI: TextMeshPro UI 텍스트 컴포넌트</span>
        [SerializeField] <span class="keyword">private</span> <span class="class-name">TextMeshProUGUI</span> mineralsText;
        [SerializeField] <span class="keyword">private</span> <span class="class-name">TextMeshProUGUI</span> gasText;
        [SerializeField] <span class="keyword">private</span> <span class="class-name">TextMeshProUGUI</span> populationText;

        <span class="comment">// 자원 타입 ScriptableObject 참조</span>
        <span class="comment">// SupplySO: 자원 타입을 정의하는 ScriptableObject</span>
        [SerializeField] <span class="keyword">private</span> <span class="class-name">SupplySO</span> mineralsSO;
        [SerializeField] <span class="keyword">private</span> <span class="class-name">SupplySO</span> gasSO;

        <span class="comment">// 정적 자원 변수들</span>
        <span class="comment">// public static: 어디서든 접근 가능한 정적 변수</span>
        <span class="comment">// { get; private set; }: 외부에서는 읽기만 가능, 내부에서만 수정 가능</span>
        <span class="comment">// int: 정수형 (자원의 개수)</span>
        <span class="keyword">public static int</span> <span class="property-name">Minerals</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        <span class="keyword">public static int</span> <span class="property-name">Gas</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        <span class="keyword">public static int</span> <span class="property-name">Population</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }
        <span class="keyword">public static int</span> <span class="property-name">PopulationLimit</span> { <span class="keyword">get</span>; <span class="keyword">private set</span>; }

        <span class="comment">// Awake: Unity 생명주기 메서드 (게임 시작 시 한 번 호출)</span>
        <span class="comment">// private: 클래스 내부에서만 호출 가능</span>
        <span class="comment">// void: 반환값 없음</span>
        <span class="keyword">private void</span> Awake()
        {
            <span class="comment">// Bus<SupplyEvent>.OnEvent: Event Bus의 SupplyEvent 이벤트</span>
            <span class="comment">// +=: 이벤트에 핸들러 등록</span>
            <span class="comment">// HandleSupplyEvent: 이벤트 발생 시 호출될 메서드</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">SupplyEvent</span>&gt;.OnEvent += HandleSupplyEvent;
        }

        <span class="comment">// OnDestroy: Unity 생명주기 메서드 (객체 파괴 시 호출)</span>
        <span class="keyword">private void</span> OnDestroy()
        {
            <span class="comment">// -=: 이벤트에서 핸들러 해제 (메모리 누수 방지)</span>
            <span class="class-name">Bus</span>&lt;<span class="class-name">SupplyEvent</span>&gt;.OnEvent -= HandleSupplyEvent;
        }

        <span class="comment">// HandleSupplyEvent: 자원 수집 이벤트 핸들러</span>
        <span class="comment">// SupplyEvent evt: 수집된 자원 정보</span>
        <span class="keyword">private void</span> HandleSupplyEvent(<span class="class-name">SupplyEvent</span> evt)
        {
            <span class="comment">// evt.Supply.Equals(mineralsSO): 수집된 자원이 미네랄인지 확인</span>
            <span class="comment">// Equals: 객체 비교 메서드</span>
            <span class="keyword">if</span> (evt.Supply.Equals(mineralsSO))
            {
                <span class="comment">// Minerals += evt.Amount: 미네랄 수량 증가</span>
                <span class="comment">// +=: 복합 할당 연산자 (Minerals = Minerals + evt.Amount)</span>
                Minerals += evt.Amount;
                
                <span class="comment">// mineralsText.SetText: UI 텍스트 업데이트</span>
                <span class="comment">// Minerals.ToString(): 정수를 문자열로 변환</span>
                mineralsText.SetText(Minerals.ToString());
            }
            <span class="comment">// else if: 첫 번째 조건이 거짓일 때만 확인</span>
            <span class="keyword">else if</span> (evt.Supply.Equals(gasSO))
            {
                <span class="comment">// Gas += evt.Amount: 가스 수량 증가</span>
                Gas += evt.Amount;
                
                <span class="comment">// gasText.SetText: 가스 UI 텍스트 업데이트</span>
                gasText.SetText(Gas.ToString());
            }
        }
    }
}</div>
                
                <h3>🔄 동작 과정</h3>
                <ol>
                    <li><strong>자원 수집</strong>: Worker가 자원을 수집하여 `SupplyEvent` 발생</li>
                    <li><strong>이벤트 수신</strong>: `Supplies` 클래스가 Event Bus에서 이벤트 수신</li>
                    <li><strong>자원 타입 확인</strong>: 수집된 자원이 미네랄인지 가스인지 확인</li>
                    <li><strong>수량 증가</strong>: 해당 자원의 정적 변수에 수집량 추가</li>
                    <li><strong>UI 업데이트</strong>: TextMeshPro UI에 새로운 수량 표시</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>실시간 자원 표시</strong>: 화면 상단에 현재 보유 자원 수량 표시</li>
                    <li><strong>전역 접근</strong>: 게임의 어느 곳에서나 `Supplies.Minerals`로 자원 확인 가능</li>
                    <li><strong>UI 동기화</strong>: 자원 수집과 UI 업데이트가 자동으로 동기화</li>
                    <li><strong>확장성</strong>: 새로운 자원 타입을 쉽게 추가 가능</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>정적 변수</strong>: `static` 키워드로 전역 접근 가능</li>
                    <li><strong>캡슐화</strong>: `{ get; private set; }`로 외부에서 수정 방지</li>
                    <li><strong>Event Bus 연동</strong>: Behavior Tree 이벤트와 자동 연결</li>
                    <li><strong>메모리 관리</strong>: `OnDestroy`에서 이벤트 구독 해제</li>
                    <li><strong>타입 안전성</strong>: `SupplySO`로 자원 타입 구분</li>
                </ul>
                
                <h3>📊 시스템 구조</h3>
                <div class="info-box">
                    <h4>🔄 자원 흐름도</h4>
                    <ol>
                        <li><strong>Worker 수집</strong>: 자원 수집 완료</li>
                        <li><strong>SupplyEvent</strong>: Event Bus로 이벤트 전송</li>
                        <li><strong>Supplies 수신</strong>: 이벤트 핸들러에서 수신</li>
                        <li><strong>자원 타입 확인</strong>: 미네랄/가스 구분</li>
                        <li><strong>정적 변수 업데이트</strong>: Minerals/Gas 증가</li>
                        <li><strong>UI 텍스트 업데이트</strong>: 화면에 새로운 수량 표시</li>
                    </ol>
                </div>
                
                <h3>🎯 사용 예시</h3>
                <div class="code-block">
<span class="comment">// 다른 스크립트에서 자원 확인 예시</span>

<span class="comment">// 건물 건설 시 자원 확인</span>
<span class="keyword">if</span> (<span class="class-name">Supplies</span>.Minerals >= <span class="number">100</span>)
{
    <span class="comment">// 건물 건설 가능</span>
    BuildBuilding();
}

<span class="comment">// 유닛 생산 시 자원 확인</span>
<span class="keyword">if</span> (<span class="class-name">Supplies</span>.Minerals >= <span class="number">50</span> && <span class="class-name">Supplies</span>.Gas >= <span class="number">25</span>)
{
    <span class="comment">// 유닛 생산 가능</span>
    ProduceUnit();
}</div>
            </div>
        </div>
        
        <!-- Lecture 49: Conditional Branches -->
        <div class="lecture-section">
            <h2 id="lecture-49">강의 49: Conditional Branches - 조건부 분기</h2>
            
            <div class="lecture-content">
                <h3>🎯 왜 필요한가?</h3>
                <p>현재 Worker는 자원을 수집하라는 명령을 받으면 무조건 수집을 시도합니다. 하지만 StarCraft 2처럼 이미 자원을 가지고 있는 Worker는 더 이상 수집하지 않고 바로 Command Post로 돌아가야 합니다. 이를 위해 조건부 분기가 필요합니다.</p>
                
                <h3>🧠 초딩도 이해하기 쉬운 설명</h3>
                <p>마치 가방에 이미 과자가 있는데 또 과자를 사러 가는 것과 같아요! 똑똑한 사람은 "어? 이미 과자가 있네?"라고 생각하고 바로 집으로 돌아가죠. Worker도 마찬가지로 이미 자원을 가지고 있으면 더 수집하지 않고 바로 Command Post로 돌아가야 해요!</p>
                
                <h3>🔧 핵심 구현</h3>
                
                <h4>1. Behavior Tree 구조 개선</h4>
                <p>기존의 단순한 수집 시퀀스를 조건부 분기로 개선:</p>
                
                <div class="info-box">
                    <h4>🔄 기존 구조 (문제점)</h4>
                    <ol>
                        <li><strong>SetAgentAvoidance</strong>: 회피 품질 설정</li>
                        <li><strong>MoveToGatherableSupply</strong>: 자원으로 이동</li>
                        <li><strong>GatherSupplies</strong>: 자원 수집</li>
                        <li><strong>FindClosestCommandPost</strong>: Command Post 찾기</li>
                        <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                        <li><strong>RaiseEvent</strong>: 이벤트 발생</li>
                    </ol>
                    <p><strong>문제</strong>: 이미 자원을 가지고 있어도 무조건 수집 시도</p>
                </div>
                
                <div class="info-box">
                    <h4>✅ 개선된 구조 (조건부 분기)</h4>
                    <ol>
                        <li><strong>SetAgentAvoidance</strong>: 회피 품질 설정</li>
                        <li><strong>MoveToGatherableSupply</strong>: 자원으로 이동</li>
                        <li><strong>Conditional Branch</strong>: 조건부 분기</li>
                        <ul>
                            <li><strong>True (자원 없음)</strong>: 수집 시퀀스 실행</li>
                            <li><strong>False (자원 있음)</strong>: 바로 Command Post로 이동</li>
                        </ul>
                        <li><strong>Wait For Any</strong>: 두 경로 합치기</li>
                        <li><strong>FindClosestCommandPost</strong>: Command Post 찾기</li>
                        <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                        <li><strong>RaiseEvent</strong>: 이벤트 발생</li>
                    </ol>
                </div>
                
                <h4>2. Conditional Branch 설정</h4>
                <p>Behavior Tree의 새로운 노드들을 활용한 조건부 분기:</p>
                
                <div class="code-block">
<span class="comment">// Conditional Branch 설정</span>
<span class="comment">// Inspector에서 조건 설정</span>

<span class="comment">// Variable Condition: 변수 조건</span>
<span class="comment">// Variable: SupplyAmountHeld (Blackboard 변수)</span>
<span class="comment">// Comparison: Equal To</span>
<span class="comment">// Value: 0</span>

<span class="comment">// 결과:</span>
<span class="comment">// - True: SupplyAmountHeld == 0 (자원이 없음) → 수집 시퀀스 실행</span>
<span class="comment">// - False: SupplyAmountHeld != 0 (자원이 있음) → 바로 Command Post로 이동</span></div>
                
                <h4>3. Flow Control 노드들</h4>
                <p>Behavior Tree의 새로운 흐름 제어 노드들:</p>
                
                <div class="code-block">
<span class="comment">// Flow Control 노드들</span>

<span class="comment">// 1. Conditional Branch</span>
<span class="comment">// - 조건에 따라 True/False 경로로 분기</span>
<span class="comment">// - Variable Condition으로 Blackboard 변수 확인</span>

<span class="comment">// 2. Wait For All</span>
<span class="comment">// - 모든 부모 노드가 시작되면 자식 실행</span>
<span class="comment">// - 병렬 실행에 적합</span>

<span class="comment">// 3. Wait For Any</span>
<span class="comment">// - 하나의 부모 노드라도 시작되면 자식 실행</span>
<span class="comment">// - 조건부 분기 후 경로 합치기에 적합</span></div>
                
                <h3>🔄 동작 과정</h3>
                <ol>
                    <li><strong>자원 수집 명령</strong>: Worker가 Gather 명령을 받음</li>
                    <li><strong>회피 설정</strong>: SetAgentAvoidance로 이동 품질 설정</li>
                    <li><strong>자원으로 이동</strong>: MoveToGatherableSupply로 자원 위치로 이동</li>
                    <li><strong>조건 확인</strong>: Conditional Branch에서 SupplyAmountHeld 확인</li>
                    <li><strong>분기 실행</strong>:
                        <ul>
                            <li><strong>자원 없음 (True)</strong>: GatherSupplies로 자원 수집</li>
                            <li><strong>자원 있음 (False)</strong>: 수집 없이 바로 다음 단계로</li>
                        </ul>
                    </li>
                    <li><strong>경로 합치기</strong>: Wait For Any로 두 경로 합치기</li>
                    <li><strong>Command Post로 이동</strong>: FindClosestCommandPost → MoveToTargetGameObject</li>
                    <li><strong>이벤트 발생</strong>: RaiseEvent로 수집 완료 알림</li>
                </ol>
                
                <h3>🎮 게임에서의 효과</h3>
                <ul>
                    <li><strong>지능적인 Worker</strong>: 이미 자원을 가지고 있으면 수집하지 않음</li>
                    <li><strong>효율적인 이동</strong>: 불필요한 수집 과정 생략</li>
                    <li><strong>StarCraft 2와 유사한 동작</strong>: 실제 RTS 게임과 같은 행동 패턴</li>
                    <li><strong>자원 관리 최적화</strong>: Worker의 자원 운반 효율성 향상</li>
                </ul>
                
                <h3>🔧 기술적 특징</h3>
                <ul>
                    <li><strong>조건부 분기</strong>: Conditional Branch로 상황에 따른 분기</li>
                    <li><strong>Variable Condition</strong>: Blackboard 변수 기반 조건 확인</li>
                    <li><strong>Flow Control</strong>: Wait For Any로 경로 합치기</li>
                    <li><strong>코드 변경 없음</strong>: Behavior Tree 에디터만으로 구현</li>
                    <li><strong>확장성</strong>: 다른 조건들도 쉽게 추가 가능</li>
                </ul>
                
                <h3>📊 시스템 구조</h3>
                <div class="info-box">
                    <h4>🔄 조건부 분기 흐름도</h4>
                    <ol>
                        <li><strong>Gather 명령</strong>: Worker가 수집 명령 수신</li>
                        <li><strong>SetAgentAvoidance</strong>: 이동 품질 설정</li>
                        <li><strong>MoveToGatherableSupply</strong>: 자원으로 이동</li>
                        <li><strong>Conditional Branch</strong>: SupplyAmountHeld 확인</li>
                        <li><strong>True 경로</strong>: 자원 없음 → 수집 시퀀스</li>
                        <li><strong>False 경로</strong>: 자원 있음 → 수집 생략</li>
                        <li><strong>Wait For Any</strong>: 두 경로 합치기</li>
                        <li><strong>Command Post 이동</strong>: 자원 반환</li>
                    </ol>
                </div>
                
                <h3>🎯 Behavior Tree 노드 활용</h3>
                <div class="code-block">
<span class="comment">// Behavior Tree 노드 활용법</span>

<span class="comment">// 1. Conditional Branch</span>
<span class="comment">// - 조건: Variable Condition</span>
<span class="comment">// - 변수: SupplyAmountHeld</span>
<span class="comment">// - 비교: Equal To 0</span>

<span class="comment">// 2. Wait For Any</span>
<span class="comment">// - 용도: 조건부 분기 후 경로 합치기</span>
<span class="comment">// - 동작: 하나의 부모라도 완료되면 실행</span>

<span class="comment">// 3. Sequence (True 경로)</span>
<span class="comment">// - GatherSupplies: 자원 수집</span>
<span class="comment">// - 수집 후 SupplyAmountHeld 증가</span>

<span class="comment">// 4. Single Node (False 경로)</span>
<span class="comment">// - 수집 없이 바로 다음 단계로</span>
<span class="comment">// - 이미 가지고 있는 자원 활용</span></div>
                
                <h3>🔍 StarCraft 2 참고</h3>
                <div class="info-box">
                    <h4>🎮 StarCraft 2의 Worker 동작</h4>
                    <ul>
                        <li><strong>드론(Drone)</strong>: Zerg의 Worker 유닛</li>
                        <li><strong>지능적인 수집</strong>: 이미 자원을 가지고 있으면 수집하지 않음</li>
                        <li><strong>즉시 반환</strong>: 자원을 가지고 있으면 바로 Hatchery로 돌아감</li>
                        <li><strong>효율성</strong>: 불필요한 수집 과정 생략</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
