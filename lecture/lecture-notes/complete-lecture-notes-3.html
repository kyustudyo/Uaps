<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URTS 강의 노트 - 3페이지</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .lecture-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }
        
        .lecture-title {
            color: #2c3e50;
            margin-top: 0;
            font-size: 1.8em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .lecture-goal {
            background: #e8f4fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .lecture-goal h3 {
            color: #2980b9;
            margin-top: 0;
        }
        
        .content-section {
            margin: 25px 0;
        }
        
        .content-section h3 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        
        .tech-stack {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #17a2b8;
        }
        
        .tech-stack h4 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .content-list {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .content-list li {
            margin: 8px 0;
            color: #2c3e50;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .code-block .comment {
            color: #95a5a6;
            font-style: italic;
        }
        
        .code-block .keyword {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .code-block .class-name {
            color: #3498db;
            font-weight: bold;
        }
        
        .code-block .method-name {
            color: #f39c12;
            font-weight: bold;
        }
        
        .code-block .property-name {
            color: #2ecc71;
            font-weight: bold;
        }
        
        .code-block .field-name {
            color: #9b59b6;
        }
        
        .code-block .string {
            color: #e67e22;
        }
        
        .code-block .number {
            color: #e67e22;
        }
        
        .code-block .parameter {
            color: #f39c12;
        }
        
        .info-box {
            background: #e8f5e8;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .info-box h4 {
            color: #27ae60;
            margin-top: 0;
        }
        
        .warning-box {
            background: #fdf2e9;
            border: 2px solid #e67e22;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .warning-box h4 {
            color: #e67e22;
            margin-top: 0;
        }
        
        .toc {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .toc h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        .toc ul {
            list-style: none;
            padding: 0;
        }
        
        .toc li {
            margin: 8px 0;
        }
        
        .toc a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        
        .toc a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 URTS 강의 노트</h1>
            <p>Unity RTS 게임 개발 강의 정리 - 3페이지</p>
        </div>
        
        <div class="content">
            <!-- 목차 -->
            <div class="toc">
                <h3>📚 목차</h3>
                <ul>
                    <li><a href="#lecture-39">🎯 강의 39: Unit Commands in Behavior Tree</a></li>
                    <li><a href="#lecture-40">⛏️ 강의 40: Gathering Supplies with Behavior Tree</a></li>
                    <li><a href="#lecture-41">🏠 강의 41: Return Supplies to Command Post</a></li>
                    <li><a href="#lecture-42">🚶 강의 42: Smooth Gathering Movement</a></li>
                    <li><a href="#lecture-43">🎯 강의 43: Pick Better Gathering Locations</a></li>
                </ul>
            </div>

            <!-- 강의 39: Unit Commands in Behavior Tree (Behavior Tree에서 유닛 명령) -->
            <div class="lecture-section" id="lecture-39">
                <h2 class="lecture-title">🎯 강의 39: Unit Commands in Behavior Tree (Behavior Tree에서 유닛 명령)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">명령 체계 구축</strong>: <span style="color: #2c3e50;">유닛의 다양한 행동을 체계적으로 관리할 수 있는 명령 시스템</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">확장성 향상</strong>: <span style="color: #2c3e50;">새로운 유닛 기능을 쉽게 추가할 수 있는 구조</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">반응성 개선</strong>: <span style="color: #2c3e50;">명령 변경 시 즉시 반응하는 유닛 시스템</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">코드 분리</strong>: <span style="color: #2c3e50;">Behavior Tree와 명령 로직의 명확한 분리</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🎯 명령이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">게임에서 유닛에게 "이동해!", "멈춰!", "공격해!" 같은 지시를 내리는 시스템이에요. 마치 리모컨으로 TV를 조작하는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 왜 필요한가요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>다양한 행동</strong>: 유닛이 할 수 있는 여러 가지 행동을 관리해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>즉시 반응</strong>: 새로운 명령을 내리면 바로 행동을 바꿔요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>체계적 관리</strong>: 모든 명령을 하나의 시스템으로 관리해요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">집에서 "TV 켜줘!", "라디오 꺼줘!" 같은 명령을 내리는 것처럼, 게임에서도 유닛에게 명령을 내려요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>UnitCommands 열거형 생성 및 설정</li>
                        <li>Behavior Tree에서 Switch 노드 활용</li>
                        <li>StopAgentAction 커스텀 노드 구현</li>
                        <li>StopCommand 액션 베이스 구현</li>
                        <li>명령 변경 시 즉시 반응하는 시스템</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🎯 명령 체계 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>UnitCommands</strong>: 유닛 명령 열거형 (Stop, Move)</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기 처리</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>StopAgentAction</strong>: 유닛 정지 커스텀 노드</li>
                            <li><strong>StopCommand</strong>: 정지 명령 액션 베이스</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 명령 처리 플로우</h4>
                        <ol class="content-list">
                            <li><strong>명령 설정</strong>: Blackboard에 명령 값 설정</li>
                            <li><strong>Abort 트리거</strong>: 명령 변경 시 현재 실행 중단</li>
                            <li><strong>Switch 분기</strong>: 명령에 따라 다른 브랜치 실행</li>
                            <li><strong>액션 실행</strong>: 해당 명령의 행동 수행</li>
                            <li><strong>상태 관리</strong>: 명령 완료 또는 대기</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 UnitCommands 열거형</h3>
                    
                    <div class="code-block">
<span class="comment">// UnitCommands.cs - 유닛 명령 열거형</span>
<span class="comment">// BlackboardEnum: Unity Behavior Tree에서 사용할 수 있는 열거형</span>

<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// BlackboardEnum: Unity Behavior Tree의 Blackboard에서 사용할 수 있도록 하는 속성</span>
    <span class="comment">// 이 속성이 있으면 Behavior Tree 에디터에서 이 열거형을 선택할 수 있음</span>
    [<span class="class-name">BlackboardEnum</span>]
    
    <span class="comment">// UnitCommands: 유닛이 수행할 수 있는 명령들의 열거형</span>
    <span class="comment">// enum: 상수들의 집합을 정의하는 C# 키워드</span>
    <span class="keyword">public enum</span> <span class="class-name">UnitCommands</span>
    {
        <span class="comment">// Stop: 유닛을 정지시키는 명령</span>
        <span class="comment">// 첫 번째 값이므로 기본값은 0</span>
        <span class="property-name">Stop</span>,
        
        <span class="comment">// Move: 유닛을 이동시키는 명령</span>
        <span class="comment">// 두 번째 값이므로 기본값은 1</span>
        <span class="property-name">Move</span>
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🛑 StopAgentAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// StopAgentAction.cs - 유닛 정지 액션 노드</span>
<span class="comment">// Unity Behavior Tree의 커스텀 액션 노드</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트 (Agent는 Blackboard 변수)</span>
    <span class="comment">// category: 노드가 속할 카테고리</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Stop Agent"</span>, <span class="parameter">story</span>: <span class="string">"[Agent] stops moving."</span>, <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, <span class="parameter">id</span>: <span class="string">"b4af498b0656fc524515ec0b094c06a9"</span>)]
    
    <span class="comment">// StopAgentAction: 유닛을 정지시키는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">StopAgentAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 정지시킬 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// Agent.Value: Blackboard에서 가져온 GameObject</span>
            <span class="comment">// TryGetComponent: 해당 GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 agent 변수에 저장</span>
            <span class="keyword">if</span> (<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// ResetPath: NavMeshAgent의 현재 경로를 초기화하고 정지</span>
                <span class="comment">// 이동 중이던 유닛을 즉시 정지시킴</span>
                <span class="field-name">agent</span>.<span class="method-name">ResetPath</span>();
                
                <span class="comment">// Success: 액션이 성공적으로 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Failure: NavMeshAgent를 찾을 수 없어서 액션 실패</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 StopCommand 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// StopCommand.cs - 정지 명령 액션 베이스</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Commands</span>
{
    <span class="comment">// CreateAssetMenu: Unity Editor에서 이 클래스로부터 ScriptableObject를 생성할 수 있게 함</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: Unity Editor 메뉴에서의 경로</span>
    <span class="comment">// order: 메뉴에서의 순서 (낮을수록 위에 표시)</span>
    [<span class="class-name">CreateAssetMenu</span>(<span class="parameter">fileName</span> = <span class="string">"Stop Action"</span>, <span class="parameter">menuName</span> = <span class="string">"AI/Commands/Stop"</span>, <span class="parameter">order</span> = <span class="number">101</span>)]
    
    <span class="comment">// StopCommand: 유닛을 정지시키는 명령</span>
    <span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">StopCommand</span> : <span class="class-name">ActionBase</span>
    {
        <span class="comment">// CanHandle: 이 명령을 처리할 수 있는지 확인</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="comment">// 반환값: 이 명령을 처리할 수 있으면 true, 아니면 false</span>
        <span class="keyword">public override bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// context.Commandable: 명령을 받을 수 있는 객체</span>
            <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
            <span class="comment">// is: 타입 확인 연산자</span>
            <span class="keyword">return</span> <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">is</span> <span class="class-name">AbstractUnit</span>;
        }

        <span class="comment">// Handle: 실제 명령을 처리하는 메서드</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// AbstractUnit으로 타입 캐스팅</span>
            <span class="comment">// CanHandle에서 이미 AbstractUnit인지 확인했으므로 안전한 캐스팅</span>
            <span class="class-name">AbstractUnit</span> <span class="field-name">unit</span> = (<span class="class-name">AbstractUnit</span>)<span class="field-name">context</span>.<span class="property-name">Commandable</span>;
            
            <span class="comment">// unit.Stop(): 유닛의 정지 메서드 호출</span>
            <span class="comment">// 이 메서드는 Blackboard에 Stop 명령을 설정함</span>
            <span class="field-name">unit</span>.<span class="method-name">Stop</span>();
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔄 Behavior Tree 구조</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Stop 브랜치</strong>: StopAgentAction 실행</li>
                            <li><strong>Move 브랜치</strong>: MoveToTargetLocationAction 실행</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 즉시 반응 시스템</h4>
                        <ul class="content-list">
                            <li><strong>명령 변경 감지</strong>: Abort 노드가 명령 변경을 감지</li>
                            <li><strong>현재 실행 중단</strong>: 진행 중인 액션을 즉시 중단</li>
                            <li><strong>새 명령 실행</strong>: 변경된 명령에 따라 새로운 액션 시작</li>
                            <li><strong>상태 초기화</strong>: 이전 상태를 정리하고 새 상태로 전환</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>명령 체계</strong>: 유닛의 다양한 행동을 체계적으로 관리</p>
                        <p><strong>반응성</strong>: 플레이어 명령에 즉시 반응하는 유닛</p>
                        <p><strong>확장성</strong>: 새로운 유닛 기능을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 유닛이 동일한 명령 체계 사용</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>열거형 활용</strong>: 명령을 타입 안전하게 관리</p>
                        <p><strong>Switch 노드</strong>: 명령에 따른 분기 처리</p>
                        <p><strong>Abort 시스템</strong>: 명령 변경 시 즉시 반응</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>명령 순서</strong>: Blackboard 값 설정 후 명령 설정</p>
                        <p><strong>네임스페이스</strong>: 열거형 생성 후 네임스페이스 이동</p>
                        <p><strong>노드 연결</strong>: Behavior Tree에서 올바른 연결 확인</p>
                        <p><strong>상태 관리</strong>: 명령 변경 시 이전 상태 정리</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 명령</strong>: 이동, 정지, 공격, 수집, 건설 등</li>
                        <li><strong>명령 우선순위</strong>: 긴급 명령이 일반 명령보다 우선</li>
                        <li><strong>명령 취소</strong>: 진행 중인 명령을 취소할 수 있는 기능</li>
                        <li><strong>명령 대기열</strong>: 여러 명령을 순서대로 실행</li>
                        <li><strong>조건부 명령</strong>: 특정 조건에서만 실행되는 명령</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>UnitCommands</strong>: 유닛 명령 열거형</li>
                        <li><strong>BlackboardEnum</strong>: Behavior Tree에서 사용 가능한 열거형</li>
                        <li><strong>Switch 노드</strong>: 명령에 따른 분기 처리</li>
                        <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                        <li><strong>StopAgentAction</strong>: 유닛 정지 커스텀 노드</li>
                        <li><strong>StopCommand</strong>: 정지 명령 액션 베이스</li>
                        <li><strong>ResetPath</strong>: NavMeshAgent 경로 초기화</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 40: Gathering Supplies with Behavior Tree (Behavior Tree로 자원 수집) -->
            <div class="lecture-section" id="lecture-40">
                <h2 class="lecture-title">⛏️ 강의 40: Gathering Supplies with Behavior Tree (Behavior Tree로 자원 수집)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자원 수집 구현</strong>: <span style="color: #2c3e50;">Worker가 Behavior Tree를 사용해서 자원을 수집하는 시스템 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">명령 확장</strong>: <span style="color: #2c3e50;">기존 명령 체계에 Gather 명령 추가</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">커스텀 노드</strong>: <span style="color: #2c3e50;">자원 수집을 위한 전용 Behavior Tree 노드 생성</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">레이어 시스템</strong>: <span style="color: #2c3e50;">자원과 상호작용할 수 있는 레이어 설정</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>⛏️ 자원 수집이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker가 미네랄이나 가스에 가서 캐는 시스템이에요. 마치 광부가 광산에서 광물을 캐는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>명령 내리기</strong>: Worker에게 "자원 캐!" 명령을 내려요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>이동하기</strong>: Worker가 자원 위치로 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>수집하기</strong>: 자원을 캐서 가져와요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>반복하기</strong>: 자원이 남아있으면 계속 캐요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">집에서 "장보기 가!"라고 하면 가게에 가서 필요한 것들을 사는 것처럼, 게임에서도 Worker가 자원을 캐러 가요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>UnitCommands에 Gather 명령 추가</li>
                        <li>GatherCommand 액션 베이스 구현</li>
                        <li>GatherSuppliesAction 커스텀 노드 생성</li>
                        <li>Worker 클래스에 Gather 메서드 추가</li>
                        <li>Supplies 레이어 설정 및 상호작용 시스템</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>⛏️ 자원 수집 시스템 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>Gather 명령</strong>: UnitCommands 열거형에 추가</li>
                            <li><strong>GatherCommand</strong>: 자원 수집 명령 액션 베이스</li>
                            <li><strong>GatherSuppliesAction</strong>: 자원 수집 Behavior Tree 노드</li>
                            <li><strong>Worker.Gather()</strong>: Worker의 자원 수집 메서드</li>
                            <li><strong>Supplies 레이어</strong>: 자원과 상호작용할 수 있는 레이어</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 자원 수집 플로우</h4>
                        <ol class="content-list">
                            <li><strong>명령 내리기</strong>: Gather 버튼 클릭 후 자원 클릭</li>
                            <li><strong>이동</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 시작</strong>: BeginGather() 호출</li>
                            <li><strong>수집 대기</strong>: BaseGatherTime만큼 대기</li>
                            <li><strong>수집 완료</strong>: EndGather() 호출하여 자원 획득</li>
                            <li><strong>반복</strong>: 자원이 남아있으면 다시 수집</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 GatherCommand 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherCommand.cs - 자원 수집 명령 액션 베이스</span>
<span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Commands</span>
{
    <span class="comment">// CreateAssetMenu: Unity Editor에서 이 클래스로부터 ScriptableObject를 생성할 수 있게 함</span>
    <span class="comment">// fileName: 생성될 파일의 기본 이름</span>
    <span class="comment">// menuName: Unity Editor 메뉴에서의 경로</span>
    <span class="comment">// order: 메뉴에서의 순서 (낮을수록 위에 표시)</span>
    [<span class="class-name">CreateAssetMenu</span>(<span class="parameter">fileName</span> = <span class="string">"Gather Action"</span>, <span class="parameter">menuName</span> = <span class="string">"AI/Commands/Gather"</span>, <span class="parameter">order</span> = <span class="number">105</span>)]
    
    <span class="comment">// GatherCommand: 자원을 수집하는 명령</span>
    <span class="comment">// ActionBase: 모든 명령의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">GatherCommand</span> : <span class="class-name">ActionBase</span>
    {
        <span class="comment">// CanHandle: 이 명령을 처리할 수 있는지 확인</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="comment">// 반환값: 이 명령을 처리할 수 있으면 true, 아니면 false</span>
        <span class="keyword">public override bool</span> <span class="method-name">CanHandle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// context.Commandable: 명령을 받을 수 있는 객체</span>
            <span class="comment">// Worker: 자원을 수집할 수 있는 유닛</span>
            <span class="comment">// is: 타입 확인 연산자</span>
            <span class="keyword">return</span> <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">is</span> <span class="class-name">Worker</span> 
                <span class="comment">// context.Hit.collider: 클릭한 객체의 Collider</span>
                <span class="comment">// null이 아니어야 함 (뭔가를 클릭했는지 확인)</span>
                &amp;&amp; <span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span> != <span class="keyword">null</span> 
                <span class="comment">// TryGetComponent: 해당 객체에서 GatherableSupply 컴포넌트를 가져옴</span>
                <span class="comment">// out _: discard 패턴, 값을 받지만 사용하지 않음</span>
                &amp;&amp; <span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">GatherableSupply</span> <span class="keyword">_</span>);
        }

        <span class="comment">// Handle: 실제 명령을 처리하는 메서드</span>
        <span class="comment">// CommandContext: 명령의 컨텍스트 정보</span>
        <span class="keyword">public override void</span> <span class="method-name">Handle</span>(<span class="class-name">CommandContext</span> <span class="field-name">context</span>)
        {
            <span class="comment">// Worker로 타입 캐스팅</span>
            <span class="comment">// CanHandle에서 이미 Worker인지 확인했으므로 안전한 캐스팅</span>
            <span class="class-name">Worker</span> <span class="field-name">worker</span> = <span class="field-name">context</span>.<span class="property-name">Commandable</span> <span class="keyword">as</span> <span class="class-name">Worker</span>;
            
            <span class="comment">// worker.Gather(): Worker의 자원 수집 메서드 호출</span>
            <span class="comment">// context.Hit.collider.GetComponent: 클릭한 객체에서 GatherableSupply 컴포넌트 가져오기</span>
            <span class="field-name">worker</span>.<span class="method-name">Gather</span>(<span class="field-name">context</span>.<span class="property-name">Hit</span>.<span class="property-name">collider</span>.<span class="method-name">GetComponent</span>&lt;<span class="class-name">GatherableSupply</span>&gt;());
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🏗️ GatherSuppliesAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherSuppliesAction.cs - 자원 수집 액션 노드</span>
<span class="comment">// Unity Behavior Tree의 커스텀 액션 노드</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (새로운 커스텀 카테고리)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Gather Supplies"</span>, <span class="parameter">story</span>: <span class="string">"[Unit] gathers [Amount] supplies from [GatherableSupplies] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Units"</span>, <span class="parameter">id</span>: <span class="string">"3b941d7ae99d1e36b7d806875379c977"</span>)]
    
    <span class="comment">// GatherSuppliesAction: 자원을 수집하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">GatherSuppliesAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Unit: 자원을 수집할 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Unit</span>;
        
        <span class="comment">// Amount: 수집할 자원의 양</span>
        <span class="comment">// int: 정수형 (자원은 정수 단위로 관리)</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; <span class="property-name">Amount</span>;
        
        <span class="comment">// GatherableSupplies: 수집할 자원 객체</span>
        <span class="comment">// GatherableSupply: 수집 가능한 자원의 타입</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GatherableSupply</span>&gt; <span class="property-name">GatherableSupplies</span>;

        <span class="comment">// enterTime: 자원 수집을 시작한 시간</span>
        <span class="comment">// Time.time과 비교하여 수집 시간을 계산</span>
        <span class="keyword">private float</span> <span class="field-name">enterTime</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// enterTime을 현재 시간으로 설정</span>
            <span class="comment">// Time.time: 게임 시작 후 경과된 시간 (초 단위)</span>
            <span class="field-name">enterTime</span> = <span class="class-name">Time</span>.<span class="property-name">time</span>;

            <span class="comment">// GatherableSupplies.Value: Blackboard에서 가져온 자원 객체</span>
            <span class="comment">// BeginGather(): 자원 수집을 시작하고 Busy 상태로 변경</span>
            <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">BeginGather</span>();
            
            <span class="comment">// Running: 아직 수집이 완료되지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 주기적으로 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// 수집 시간이 완료되었는지 확인</span>
            <span class="comment">// GatherableSupplies.Value.Supply.BaseGatherTime: 자원의 기본 수집 시간</span>
            <span class="comment">// enterTime: 수집을 시작한 시간</span>
            <span class="comment">// Time.time: 현재 시간</span>
            <span class="comment">// 수집 시간 + 시작 시간이 현재 시간보다 작거나 같으면 수집 완료</span>
            <span class="keyword">if</span> (<span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="property-name">Supply</span>.<span class="property-name">BaseGatherTime</span> + <span class="field-name">enterTime</span> &lt;= <span class="class-name">Time</span>.<span class="property-name">time</span>)
            {
                <span class="comment">// 수집 완료</span>
                <span class="comment">// EndGather(): 수집을 완료하고 실제 수집된 양을 반환</span>
                <span class="comment">// Busy 상태를 false로 변경하고 자원에서 수집한 양만큼 차감</span>
                <span class="keyword">int</span> <span class="field-name">amountGathered</span> = <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">EndGather</span>();
                
                <span class="comment">// Success: 수집이 성공적으로 완료됨</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 수집 시간이 완료되지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔧 Worker 클래스 확장</h3>
                    
                    <div class="code-block">
<span class="comment">// Worker.cs - Worker 클래스에 Gather 메서드 추가</span>
<span class="comment">// AbstractUnit을 상속받아 Worker만의 특별한 기능 추가</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// Worker: 자원을 수집할 수 있는 유닛</span>
    <span class="comment">// AbstractUnit: 모든 유닛의 기본 클래스</span>
    <span class="keyword">public class</span> <span class="class-name">Worker</span> : <span class="class-name">AbstractUnit</span>
    {
        <span class="comment">// Gather: 자원을 수집하는 메서드</span>
        <span class="comment">// GatherableSupply: 수집할 자원 객체</span>
        <span class="keyword">public void</span> <span class="method-name">Gather</span>(<span class="class-name">GatherableSupply</span> <span class="field-name">supply</span>)
        {
            <span class="comment">// Blackboard에 자원 정보 설정</span>
            <span class="comment">// graphAgent: AbstractUnit에서 상속받은 BehaviorGraphAgent</span>
            <span class="comment">// SetVariableValue: Blackboard에 변수 값 설정</span>
            
            <span class="comment">// Supply: 수집할 자원 객체를 Blackboard에 설정</span>
            <span class="comment">// "Supply": Blackboard 변수 이름 (대소문자 중요)</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Supply"</span>, <span class="field-name">supply</span>);
            
            <span class="comment">// TargetLocation: 자원의 위치를 목표 위치로 설정</span>
            <span class="comment">// supply.transform.position: 자원의 현재 위치</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"TargetLocation"</span>, <span class="field-name">supply</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>);
            
            <span class="comment">// Command: 명령을 Gather로 설정</span>
            <span class="comment">// UnitCommands.Gather: 수집 명령</span>
            <span class="comment">// 이 명령 설정이 Behavior Tree를 트리거하여 수집 행동 시작</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Command"</span>, <span class="class-name">UnitCommands</span>.<span class="property-name">Gather</span>);
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 수집 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 수집 프로세스</h4>
                        <ul class="content-list">
                            <li><strong>이동 단계</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 시작</strong>: BeginGather() 호출하여 Busy 상태 설정</li>
                            <li><strong>수집 대기</strong>: BaseGatherTime만큼 대기</li>
                            <li><strong>수집 완료</strong>: EndGather() 호출하여 자원 획득</li>
                            <li><strong>상태 정리</strong>: Busy 상태 해제 및 자원 차감</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎯 레이어 시스템</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 레이어 설정</h4>
                        <ul class="content-list">
                            <li><strong>Supplies 레이어</strong>: 자원 전용 레이어 생성</li>
                            <li><strong>Interactable Layers</strong>: 상호작용 가능한 레이어들</li>
                            <li><strong>Layer Collision Matrix</strong>: 레이어 간 충돌 설정</li>
                            <li><strong>PlayerInput 업데이트</strong>: 자원과 상호작용 가능하도록 수정</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 PlayerInput 수정</h4>
                        <ul class="content-list">
                            <li><strong>Interactable Layers</strong>: Units, Buildings, Supplies</li>
                            <li><strong>Layer Mask 조합</strong>: Interactable | Floor Layers</li>
                            <li><strong>CanHandle 체크</strong>: 명령 처리 가능 여부 확인</li>
                            <li><strong>안전한 명령 실행</strong>: 처리할 수 없는 명령 방지</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>경제 시스템</strong>: RTS 게임의 핵심인 자원 수집 메커니즘</p>
                        <p><strong>자동화</strong>: Worker가 지능적으로 자원을 수집</p>
                        <p><strong>확장성</strong>: 다양한 자원 타입을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 수집 행동이 동일한 패턴으로 동작</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>Behavior Tree 활용</strong>: 시각적이고 직관적인 AI 로직</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                        <p><strong>시간 기반 로직</strong>: Time.time을 사용한 정확한 타이밍</p>
                        <p><strong>레이어 시스템</strong>: 체계적인 상호작용 관리</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>Blackboard 변수명</strong>: 대소문자와 정확한 이름 사용</p>
                        <p><strong>레이어 설정</strong>: 자원을 올바른 레이어에 배치</p>
                        <p><strong>시간 계산</strong>: enterTime과 현재 시간의 정확한 비교</p>
                        <p><strong>상태 관리</strong>: BeginGather와 EndGather의 올바른 호출</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 자원</strong>: 미네랄, 가스, 에너지, 금속 등</li>
                        <li><strong>자원 등급</strong>: 일반, 희귀, 전설 등급의 자원</li>
                        <li><strong>수집 효율</strong>: Worker 레벨에 따른 수집 속도 차이</li>
                        <li><strong>자원 보호</strong>: 중요한 자원을 보호하는 방어 시설</li>
                        <li><strong>자동 수집</strong>: Worker가 알아서 가장 가까운 자원 찾기</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>GatherCommand</strong>: 자원 수집 명령 액션 베이스</li>
                        <li><strong>GatherSuppliesAction</strong>: 자원 수집 커스텀 노드</li>
                        <li><strong>Worker.Gather()</strong>: Worker의 자원 수집 메서드</li>
                        <li><strong>Time.time</strong>: 게임 시간 기반 타이밍</li>
                        <li><strong>BeginGather/EndGather</strong>: 자원 수집 상태 관리</li>
                        <li><strong>Supplies 레이어</strong>: 자원 전용 레이어</li>
                        <li><strong>Interactable Layers</strong>: 상호작용 가능한 레이어</li>
                        <li><strong>Sequence 노드</strong>: 순차적 실행을 위한 노드</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 41: Return Supplies to Command Post (자원을 Command Post로 반환) -->
            <div class="lecture-section" id="lecture-41">
                <h2 class="lecture-title">🏠 강의 41: Return Supplies to Command Post (자원을 Command Post로 반환)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자원 반환 시스템</strong>: <span style="color: #2c3e50;">Worker가 수집한 자원을 가장 가까운 Command Post로 반환하는 시스템 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">완전한 수집 사이클</strong>: <span style="color: #2c3e50;">자원 수집 → 반환의 완전한 사이클 완성</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">AI 탐색 시스템</strong>: <span style="color: #2c3e50;">Physics.OverlapSphere를 사용한 가장 가까운 건물 찾기</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">커스텀 노드 확장</strong>: <span style="color: #2c3e50;">FindClosestCommandPost와 MoveToTargetGameObject 노드 추가</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 자원 반환이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker가 미네랄을 캐서 집(Command Post)으로 가져가는 시스템이에요. 마치 장보기에서 사온 것들을 집에 가져가는 것과 같아요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집</strong>: Worker가 미네랄을 캐요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>가까운 집 찾기</strong>: 가장 가까운 Command Post를 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>집으로 이동</strong>: Command Post로 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 반환</strong>: 수집한 자원을 Command Post에 넣어요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>반복</strong>: 다시 자원을 캐러 가요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기에서 사온 것들을 집에 가져가서 냉장고에 넣는 것처럼, 게임에서도 Worker가 캔 자원을 Command Post에 저장해요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>GatherSuppliesAction에서 수집량을 Blackboard에 저장</li>
                        <li>FindClosestCommandPostAction 커스텀 노드 구현</li>
                        <li>MoveToTargetGameObjectAction 커스텀 노드 구현</li>
                        <li>Behavior Tree에 자원 반환 시퀀스 추가</li>
                        <li>Physics.OverlapSphere를 사용한 건물 탐색</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🏠 자원 반환 시스템 설계</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 시스템 구성 요소</h4>
                        <ul class="content-list">
                            <li><strong>SupplyAmountHeld</strong>: 수집한 자원량을 저장하는 Blackboard 변수</li>
                            <li><strong>FindClosestCommandPostAction</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObjectAction</strong>: GameObject로 이동하는 노드</li>
                            <li><strong>CommandPost</strong>: 찾은 Command Post를 저장하는 변수</li>
                            <li><strong>SearchRadius</strong>: 탐색 반경 설정</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 자원 반환 플로우</h4>
                        <ol class="content-list">
                            <li><strong>자원 수집</strong>: GatherSuppliesAction에서 자원 수집</li>
                            <li><strong>수집량 저장</strong>: SupplyAmountHeld에 수집량 저장</li>
                            <li><strong>Command Post 찾기</strong>: FindClosestCommandPostAction 실행</li>
                            <li><strong>Command Post로 이동</strong>: MoveToTargetGameObjectAction 실행</li>
                            <li><strong>자원 반환</strong>: Command Post에 자원 전달 (다음 강의)</li>
                            <li><strong>반복</strong>: 다시 자원 수집으로 돌아감</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 GatherSuppliesAction 수정</h3>
                    
                    <div class="code-block">
<span class="comment">// GatherSuppliesAction.cs - 수집량을 Blackboard에 저장하도록 수정</span>
<span class="comment">// OnUpdate 메서드에서 수집 완료 시 수집량을 Blackboard에 저장</span>

<span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
{
    <span class="comment">// 수집 시간이 완료되었는지 확인</span>
    <span class="keyword">if</span> (<span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="property-name">Supply</span>.<span class="property-name">BaseGatherTime</span> + <span class="field-name">enterTime</span> &lt;= <span class="class-name">Time</span>.<span class="property-name">time</span>)
    {
        <span class="comment">// 수집 완료</span>
        <span class="comment">// EndGather(): 수집을 완료하고 실제 수집된 양을 반환</span>
        <span class="comment">// Busy 상태를 false로 변경하고 자원에서 수집한 양만큼 차감</span>
        <span class="keyword">int</span> <span class="field-name">amountGathered</span> = <span class="property-name">GatherableSupplies</span>.<span class="property-name">Value</span>.<span class="method-name">EndGather</span>();
        
        <span class="comment">// 수집량을 Blackboard에 저장</span>
        <span class="comment">// Amount: Blackboard의 SupplyAmountHeld 변수</span>
        <span class="comment">// 이 값은 다음 액션에서 사용됨</span>
        <span class="property-name">Amount</span>.<span class="property-name">Value</span> = <span class="field-name">amountGathered</span>;
        
        <span class="comment">// Success: 수집이 성공적으로 완료됨</span>
        <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
    }

    <span class="comment">// Running: 아직 수집 시간이 완료되지 않았으므로 계속 실행 중</span>
    <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔍 FindClosestCommandPostAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// FindClosestCommandPostAction.cs - 가장 가까운 Command Post 찾기</span>
<span class="comment">// Physics.OverlapSphere를 사용하여 주변 건물 탐색</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">System.Collections.Generic</span>;
<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Units</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Units)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Find Closest Command Post"</span>, <span class="parameter">story</span>: <span class="string">"[Unit] finds nearest [CommandPost] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Units"</span>, <span class="parameter">id</span>: <span class="string">"df019f9861776b3b31754a035175faf5"</span>)]
    
    <span class="comment">// FindClosestCommandPostAction: 가장 가까운 Command Post를 찾는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">FindClosestCommandPostAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Unit: Command Post를 찾을 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Unit</span>;
        
        <span class="comment">// CommandPost: 찾은 Command Post를 저장할 변수</span>
        <span class="comment">// GameObject: Command Post의 GameObject</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">CommandPost</span>;
        
        <span class="comment">// SearchRadius: 탐색 반경</span>
        <span class="comment">// float: 실수형 (탐색 반경은 미터 단위)</span>
        <span class="comment">// new(10): 기본값 10으로 초기화</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">float</span>&gt; <span class="property-name">SearchRadius</span> = <span class="keyword">new</span>(<span class="number">10</span>);
        
        <span class="comment">// CommandPostBuilding: Command Post의 UnitSO</span>
        <span class="comment">// UnitSO: 건물의 ScriptableObject</span>
        <span class="comment">// 이 값을 사용하여 Command Post인지 확인</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">UnitSO</span>&gt; <span class="property-name">CommandPostBuilding</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// Physics.OverlapSphere: 구체 모양의 영역에서 Collider들을 찾음</span>
            <span class="comment">// Unit.Value.transform.position: 유닛의 현재 위치</span>
            <span class="comment">// SearchRadius.Value: 탐색 반경</span>
            <span class="comment">// LayerMask.GetMask("Buildings"): Buildings 레이어만 검사</span>
            <span class="comment">// 반환값: 해당 영역에 있는 모든 Collider 배열</span>
            <span class="class-name">Collider</span>[] <span class="field-name">colliders</span> = <span class="class-name">Physics</span>.<span class="method-name">OverlapSphere</span>(
                <span class="property-name">Unit</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, 
                <span class="property-name">SearchRadius</span>.<span class="property-name">Value</span>, 
                <span class="class-name">LayerMask</span>.<span class="method-name">GetMask</span>(<span class="string">"Buildings"</span>));

            <span class="comment">// nearbyCommandPosts: 주변의 Command Post들을 저장할 리스트</span>
            <span class="comment">// List&lt;BaseBuilding&gt;: BaseBuilding 타입의 리스트</span>
            <span class="comment">// new(): 빈 리스트로 초기화</span>
            <span class="class-name">List</span>&lt;<span class="class-name">BaseBuilding</span>&gt; <span class="field-name">nearbyCommandPosts</span> = <span class="keyword">new</span>();

            <span class="comment">// foreach: 배열의 각 요소를 순회</span>
            <span class="comment">// collider: 현재 검사 중인 Collider</span>
            <span class="keyword">foreach</span>(<span class="class-name">Collider</span> <span class="field-name">collider</span> <span class="keyword">in</span> <span class="field-name">colliders</span>)
            {
                <span class="comment">// TryGetComponent: 해당 GameObject에서 BaseBuilding 컴포넌트를 가져옴</span>
                <span class="comment">// out building: 가져온 BaseBuilding을 저장할 변수</span>
                <span class="comment">// building.UnitSO.Equals: 건물의 UnitSO가 Command Post인지 확인</span>
                <span class="comment">// CommandPostBuilding.Value: Blackboard에서 가져온 Command Post의 UnitSO</span>
                <span class="keyword">if</span> (<span class="field-name">collider</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">BaseBuilding</span> <span class="field-name">building</span>) 
                        &amp;&amp; <span class="field-name">building</span>.<span class="property-name">UnitSO</span>.<span class="method-name">Equals</span>(<span class="property-name">CommandPostBuilding</span>.<span class="property-name">Value</span>))
                {
                    <span class="comment">// Command Post인 경우 리스트에 추가</span>
                    <span class="field-name">nearbyCommandPosts</span>.<span class="method-name">Add</span>(<span class="field-name">building</span>);
                }
            }

            <span class="comment">// 주변에 Command Post가 없는 경우</span>
            <span class="keyword">if</span> (<span class="field-name">nearbyCommandPosts</span>.<span class="property-name">Count</span> == <span class="number">0</span>)
            {
                <span class="comment">// Failure: Command Post를 찾을 수 없음</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// Command Post를 찾은 경우</span>
            <span class="comment">// CommandPost.Value: Blackboard의 CommandPost 변수에 저장</span>
            <span class="comment">// nearbyCommandPosts[0].gameObject: 첫 번째 Command Post의 GameObject</span>
            <span class="comment">// 현재는 가장 가까운 것이 아닌 첫 번째 것을 선택 (단순화)</span>
            <span class="property-name">CommandPost</span>.<span class="property-name">Value</span> = <span class="field-name">nearbyCommandPosts</span>[<span class="number">0</span>].<span class="property-name">gameObject</span>;

            <span class="comment">// Success: Command Post를 성공적으로 찾음</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🚶 MoveToTargetGameObjectAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// MoveToTargetGameObjectAction.cs - GameObject로 이동하는 액션 노드</span>
<span class="comment">// MoveToTargetLocationAction과 유사하지만 GameObject의 위치로 이동</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(<span class="parameter">name</span>: <span class="string">"Move to Target GameObject"</span>, <span class="parameter">story</span>: <span class="string">"[Agent] moves to [TargetGameObject] ."</span>, <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, <span class="parameter">id</span>: <span class="string">"f07a8fab1fc459315f3380eef35b2aa0"</span>)]
    
    <span class="comment">// MoveToTargetGameObjectAction: GameObject로 이동하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetGameObjectAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 이동할 유닛의 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// TargetGameObject: 이동할 목표 GameObject</span>
        <span class="comment">// GameObject: 목표가 되는 GameObject</span>
        [<span class="class-name">SerializeReference</span>] <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">TargetGameObject</span>;

        <span class="comment">// agent: NavMeshAgent 컴포넌트</span>
        <span class="comment">// private: 외부에서 접근할 수 없음</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// Failure: NavMeshAgent가 없으면 실패</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// targetPosition: 목표 GameObject의 위치</span>
            <span class="comment">// TargetGameObject.Value.transform.position: 목표 GameObject의 현재 위치</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span> = <span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>;
            
            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.transform.position: 현재 위치</span>
            <span class="comment">// targetPosition: 목표 위치</span>
            <span class="comment">// agent.stoppingDistance: 정지 거리</span>
            <span class="comment">// 이미 목표에 가까이 있으면 성공</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.<span class="method-name">Distance</span>(<span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, <span class="field-name">targetPosition</span>) &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 이미 목표에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// SetDestination: NavMeshAgent에게 목표 위치 설정</span>
            <span class="comment">// targetPosition: 이동할 목표 위치</span>
            <span class="field-name">agent</span>.<span class="method-name">SetDestination</span>(<span class="field-name">targetPosition</span>);
            
            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 주기적으로 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="comment">// 목표에 도달했는지 확인</span>
            <span class="keyword">if</span> (<span class="field-name">agent</span>.<span class="property-name">remainingDistance</span> &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 목표에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 목표에 도달하지 않았으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 완전한 수집 사이클</h4>
                        <ul class="content-list">
                            <li><strong>이동 단계</strong>: Worker가 자원 위치로 이동</li>
                            <li><strong>수집 단계</strong>: 자원을 수집하고 수집량 저장</li>
                            <li><strong>탐색 단계</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>반환 단계</strong>: Command Post로 이동</li>
                            <li><strong>반복</strong>: 다시 자원 수집으로 돌아감</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Blackboard 변수 설정</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 필요한 Blackboard 변수들</h4>
                        <ul class="content-list">
                            <li><strong>SupplyAmountHeld</strong>: 수집한 자원량 (int)</li>
                            <li><strong>CommandPost</strong>: 찾은 Command Post (GameObject)</li>
                            <li><strong>SearchRadius</strong>: 탐색 반경 (float, 기본값 10)</li>
                            <li><strong>CommandPostBuilding</strong>: Command Post의 UnitSO</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 변수 연결</h4>
                        <ul class="content-list">
                            <li><strong>GatherSupplies → SupplyAmountHeld</strong>: 수집량 저장</li>
                            <li><strong>FindClosestCommandPost → CommandPost</strong>: 찾은 Command Post 저장</li>
                            <li><strong>MoveToTargetGameObject → CommandPost</strong>: Command Post로 이동</li>
                            <li><strong>CommandPostBuilding</strong>: Command Post 식별용</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>완전한 경제 시스템</strong>: 자원 수집 → 반환의 완전한 사이클</p>
                        <p><strong>자동화</strong>: Worker가 지능적으로 자원을 수집하고 반환</p>
                        <p><strong>확장성</strong>: 다양한 건물 타입을 쉽게 추가</p>
                        <p><strong>일관성</strong>: 모든 수집 행동이 동일한 패턴으로 동작</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>Physics 시스템 활용</strong>: OverlapSphere로 효율적인 탐색</p>
                        <p><strong>커스텀 노드</strong>: 특정 기능을 위한 전용 노드</p>
                        <p><strong>Blackboard 활용</strong>: 노드 간 데이터 공유</p>
                        <p><strong>레이어 시스템</strong>: Buildings 레이어로 정확한 탐색</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>UnitSO 접근</strong>: BaseBuilding의 UnitSO를 public으로 변경</p>
                        <p><strong>레이어 설정</strong>: 건물을 올바른 레이어에 배치</p>
                        <p><strong>탐색 반경</strong>: 적절한 SearchRadius 설정</p>
                        <p><strong>성능 고려</strong>: 너무 많은 건물이 있으면 성능 저하</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 건물</strong>: Command Post, Supply Depot, Refinery 등</li>
                        <li><strong>자원 저장소</strong>: 각 건물마다 다른 자원 저장</li>
                        <li><strong>우선순위 시스템</strong>: 가장 가까운 건물이 아닌 가장 효율적인 건물</li>
                        <li><strong>자원 전송</strong>: 건물 간 자원 이동 시스템</li>
                        <li><strong>자동 배치</strong>: Worker가 알아서 최적의 건물 찾기</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>Physics.OverlapSphere</strong>: 구체 영역에서 Collider 탐색</li>
                        <li><strong>LayerMask.GetMask</strong>: 특정 레이어만 검사</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                        <li><strong>UnitSO.Equals</strong>: ScriptableObject 비교</li>
                        <li><strong>Blackboard 변수</strong>: 노드 간 데이터 공유</li>
                        <li><strong>Sequence 노드</strong>: 순차적 실행을 위한 노드</li>
                        <li><strong>GameObject 이동</strong>: Vector3가 아닌 GameObject로 이동</li>
                        <li><strong>탐색 반경</strong>: 효율적인 건물 탐색</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 42: Smooth Gathering Movement (부드러운 자원 수집 이동) -->
            <div class="lecture-section" id="lecture-42">
                <h2 class="lecture-title">🚶 강의 42: Smooth Gathering Movement (부드러운 자원 수집 이동)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">부드러운 이동</strong>: <span style="color: #2c3e50;">Worker들이 자원을 수집할 때 더 부드럽게 움직이도록 개선</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">Obstacle Avoidance 조정</strong>: <span style="color: #2c3e50;">자원 수집 시 다른 유닛들을 무시하고 통과할 수 있도록 설정</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">게임플레이 개선</strong>: <span style="color: #2c3e50;">StarCraft와 같은 RTS 게임의 수집 행동 패턴 구현</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">동적 설정</strong>: <span style="color: #2c3e50;">Behavior Tree에서 상황에 따라 NavMesh Agent 설정 변경</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🚶 부드러운 이동이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker들이 자원을 캐러 갈 때 다른 Worker들을 피해서 돌아다니지 않고, 그냥 통과해서 가는 시스템이에요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집 시</strong>: 다른 Worker들을 무시하고 통과해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>일반 이동 시</strong>: 다른 유닛들을 피해서 이동해요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자동 전환</strong>: 상황에 따라 자동으로 바뀌어요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기 갈 때는 다른 사람들을 피해서 돌아다니지만, 급할 때는 그냥 지나가는 것처럼, 게임에서도 상황에 따라 다르게 움직여요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>NavMesh Agent의 Obstacle Avoidance 개념 이해</li>
                        <li>SetAgentAvoidanceAction 커스텀 노드 구현</li>
                        <li>Behavior Tree에서 동적으로 avoidance 설정 변경</li>
                        <li>자원 수집 시와 일반 이동 시 다른 설정 적용</li>
                        <li>게임플레이 개선을 위한 이동 최적화</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🚶 Obstacle Avoidance 시스템</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 Obstacle Avoidance 타입</h4>
                        <ul class="content-list">
                            <li><strong>No Obstacle Avoidance (0)</strong>: 다른 유닛을 무시하고 통과</li>
                            <li><strong>Low Quality (1)</strong>: 낮은 품질의 회피</li>
                            <li><strong>Medium Quality (2)</strong>: 중간 품질의 회피</li>
                            <li><strong>Good Quality (3)</strong>: 좋은 품질의 회피</li>
                            <li><strong>High Quality (4)</strong>: 높은 품질의 회피 (기본값)</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 상황별 설정</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시</strong>: No Obstacle Avoidance (0) - 다른 Worker 무시</li>
                            <li><strong>일반 이동 시</strong>: High Quality (4) - 다른 유닛 회피</li>
                            <li><strong>전투 시</strong>: High Quality (4) - 전술적 이동</li>
                            <li><strong>건설 시</strong>: Medium Quality (2) - 적당한 회피</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 SetAgentAvoidanceAction 구현</h3>
                    
                    <div class="code-block">
<span class="comment">// SetAgentAvoidanceAction.cs - NavMesh Agent의 Obstacle Avoidance 설정</span>
<span class="comment">// Behavior Tree에서 동적으로 avoidance 품질을 변경</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(
        <span class="parameter">name</span>: <span class="string">"Set Agent Avoidance"</span>, 
        <span class="parameter">story</span>: <span class="string">"Set [Agent] avoidance quality to [AvoidanceQuality] ."</span>, 
        <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, 
        <span class="parameter">id</span>: <span class="string">"3a4f7ab7967bf186b0c645339d0ace1e"</span>
    )]
    
    <span class="comment">// SetAgentAvoidanceAction: NavMesh Agent의 Obstacle Avoidance를 설정하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">SetAgentAvoidanceAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 설정할 NavMesh Agent가 있는 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// AvoidanceQuality: 설정할 avoidance 품질 (0-4)</span>
        <span class="comment">// int: 정수형 (0=No, 1=Low, 2=Medium, 3=Good, 4=High)</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="keyword">int</span>&gt; <span class="property-name">AvoidanceQuality</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="comment">// AvoidanceQuality > 4: 유효하지 않은 높은 값</span>
            <span class="comment">// AvoidanceQuality < 0: 유효하지 않은 낮은 값</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>) || 
                <span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span> > <span class="number">4</span> || 
                <span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span> &lt; <span class="number">0</span>)
            {
                <span class="comment">// Failure: NavMeshAgent가 없거나 유효하지 않은 avoidance 품질</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// obstacleAvoidanceType: NavMesh Agent의 obstacle avoidance 타입</span>
            <span class="comment">// (ObstacleAvoidanceType): int를 ObstacleAvoidanceType enum으로 캐스팅</span>
            <span class="comment">// AvoidanceQuality.Value: Blackboard에서 가져온 avoidance 품질 값</span>
            <span class="field-name">agent</span>.<span class="property-name">obstacleAvoidanceType</span> = (<span class="class-name">ObstacleAvoidanceType</span>)<span class="property-name">AvoidanceQuality</span>.<span class="property-name">Value</span>;

            <span class="comment">// Success: avoidance 품질을 성공적으로 설정함</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>SetAgentAvoidance (0)</strong>: 자원 수집 시 No Obstacle Avoidance</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetLocation</strong>: 자원 위치로 이동</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post로 이동</li>
                            <li><strong>SetAgentAvoidance (4)</strong>: 일반 이동 시 High Quality</li>
                        </ol>
                    </div>

                    <div class="tech-stack">
                        <h4>⚡ 이동 최적화 프로세스</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시작</strong>: Obstacle Avoidance를 0으로 설정</li>
                            <li><strong>자원으로 이동</strong>: 다른 Worker들을 무시하고 통과</li>
                            <li><strong>자원 수집</strong>: 부드럽게 자원 수집</li>
                            <li><strong>Command Post로 이동</strong>: 다른 Worker들을 무시하고 통과</li>
                            <li><strong>일반 이동 복원</strong>: Obstacle Avoidance를 4로 설정</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Blackboard 변수 설정</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 필요한 Blackboard 변수들</h4>
                        <ul class="content-list">
                            <li><strong>AvoidanceQuality</strong>: 설정할 avoidance 품질 (int)</li>
                            <li><strong>Agent</strong>: NavMesh Agent가 있는 GameObject</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 변수 연결</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집 시</strong>: AvoidanceQuality = 0 (No Obstacle Avoidance)</li>
                            <li><strong>일반 이동 시</strong>: AvoidanceQuality = 4 (High Quality)</li>
                            <li><strong>Agent</strong>: Self (현재 유닛)</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>자연스러운 수집</strong>: StarCraft와 같은 RTS 게임의 수집 행동 패턴</p>
                        <p><strong>성능 최적화</strong>: 불필요한 회피 계산 제거</p>
                        <p><strong>사용자 경험</strong>: 더 부드럽고 직관적인 이동</p>
                        <p><strong>게임플레이 개선</strong>: 자원 수집이 더 효율적으로</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>동적 설정</strong>: Behavior Tree에서 상황에 따라 설정 변경</p>
                        <p><strong>간단한 구현</strong>: 단순하지만 효과적인 솔루션</p>
                        <p><strong>유연성</strong>: 다양한 상황에 적용 가능</p>
                        <p><strong>성능</strong>: 불필요한 계산 제거</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>유효성 검사</strong>: 0-4 범위 내의 값만 허용</p>
                        <p><strong>NavMeshAgent 확인</strong>: 컴포넌트 존재 여부 확인</p>
                        <p><strong>타입 캐스팅</strong>: int를 ObstacleAvoidanceType으로 안전하게 변환</p>
                        <p><strong>상황별 적용</strong>: 적절한 시점에 설정 변경</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>다양한 이동 모드</strong>: 수집, 전투, 건설, 탐색 모드</li>
                        <li><strong>상황별 최적화</strong>: 각 상황에 맞는 이동 설정</li>
                        <li><strong>성능 최적화</strong>: 불필요한 회피 계산 제거</li>
                        <li><strong>사용자 경험</strong>: 더 부드럽고 직관적인 이동</li>
                        <li><strong>전술적 이동</strong>: 전투 시와 평시 이동 구분</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>ObstacleAvoidanceType</strong>: NavMesh Agent의 회피 타입</li>
                        <li><strong>SetAgentAvoidanceAction</strong>: avoidance 설정 커스텀 노드</li>
                        <li><strong>동적 설정</strong>: Behavior Tree에서 런타임 설정 변경</li>
                        <li><strong>타입 캐스팅</strong>: int를 enum으로 안전하게 변환</li>
                        <li><strong>유효성 검사</strong>: 입력값 범위 확인</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 가져오기</li>
                        <li><strong>상황별 최적화</strong>: 각 상황에 맞는 이동 설정</li>
                        <li><strong>게임플레이 개선</strong>: 더 자연스러운 이동 패턴</li>
                    </ul>
                </div>
            </div>

            <!-- 강의 43: Pick Better Gathering Locations (더 나은 자원 수집 위치 선택) -->
            <div class="lecture-section" id="lecture-43">
                <h2 class="lecture-title">🎯 강의 43: Pick Better Gathering Locations (더 나은 자원 수집 위치 선택)</h2>
                
                <div class="tech-stack" style="margin-top: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                    <h4 style="color: #2c3e50; margin-top: 0;">🎯 이번 강의를 왜 해야 하는가?</h4>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">최적화된 위치 선택</strong>: <span style="color: #2c3e50;">Worker들이 자원과 Command Post의 가장 가까운 지점을 선택하도록 개선</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">Collider 활용</strong>: <span style="color: #2c3e50;">Collider.ClosestPoint API를 사용하여 정확한 위치 계산</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">자연스러운 이동</strong>: <span style="color: #2c3e50;">RTS 게임다운 직관적이고 효율적인 이동 패턴</span></p>
                    <p style="margin: 8px 0;"><strong style="color: #2c3e50;">성능 개선</strong>: <span style="color: #2c3e50;">불필요한 우회 이동 제거로 더 빠른 자원 수집</span></p>
                </div>
                
                <div class="tech-stack" style="margin-top: 15px; background: #e8f5e8; border: 2px solid #28a745; border-radius: 8px;">
                    <h4 style="color: #155724; margin-top: 0;">🧒 초딩도 이해하기 쉬운 설명</h4>
                    <p style="margin: 8px 0; color: #155724;"><strong>🎯 더 나은 위치 선택이 뭐야?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">Worker들이 자원을 캐러 갈 때, 자원의 뒤쪽이 아니라 가장 가까운 쪽으로 가도록 하는 시스템이에요!</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🎮 어떻게 작동하나요?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>자원 수집 시</strong>: 자원에서 가장 가까운 지점을 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>Command Post 반환 시</strong>: Command Post에서 가장 가까운 지점을 찾아요</p>
                    <p style="margin: 8px 0; color: #155724;">• <strong>Collider 활용</strong>: 물체의 모양을 고려해서 정확한 위치를 계산해요</p>
                    
                    <p style="margin: 8px 0; color: #155724;"><strong>🏠 집으로 비유하면?</strong></p>
                    <p style="margin: 8px 0; color: #155724;">장보기 갈 때 가게의 뒷문이 아니라 앞문으로 가는 것처럼, 게임에서도 가장 가까운 곳으로 가요!</p>
                </div>

                <div class="lecture-goal">
                    <h3>🎯 학습 목표</h3>
                    <ul class="content-list">
                        <li>Collider.ClosestPoint API 이해 및 활용</li>
                        <li>MoveToTargetGameObjectAction 개선</li>
                        <li>Worker.Gather() 메서드 업데이트</li>
                        <li>Behavior Tree Blackboard 변수 추가</li>
                        <li>더 직관적인 자원 수집 위치 선택</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🎯 문제점과 해결책</h3>
                    
                    <div class="tech-stack">
                        <h4>❌ 기존 문제점</h4>
                        <ul class="content-list">
                            <li><strong>임의의 위치 선택</strong>: 자원의 중심점에서 동일한 거리의 4개 지점 중 랜덤 선택</li>
                            <li><strong>비효율적인 이동</strong>: Worker가 자원의 뒤쪽으로 돌아가는 경우</li>
                            <li><strong>불필요한 우회</strong>: Command Post 반환 시에도 비효율적인 경로</li>
                            <li><strong>부자연스러운 동작</strong>: RTS 게임다운 직관적이지 않은 이동</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>✅ 개선된 해결책</h4>
                        <ul class="content-list">
                            <li><strong>ClosestPoint API</strong>: Collider에서 가장 가까운 지점 계산</li>
                            <li><strong>최적화된 경로</strong>: Worker 위치를 고려한 최단 경로</li>
                            <li><strong>자연스러운 이동</strong>: 직관적이고 효율적인 이동 패턴</li>
                            <li><strong>성능 향상</strong>: 불필요한 이동 시간 단축</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>📝 MoveToTargetGameObjectAction 개선</h3>
                    
                    <div class="code-block">
<span class="comment">// MoveToTargetGameObjectAction.cs - 개선된 GameObject 이동 액션</span>
<span class="comment">// Collider.ClosestPoint를 사용하여 최적의 위치 선택</span>

<span class="keyword">using</span> <span class="class-name">System</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Behavior</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine</span>;
<span class="keyword">using</span> <span class="class-name">Action</span> = <span class="class-name">Unity.Behavior.Action</span>;
<span class="keyword">using</span> <span class="class-name">Unity.Properties</span>;
<span class="keyword">using</span> <span class="class-name">UnityEngine.AI</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Behavior</span>
{
    <span class="comment">// Serializable: Unity에서 직렬화 가능하도록 하는 속성</span>
    <span class="comment">// GeneratePropertyBag: Unity Behavior Tree에서 사용하는 속성 백 생성</span>
    [<span class="class-name">Serializable</span>, <span class="class-name">GeneratePropertyBag</span>]
    
    <span class="comment">// NodeDescription: Behavior Tree 에디터에서 노드의 설명을 정의</span>
    <span class="comment">// name: 노드의 이름</span>
    <span class="comment">// story: 노드의 동작을 설명하는 텍스트</span>
    <span class="comment">// category: 노드가 속할 카테고리 (Action/Navigation)</span>
    <span class="comment">// id: 노드의 고유 식별자</span>
    [<span class="class-name">NodeDescription</span>(
        <span class="parameter">name</span>: <span class="string">"Move to Target GameObject"</span>, 
        <span class="parameter">story</span>: <span class="string">"[Agent] moves to [TargetGameObject] ."</span>, 
        <span class="parameter">category</span>: <span class="string">"Action/Navigation"</span>, 
        <span class="parameter">id</span>: <span class="string">"f07a8fab1fc459315f3380eef35b2aa0"</span>
    )]
    
    <span class="comment">// MoveToTargetGameObjectAction: GameObject로 이동하는 액션 노드</span>
    <span class="comment">// partial: 클래스가 여러 파일에 나뉘어 정의될 수 있음 (Unity Behavior Tree가 자동 생성)</span>
    <span class="keyword">public partial class</span> <span class="class-name">MoveToTargetGameObjectAction</span> : <span class="class-name">Action</span>
    {
        <span class="comment">// Agent: 이동할 NavMesh Agent가 있는 GameObject</span>
        <span class="comment">// SerializeReference: Unity에서 직렬화 가능한 참조</span>
        <span class="comment">// BlackboardVariable: Behavior Tree의 Blackboard에서 가져오는 변수</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">Agent</span>;
        
        <span class="comment">// TargetGameObject: 이동할 대상 GameObject</span>
        [<span class="class-name">SerializeReference</span>] 
        <span class="keyword">public</span> <span class="class-name">BlackboardVariable</span>&lt;<span class="class-name">GameObject</span>&gt; <span class="property-name">TargetGameObject</span>;

        <span class="comment">// agent: NavMesh Agent 컴포넌트 참조</span>
        <span class="comment">// private: 클래스 내부에서만 접근 가능</span>
        <span class="keyword">private</span> <span class="class-name">NavMeshAgent</span> <span class="field-name">agent</span>;

        <span class="comment">// OnStart: 액션이 시작될 때 호출되는 메서드</span>
        <span class="comment">// Status: 액션의 실행 상태 (Success, Failure, Running)</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnStart</span>()
        {
            <span class="comment">// TryGetComponent: Agent GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// out agent: 가져온 NavMeshAgent를 저장할 변수</span>
            <span class="comment">// !: 논리 부정 연산자 (실패 시 true)</span>
            <span class="keyword">if</span> (!<span class="property-name">Agent</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="field-name">agent</span>))
            {
                <span class="comment">// Failure: NavMeshAgent가 없는 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Failure</span>;
            }

            <span class="comment">// GetTargetPosition: 최적의 목표 위치를 계산하는 메서드</span>
            <span class="comment">// Vector3: 3차원 벡터 (x, y, z 좌표)</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span> = <span class="method-name">GetTargetPosition</span>();

            <span class="comment">// Vector3.Distance: 두 점 사이의 거리 계산</span>
            <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
            <span class="comment">// agent.stoppingDistance: NavMesh Agent의 정지 거리</span>
            <span class="comment">// <=: 작거나 같음 비교 연산자</span>
            <span class="keyword">if</span> (<span class="class-name">Vector3</span>.<span class="method-name">Distance</span>(
                <span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>, 
                <span class="field-name">targetPosition</span>
            ) &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 이미 목표 위치에 도달한 경우</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// SetDestination: NavMesh Agent의 목표 위치 설정</span>
            <span class="comment">// targetPosition: 계산된 최적의 목표 위치</span>
            <span class="field-name">agent</span>.<span class="method-name">SetDestination</span>(<span class="field-name">targetPosition</span>);
            
            <span class="comment">// Running: 이동을 시작했으므로 계속 실행 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// OnUpdate: 액션이 실행 중일 때 매 프레임 호출되는 메서드</span>
        <span class="keyword">protected override</span> <span class="class-name">Status</span> <span class="method-name">OnUpdate</span>()
        {
            <span class="comment">// remainingDistance: 목표까지 남은 거리</span>
            <span class="comment">// stoppingDistance: 정지 거리</span>
            <span class="keyword">if</span> (<span class="field-name">agent</span>.<span class="property-name">remainingDistance</span> &lt;= <span class="field-name">agent</span>.<span class="property-name">stoppingDistance</span>)
            {
                <span class="comment">// Success: 목표 위치에 도달함</span>
                <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Success</span>;
            }

            <span class="comment">// Running: 아직 이동 중</span>
            <span class="keyword">return</span> <span class="class-name">Status</span>.<span class="property-name">Running</span>;
        }

        <span class="comment">// GetTargetPosition: 최적의 목표 위치를 계산하는 private 메서드</span>
        <span class="comment">// private: 클래스 내부에서만 호출 가능</span>
        <span class="comment">// Vector3: 반환 타입 (3차원 벡터)</span>
        <span class="keyword">private</span> <span class="class-name">Vector3</span> <span class="method-name">GetTargetPosition</span>()
        {
            <span class="comment">// targetPosition: 계산될 목표 위치를 저장할 변수</span>
            <span class="class-name">Vector3</span> <span class="field-name">targetPosition</span>;
            
            <span class="comment">// TryGetComponent: TargetGameObject에서 Collider 컴포넌트를 가져옴</span>
            <span class="comment">// out collider: 가져온 Collider를 저장할 변수</span>
            <span class="keyword">if</span> (<span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="method-name">TryGetComponent</span>(<span class="keyword">out</span> <span class="class-name">Collider</span> <span class="field-name">collider</span>))
            {
                <span class="comment">// ClosestPoint: Collider에서 가장 가까운 지점을 계산</span>
                <span class="comment">// agent.transform.position: 현재 NavMesh Agent의 위치</span>
                <span class="comment">// 반환값: Collider 표면에서 Agent에 가장 가까운 지점</span>
                <span class="field-name">targetPosition</span> = <span class="field-name">collider</span>.<span class="method-name">ClosestPoint</span>(<span class="field-name">agent</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>);
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// Collider가 없는 경우: GameObject의 transform.position 사용</span>
                <span class="comment">// TargetGameObject.Value.transform.position: GameObject의 중심 위치</span>
                <span class="field-name">targetPosition</span> = <span class="property-name">TargetGameObject</span>.<span class="property-name">Value</span>.<span class="property-name">transform</span>.<span class="property-name">position</span>;
            }

            <span class="comment">// 계산된 목표 위치 반환</span>
            <span class="keyword">return</span> <span class="field-name">targetPosition</span>;
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🔧 Worker.Gather() 메서드 업데이트</h3>
                    
                    <div class="code-block">
<span class="comment">// Worker.cs - 개선된 자원 수집 메서드</span>
<span class="comment">// TargetGameObject를 사용하여 더 정확한 위치 설정</span>

<span class="keyword">using</span> <span class="class-name">GameDevTV.RTS.Environment</span>;

<span class="keyword">namespace</span> <span class="class-name">GameDevTV.RTS.Units</span>
{
    <span class="comment">// Worker: AbstractUnit을 상속하고 IGatherer 인터페이스를 구현</span>
    <span class="comment">// IGatherer: 자원 수집 기능을 제공하는 인터페이스</span>
    <span class="keyword">public class</span> <span class="class-name">Worker</span> : <span class="class-name">AbstractUnit</span>, <span class="class-name">IGatherer</span>
    {
        <span class="comment">// Gather: 자원 수집을 시작하는 메서드</span>
        <span class="comment">// public: 외부에서 호출 가능</span>
        <span class="comment">// void: 반환값 없음</span>
        <span class="comment">// GatherableSupply supply: 수집할 자원 객체</span>
        <span class="keyword">public void</span> <span class="method-name">Gather</span>(<span class="class-name">GatherableSupply</span> <span class="field-name">supply</span>)
        {
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Supply": Blackboard 변수 이름</span>
            <span class="comment">// supply: 설정할 값 (GatherableSupply 객체)</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Supply"</span>, <span class="field-name">supply</span>);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "TargetGameObject": Blackboard 변수 이름</span>
            <span class="comment">// supply.gameObject: 수집할 자원의 GameObject</span>
            <span class="comment">// 이전: TargetLocation (Vector3) 사용</span>
            <span class="comment">// 개선: TargetGameObject (GameObject) 사용으로 Collider.ClosestPoint 활용 가능</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"TargetGameObject"</span>, <span class="field-name">supply</span>.<span class="property-name">gameObject</span>);
            
            <span class="comment">// SetVariableValue: Behavior Tree의 Blackboard에 변수 설정</span>
            <span class="comment">// "Command": Blackboard 변수 이름</span>
            <span class="comment">// UnitCommands.Gather: 수집 명령</span>
            <span class="property-name">graphAgent</span>.<span class="method-name">SetVariableValue</span>(<span class="string">"Command"</span>, <span class="class-name">UnitCommands</span>.<span class="property-name">Gather</span>);
        }
    }
}
</div>
                </div>

                <div class="content-section">
                    <h3>🎮 Behavior Tree 구조 업데이트</h3>
                    
                    <div class="tech-stack">
                        <h4>📊 새로운 Blackboard 변수</h4>
                        <ul class="content-list">
                            <li><strong>TargetGameObject</strong>: 이동할 대상 GameObject (GameObject)</li>
                            <li><strong>TargetLocation</strong>: 이동할 위치 (Vector3) - 기존 유지</li>
                            <li><strong>Supply</strong>: 수집할 자원 (GatherableSupply)</li>
                            <li><strong>Command</strong>: 현재 명령 (UnitCommands)</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🔄 업데이트된 트리 구조</h4>
                        <ol class="content-list">
                            <li><strong>OnStart</strong>: 트리 시작점</li>
                            <li><strong>Abort 노드</strong>: 명령 변경 시 즉시 중단</li>
                            <li><strong>Switch 노드</strong>: 명령에 따른 분기</li>
                            <li><strong>Gather 브랜치</strong>: 자원 수집 로직</li>
                            <li><strong>SetAgentAvoidance (0)</strong>: 자원 수집 시 No Obstacle Avoidance</li>
                            <li><strong>Sequence</strong>: 순차적으로 실행되는 노드들</li>
                            <li><strong>MoveToTargetGameObject</strong>: 자원 GameObject로 이동 (개선됨)</li>
                            <li><strong>GatherSupplies</strong>: 자원 수집 실행</li>
                            <li><strong>FindClosestCommandPost</strong>: 가장 가까운 Command Post 찾기</li>
                            <li><strong>MoveToTargetGameObject</strong>: Command Post GameObject로 이동 (개선됨)</li>
                            <li><strong>SetAgentAvoidance (4)</strong>: 일반 이동 시 High Quality</li>
                        </ol>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🔧 Collider.ClosestPoint API</h3>
                    
                    <div class="tech-stack">
                        <h4>📋 API 설명</h4>
                        <ul class="content-list">
                            <li><strong>Collider.ClosestPoint(Vector3 point)</strong>: Collider 표면에서 가장 가까운 지점 반환</li>
                            <li><strong>매개변수</strong>: 기준점이 되는 Vector3 위치</li>
                            <li><strong>반환값</strong>: Collider 표면에서 가장 가까운 Vector3 위치</li>
                            <li><strong>용도</strong>: 정확한 접근 지점 계산</li>
                        </ul>
                    </div>

                    <div class="tech-stack">
                        <h4>🎯 활용 예시</h4>
                        <ul class="content-list">
                            <li><strong>자원 수집</strong>: Worker 위치에서 자원 Collider까지의 최단 지점</li>
                            <li><strong>건물 접근</strong>: 유닛 위치에서 건물 Collider까지의 최단 지점</li>
                            <li><strong>장애물 회피</strong>: 장애물 주변의 안전한 경로 계산</li>
                            <li><strong>정확한 배치</strong>: 객체 주변의 정확한 배치 위치</li>
                        </ul>
                    </div>
                </div>

                <div class="content-section">
                    <h3>❓ 왜 필요한가?</h3>
                    
                    <div class="tech-stack">
                        <h4>🎮 게임 개발 관점</h4>
                        <p><strong>직관적인 이동</strong>: RTS 게임다운 자연스러운 이동 패턴</p>
                        <p><strong>효율성</strong>: 불필요한 우회 이동 제거</p>
                        <p><strong>사용자 경험</strong>: 예측 가능하고 합리적인 유닛 동작</p>
                        <p><strong>게임플레이</strong>: 더 빠르고 효율적인 자원 수집</p>
                    </div>

                    <div class="tech-stack">
                        <h4>🔧 기술적 장점</h4>
                        <p><strong>정확한 계산</strong>: Collider의 실제 모양을 고려한 위치 계산</p>
                        <p><strong>유연성</strong>: 다양한 크기와 모양의 객체에 적용 가능</p>
                        <p><strong>성능</strong>: Unity 내장 API 사용으로 최적화된 성능</p>
                        <p><strong>확장성</strong>: 다른 이동 시나리오에도 적용 가능</p>
                    </div>

                    <div class="tech-stack">
                        <h4>⚠️ 주의사항</h4>
                        <p><strong>Collider 존재 확인</strong>: TryGetComponent로 안전한 접근</p>
                        <p><strong>폴백 로직</strong>: Collider가 없는 경우 기존 방식 사용</p>
                        <p><strong>성능 고려</strong>: 매 프레임 호출 시 성능 영향 고려</p>
                        <p><strong>정확도</strong>: Collider의 복잡도에 따른 계산 정확도</p>
                    </div>
                </div>

                <div class="content-section">
                    <h3>🎮 노바1492 적용 포인트</h3>
                    <ul class="content-list">
                        <li><strong>정확한 건물 접근</strong>: 건물의 입구나 특정 지점으로 정확한 접근</li>
                        <li><strong>자원 수집 최적화</strong>: 자원에서 가장 효율적인 수집 지점 선택</li>
                        <li><strong>전투 위치 계산</strong>: 적 건물이나 유닛에 대한 최적의 공격 위치</li>
                        <li><strong>건설 위치 선택</strong>: 건물 건설 시 가장 적절한 위치 계산</li>
                        <li><strong>탐색 최적화</strong>: 탐색 대상에 대한 효율적인 접근 경로</li>
                    </ul>
                </div>

                <div class="content-section">
                    <h3>🔑 핵심 기술 개념</h3>
                    <ul class="content-list">
                        <li><strong>Collider.ClosestPoint</strong>: Collider에서 가장 가까운 지점 계산 API</li>
                        <li><strong>TryGetComponent</strong>: 안전한 컴포넌트 접근 방법</li>
                        <li><strong>폴백 로직</strong>: 대안적 처리 방식 제공</li>
                        <li><strong>Blackboard 변수</strong>: Behavior Tree의 데이터 통신</li>
                        <li><strong>GameObject vs Vector3</strong>: 위치 정보의 표현 방식 차이</li>
                        <li><strong>최적화된 경로</strong>: 효율적인 이동 경로 계산</li>
                        <li><strong>RTS 게임 패턴</strong>: 전략 게임의 표준적인 이동 방식</li>
                        <li><strong>사용자 경험</strong>: 직관적이고 예측 가능한 동작</li>
                    </ul>
                </div>
            </div>

        </div>
    </div>
</body>
</html>
