<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎮 Unity RTS 강의 완전 정리 - 노바1492 프로젝트 적용</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .container { max-width: 1200px; margin: 20px auto; padding: 20px; background: white; box-shadow: 0 20px 40px rgba(0,0,0,0.1); border-radius: 20px; }
        .header { text-align: center; margin-bottom: 40px; padding: 40px 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 20px; margin: -20px -20px 40px -20px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; font-weight: 700; }
        .lecture-section { margin-bottom: 50px; padding: 30px; background: #f8f9fa; border-radius: 15px; border-left: 5px solid #667eea; }
        .lecture-title { font-size: 1.8rem; color: #667eea; margin-bottom: 20px; font-weight: 600; }
        .lecture-goal { background: #e3f2fd; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #2196f3; }
        .content-section { margin-bottom: 25px; }
        .content-section h3 { color: #333; margin-bottom: 15px; font-size: 1.3rem; }
        .content-list { list-style: none; padding-left: 0; }
        .content-list li { padding: 8px 0; padding-left: 25px; position: relative; }
        .content-list li::before { content: "✓"; position: absolute; left: 0; color: #4caf50; font-weight: bold; }
        .code-block { background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 10px; margin: 15px 0; overflow-x: auto; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9rem; white-space: pre; line-height: 1.8; }
        .project-application { background: #f0f4f8; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #38a169; }
        .tech-stack { background: #fff5f5; padding: 20px; border-radius: 10px; margin: 20px 0; border-left: 4px solid #e53e3e; }
        .summary-section { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 40px; border-radius: 20px; margin-top: 40px; text-align: center; }
        .toc { background: #f7fafc; padding: 20px; border-radius: 10px; margin-bottom: 30px; }
        .toc ul { list-style: none; padding-left: 0; }
        .toc li { padding: 5px 0; padding-left: 20px; position: relative; }
        .toc li::before { content: "📚"; position: absolute; left: 0; }
        .toc a { color: #4a5568; text-decoration: none; transition: color 0.3s; }
        .toc a:hover { color: #667eea; }
        
        .step-guide {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        
        .step-guide h5 {
            color: #2e7d32;
            margin-top: 0;
            font-size: 16px;
        }
        
        .step-guide ol {
            margin: 12px 0;
            padding-left: 20px;
        }
        
        .step-guide li {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .option-explanation {
            margin: 20px 0;
        }
        
        .option-explanation h5 {
            color: #1976d2;
            font-size: 16px;
            margin: 20px 0 10px 0;
            padding: 8px 12px;
            background: #e3f2fd;
            border-radius: 6px;
            border-left: 4px solid #1976d2;
        }
        
        .problem-solution {
            background: #fff3e0;
            border: 1px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        
        .problem-solution h5 {
            color: #e65100;
            margin-top: 0;
            font-size: 16px;
        }
        
        .area-types {
            background: #f3e5f5;
            border: 1px solid #9c27b0;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }
        
        .area-types h5 {
            color: #7b1fa2;
            margin-top: 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 Unity RTS 강의 완전 정리</h1>
            <p>노바1492 프로젝트 적용</p>
        </div>
        
        <div class="toc">
            <h3>📚 목차</h3>
            <ul>
                <li><a href="#lecture1">강의 1: 패키지 매니저 등록 및 어셋 등록</a></li>
                <li><a href="#lecture2">강의 2: Cinemachine 카메라 시스템 구현</a></li>
                <li><a href="#lecture3">강의 3: 키보드 카메라 이동 시스템</a></li>
                <li><a href="#lecture4">강의 4: Warcraft 3 스타일 줌 시스템</a></li>
                <li><a href="#lecture5">강의 5: 카메라 회전 시스템</a></li>
                <li><a href="#lecture6">강의 6: 마우스 엣지 팬 시스템</a></li>
                <li><a href="#lecture7">강의 7: 카메라 경계 제한 시스템</a></li>
                <li><a href="#lecture8">강의 8: Navigation Mesh 시스템</a></li>
                <li><a href="#lecture9">강의 9: NavMesh Agent 시스템</a></li>
                <li><a href="#summary">노바1492 프로젝트 종합 적용 방안</a></li>
            </ul>
        </div>
        
        <div class="lecture-section" id="lecture1">
            <h2 class="lecture-title">📦 강의 1: 패키지 매니저 등록 및 어셋 등록</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>Unity RTS 게임 개발을 위한 기본 패키지와 어셋들을 프로젝트에 등록하고 설정하는 방법을 학습합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 패키지 매니저 설정</h4>
                <ul class="content-list">
                    <li><strong>Unity Package Manager</strong>를 통한 패키지 관리</li>
                    <li><strong>Input System</strong> 패키지 등록</li>
                    <li><strong>Cinemachine</strong> 패키지 등록</li>
                    <li><strong>Universal Render Pipeline (URP)</strong> 설정</li>
                </ul>
                <h4>2. 어셋 등록</h4>
                <ul class="content-list">
                    <li><strong>SciFi Pack</strong>: 우주/미래 테마 3D 모델들</li>
                    <li><strong>UI Assets</strong>: 게임 인터페이스 요소들</li>
                    <li><strong>Particle Effects</strong>: 폭발, 연기, 머즐플래시 등</li>
                    <li><strong>Terrain Assets</strong>: 지형 텍스처 및 레이어</li>
                </ul>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>SciFi Pack의 모델들</strong>: 로봇 파츠의 기본 형태로 활용</li>
                    <li><strong>UI 시스템</strong>: 파츠 선택 및 커스터마이징 인터페이스</li>
                    <li><strong>머티리얼 시스템</strong>: 각 파츠별 고유한 머티리얼 적용</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture2">
            <h2 class="lecture-title">📹 강의 2: Cinemachine 카메라 시스템 구현</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>RTS 게임에 최적화된 카메라 시스템을 Cinemachine을 사용하여 구현하는 방법을 학습합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. Cinemachine Brain 설정</h4>
                <ul class="content-list">
                    <li><strong>메인 카메라</strong>에 Cinemachine Brain 컴포넌트 추가</li>
                    <li><strong>Brain</strong>은 여러 Virtual Camera 간의 전환을 관리</li>
                    <li><strong>Blend List Camera</strong>를 통한 카메라 전환 시스템</li>
                </ul>
                <h4>2. Virtual Camera 생성 및 설정</h4>
                <div class="code-block">
<span class="comment">// Cinemachine Virtual Camera 설정</span>
<span class="comment">// Virtual Camera: 실제 카메라가 아닌 가상의 카메라 설정을 정의하는 컴포넌트</span>
<span class="comment">// AddComponent: GameObject에 새로운 컴포넌트를 동적으로 추가하는 Unity 메서드</span>
<span class="comment">// CinemachineVirtualCamera: Cinemachine 패키지에서 제공하는 가상 카메라 클래스</span>
CinemachineVirtualCamera vcam = gameObject.AddComponent&lt;CinemachineVirtualCamera&gt;();
                </div>
                <h4>3. 카메라 위치 및 각도 설정</h4>
                <ul class="content-list">
                    <li><strong>위치</strong>: (6, 10, -8) - RTS 게임에 적합한 시점</li>
                    <li><strong>회전</strong>: (62, -60, 0) - 지형을 잘 볼 수 있는 각도</li>
                    <li><strong>Field of View</strong>: 60도 - 적절한 시야각</li>
                </ul>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>전체 맵 시야</strong>: 로봇들의 위치를 파악하기 쉬운 시점</li>
                    <li><strong>빠른 반응성</strong>: 전투 중 빠른 카메라 이동</li>
                    <li><strong>부드러운 전환</strong>: 로봇 간 전환 시 자연스러운 카메라 이동</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture3">
            <h2 class="lecture-title">⌨️ 강의 3: 키보드 카메라 이동 시스템</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>새로운 Input System을 사용하여 키보드로 카메라를 이동시키는 시스템을 구현합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 새로운 Input System 소개</h4>
                <ul class="content-list">
                    <li><strong>Unity 2018</strong>부터 도입된 새로운 Input System</li>
                    <li><strong>Polling 방식</strong>: 매 프레임마다 입력을 확인</li>
                    <li><strong>Event-driven 방식</strong>: 입력이 발생할 때 콜백을 받음</li>
                </ul>
                <h4>2. 키보드 입력 처리</h4>
                <div class="code-block">
<span class="comment">// 키보드 입력 확인</span>
<span class="comment">// Keyboard.current: 현재 키보드 상태에 접근하는 Unity Input System의 정적 프로퍼티</span>
<span class="comment">// upArrowKey.isPressed: 위쪽 화살표 키가 현재 눌려있는지 확인하는 불린 값</span>
<span class="comment">// keyboardPanSpeed: 카메라 이동 속도를 조절하는 변수 (Inspector에서 설정 가능)</span>
<span class="keyword">if</span> (Keyboard.current.upArrowKey.isPressed) {
    <span class="comment">// moveAmount.y: Y축(위/아래) 이동량을 누적</span>
    <span class="comment">// += 연산자: 기존 값에 새로운 값을 더함 (연속 이동을 위해)</span>
    moveAmount.y += keyboardPanSpeed;
}
<span class="comment">// leftArrowKey.isPressed: 왼쪽 화살표 키가 눌려있는지 확인</span>
<span class="keyword">if</span> (Keyboard.current.leftArrowKey.isPressed) {
    <span class="comment">// moveAmount.x: X축(좌/우) 이동량을 누적</span>
    <span class="comment">// -= 연산자: 왼쪽 이동이므로 음수 값을 더함</span>
    moveAmount.x -= keyboardPanSpeed;
}
                </div>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>빠른 반응성</strong>: 전투 중 즉각적인 카메라 이동</li>
                    <li><strong>정확한 제어</strong>: 로봇 위치를 정확히 파악할 수 있는 시점</li>
                    <li><strong>직관적 조작</strong>: 플레이어가 쉽게 익힐 수 있는 조작법</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture4">
            <h2 class="lecture-title">🔍 강의 4: Warcraft 3 스타일 줌 시스템</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>Warcraft 3와 같은 RTS 게임의 줌 시스템을 구현하여 카메라를 확대/축소할 수 있게 합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 줌 시스템 구현</h4>
                <ul class="content-list">
                    <li><strong>End 키</strong>를 누르면 줌인, 놓으면 줌아웃</li>
                    <li><strong>Cinemachine Follow Offset</strong>을 조작하여 줌 구현</li>
                    <li><strong>Lerp vs Slerp</strong>: 부드러운 애니메이션을 위한 보간법</li>
                </ul>
                <h4>2. 부드러운 애니메이션</h4>
                <ul class="content-list">
                    <li><strong>Vector3.Lerp</strong>: 선형 보간 (직선 이동)</li>
                    <li><strong>Vector3.Slerp</strong>: 구면 보간 (부드러운 곡선 이동)</li>
                    <li><strong>Mathf.Clamp</strong>: 시간 값을 0-1 사이로 제한</li>
                </ul>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>전체 전장 파악</strong>: 줌아웃으로 전체 맵 보기</li>
                    <li><strong>세부 전투 관찰</strong>: 줌인으로 개별 로봇 전투 보기</li>
                    <li><strong>빠른 전환</strong>: 전투 상황에 따른 즉각적인 줌 조절</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture5">
            <h2 class="lecture-title">🔄 강의 5: 카메라 회전 시스템</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>Page Up/Page Down 키를 사용하여 카메라를 회전시키는 시스템을 구현합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 회전 시스템 구현</h4>
                <ul class="content-list">
                    <li><strong>Page Up</strong>: 왼쪽으로 회전</li>
                    <li><strong>Page Down</strong>: 오른쪽으로 회전</li>
                    <li><strong>Follow Offset의 X, Z 값을 조작</strong>하여 회전 구현</li>
                </ul>
                <h4>2. 부드러운 회전</h4>
                <ul class="content-list">
                    <li><strong>Slerp</strong>를 사용한 부드러운 회전 애니메이션</li>
                    <li><strong>회전 속도</strong> 조절 가능</li>
                    <li><strong>자동 리셋</strong> 기능</li>
                </ul>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>다각도 관찰</strong>: 다양한 각도에서 전투 상황 파악</li>
                    <li><strong>전략적 시점</strong>: 팀 전략에 맞는 최적 시점 선택</li>
                    <li><strong>빠른 전환</strong>: 전투 중 즉각적인 시점 변경</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture6">
            <h2 class="lecture-title">🖱️ 강의 6: 마우스 엣지 팬 시스템</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>마우스를 화면 가장자리로 이동시키면 카메라가 해당 방향으로 이동하는 시스템을 구현합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 엣지 팬 시스템</h4>
                <ul class="content-list">
                    <li><strong>마우스 위치 감지</strong>: 화면 가장자리에서 마우스 위치 확인</li>
                    <li><strong>방향별 이동</strong>: 상하좌우 각 방향으로 카메라 이동</li>
                    <li><strong>임계값 설정</strong>: 엣지 팬이 시작되는 거리 조절</li>
                </ul>
                <h4>2. 화면 좌표계 이해</h4>
                <div class="code-block">
<span class="comment">// Unity 화면 좌표계 (왼쪽 하단이 원점)</span>
<span class="comment">// 화면 해상도가 1920x1080일 때의 좌표 예시</span>
<span class="comment">// (0, 1080): 화면 왼쪽 상단 모서리</span>
<span class="comment">// (1920, 1080): 화면 오른쪽 상단 모서리</span>
<span class="comment">// (0, 0): 화면 왼쪽 하단 모서리 (Unity 좌표계의 원점)</span>
<span class="comment">// (1920, 0): 화면 오른쪽 하단 모서리</span>
(<span class="number">0</span>, <span class="number">1080</span>) ──────────── (<span class="number">1920</span>, <span class="number">1080</span>)
    │                       │
    │                       │
    │                       │
(<span class="number">0</span>, <span class="number">0</span>) ────────────────── (<span class="number">1920</span>, <span class="number">0</span>)
                </div>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>빠른 카메라 이동</strong>: 마우스만으로 즉각적인 카메라 이동</li>
                    <li><strong>정밀한 제어</strong>: 키보드와 마우스 조합으로 정밀한 카메라 제어</li>
                    <li><strong>직관적 조작</strong>: RTS 게임의 표준적인 조작법</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture7">
            <h2 class="lecture-title">🚧 강의 7: 카메라 경계 제한 시스템</h2>
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>카메라가 맵 경계를 벗어나지 않도록 제한하는 시스템을 구현합니다.</p>
            </div>
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                <h4>1. 물리 기반 경계 제한</h4>
                <ul class="content-list">
                    <li><strong>Rigidbody + Collider</strong>를 사용한 물리 기반 제한</li>
                    <li><strong>World Bounds</strong> 레이어 생성</li>
                    <li><strong>Physics Material</strong>을 사용한 마찰력 제거</li>
                </ul>
                <h4>2. 물리 기반 이동</h4>
                <div class="code-block">
<span class="comment">// Transform 직접 조작 대신 Rigidbody 사용</span>
<span class="comment">// 물리 기반 이동: Unity의 물리 시스템을 활용한 자연스러운 카메라 이동</span>
<span class="comment">// cameraTarget: 카메라가 따라갈 대상 오브젝트 (Rigidbody 컴포넌트 보유)</span>
<span class="comment">// linearVelocity: Rigidbody의 선형 속도 (이동 속도)</span>
<span class="comment">// Vector3: 3차원 벡터 (x, y, z 좌표)</span>
cameraTarget.linearVelocity = <span class="keyword">new</span> Vector3(
    <span class="comment">// X축 이동량: 좌우 이동</span>
    <span class="comment">// moveAmount.x: 키보드 입력으로 계산된 X축 이동량</span>
    moveAmount.x, 
    <span class="comment">// Y축 이동량: 상하 이동 (카메라는 수직으로 이동하지 않으므로 0)</span>
    <span class="number">0</span>, 
    <span class="comment">// Z축 이동량: 앞뒤 이동</span>
    <span class="comment">// moveAmount.y: 키보드 입력으로 계산된 Y축 이동량을 Z축으로 변환</span>
    <span class="comment">// 키보드의 위/아래 키가 월드의 앞/뒤 이동으로 매핑됨</span>
    moveAmount.y
);
                </div>
            </div>
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                <ul class="content-list">
                    <li><strong>전장 한정</strong>: 로봇들이 전장 내에서만 전투</li>
                    <li><strong>현실감</strong>: 맵을 벗어날 수 없는 현실적인 제약</li>
                    <li><strong>전략적 요소</strong>: 맵 경계를 활용한 전략 수립</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture8">
            <h2 class="lecture-title">🗺️ 강의 8: Navigation Mesh 시스템</h2>
            
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>AI 로봇들이 맵에서 어디로 갈 수 있는지 미리 계산해서 저장하는 <strong>Navigation Mesh</strong>를 만드는 방법을 학습합니다.</p>
            </div>
            
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                
                <h4>1. Navigation Mesh란? (쉽게 설명)</h4>
                <ul class="content-list">
                    <li><strong>NavMesh</strong>: AI가 "여기로 갈 수 있어!"라고 미리 표시해둔 지도</li>
                    <li><strong>Bake (구워내기)</strong>: 이 지도를 미리 계산해서 파일로 저장하는 과정</li>
                    <li><strong>NavMesh Agent</strong>: 이 지도를 보고 이동하는 AI 컴포넌트</li>
                    <li><strong>Area Cost (영역 비용)</strong>: 
                        <ul>
                            <li>평지 = 비용 1 (빠르게 이동)</li>
                            <li>물 = 비용 5 (느리게 이동, 피하려고 함)</li>
                            <li>벽 = 비용 무한대 (갈 수 없음)</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>2. NavMesh Surface 컴포넌트 설정 (단계별)</h4>
                <div class="step-guide">
                    <h5>🔧 설정 방법</h5>
                    <ol>
                        <li><strong>Floor 오브젝트 선택</strong> (Hierarchy에서)</li>
                        <li><strong>Inspector에서 "Add Component" 클릭</strong></li>
                        <li><strong>"Navmesh Surface" 검색해서 추가</strong></li>
                        <li><strong>설정값들 확인</strong>:
                            <ul>
                                <li>Agent Type: Default Agent (기본값)</li>
                                <li>Use Geometry: Physics Colliders (권장)</li>
                                <li>Collect Objects: Volume (권장)</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
                <h4>3. Object Collection 옵션들 (상세 설명)</h4>
                <div class="option-explanation">
                    <h5>📦 All Game Objects (모든 오브젝트 포함)</h5>
                    <ul>
                        <li><strong>의미</strong>: 씬에 있는 모든 오브젝트를 NavMesh 생성에 포함</li>
                        <li><strong>문제점</strong>: 카메라, UI 등 불필요한 오브젝트까지 포함되어 구멍(Hole) 생성</li>
                        <li><strong>결과</strong>: 이상한 구멍들이 생겨서 AI가 갑자기 멈춤</li>
                        <li><strong>권장</strong>: ❌ 사용하지 말 것</li>
                    </ul>
                    
                    <h5>📁 Current Object Hierarchy (현재 오브젝트만)</h5>
                    <ul>
                        <li><strong>의미</strong>: 선택한 오브젝트와 그 자식들만 포함</li>
                        <li><strong>장점</strong>: 카메라 타겟 같은 불필요한 오브젝트 제외</li>
                        <li><strong>문제점</strong>: 여전히 맵 밖 영역까지 포함됨</li>
                        <li><strong>권장</strong>: ⚠️ 임시로 사용</li>
                    </ul>
                    
                    <h5>📏 Volume (특정 영역만) - 권장!</h5>
                    <ul>
                        <li><strong>의미</strong>: 지정한 영역 내의 오브젝트들만 포함</li>
                        <li><strong>장점</strong>: 전장 영역만 정확히 설정 가능</li>
                        <li><strong>설정법</strong>: Volume Bounds로 영역 크기 조정</li>
                        <li><strong>권장</strong>: ✅ 가장 좋은 방법</li>
                    </ul>
                </div>
                
                <h4>4. Volume Bounds 설정 (구체적인 방법)</h4>
                <div class="step-guide">
                    <h5>🎯 전장 영역 설정하기</h5>
                    <ol>
                        <li><strong>Collect Objects를 "Volume"으로 변경</strong></li>
                        <li><strong>"Edit Volume" 버튼 클릭</strong> (씬에서 보라색 박스가 나타남)</li>
                        <li><strong>씬에서 보라색 박스 조정</strong>:
                            <ul>
                                <li>마우스로 모서리를 드래그해서 크기 조정</li>
                                <li>World Collider Bounds 안쪽에 맞춰서 설정</li>
                            </ul>
                        </li>
                        <li><strong>구체적인 수치</strong>:
                            <ul>
                                <li>X: -96 ~ 96 (좌우 경계)</li>
                                <li>Y: 3.5 ~ 7 (높이 범위 - 지형 위, 물 아래)</li>
                                <li>Z: -128 ~ 128 (앞뒤 경계)</li>
                            </ul>
                        </li>
                        <li><strong>"Bake" 버튼 클릭</strong></li>
                    </ol>
                </div>
                
                <h4>5. Layer 기반 제외 설정 (문제 해결)</h4>
                <div class="problem-solution">
                    <h5>🚫 Hole 문제 해결하기</h5>
                    <p><strong>문제</strong>: NavMesh에 이상한 구멍들이 생김</p>
                    <p><strong>원인</strong>: 카메라 타겟, UI 등이 NavMesh 생성에 방해</p>
                    <p><strong>해결법</strong>:</p>
                    <ol>
                        <li><strong>Include Layers 설정</strong>:
                            <ul>
                                <li>Ground, Terrain 등 이동 가능한 레이어만 선택</li>
                                <li>World Bounds 레이어는 제외</li>
                            </ul>
                        </li>
                        <li><strong>Water 제외하기</strong>:
                            <ul>
                                <li>Water 오브젝트의 Mesh Collider 비활성화</li>
                                <li>이렇게 하면 물은 통과 불가능한 장애물이 됨</li>
                            </ul>
                        </li>
                    </ol>
                </div>
                
                <h4>6. Area Types 설정 (로봇별 이동 특성)</h4>
                <div class="area-types">
                    <h5>🏷️ 영역별 이동 비용 설정</h5>
                    <ul>
                        <li><strong>Walkable (이동 가능)</strong>: Cost 1.0 - 평지, 기본 이동 영역</li>
                        <li><strong>Water (물)</strong>: Cost 5.0 - 로봇이 피하려고 하는 영역</li>
                        <li><strong>Rough Terrain (거친 지형)</strong>: Cost 2.0 - 느리게 이동하는 영역</li>
                        <li><strong>Impassable (통과 불가)</strong>: Cost 무한대 - 절대 갈 수 없는 영역</li>
                    </ul>
                </div>
            </div>
            
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                
                <h4>로봇 대전에 최적화된 NavMesh</h4>
                <ul class="content-list">
                    <li><strong>전장 경로 설정</strong>: 로봇들이 이동할 수 있는 전장 경로 정의</li>
                    <li><strong>장애물 회피</strong>: 물, 건물 등 통과 불가능한 영역 설정</li>
                    <li><strong>다양한 로봇 타입</strong>: 각 로봇 파츠별로 다른 이동 특성 적용</li>
                </ul>
                
                <h4>4:4 팀전 활용</h4>
                <ul class="content-list">
                    <li><strong>전략적 포지셔닝</strong>: 팀원들이 전략적으로 배치될 수 있는 위치 설정</li>
                    <li><strong>적 추적 경로</strong>: 적 로봇을 추적할 때 최적 경로 제공</li>
                    <li><strong>팀 협력</strong>: 팀원들과 협력할 수 있는 이동 경로 최적화</li>
                </ul>
            </div>
            
            <div class="tech-stack">
                <h3>🔧 핵심 기술</h3>
                
                <h4>NavMesh Surface 설정</h4>
                <div class="code-block">
// NavMesh Surface 컴포넌트 설정
- Agent Type: Default Agent
- Use Geometry: Physics Colliders (권장)
- Collect Objects: Volume
- Volume Bounds: 전장 영역에 맞게 설정
- Include Layers: Ground, Terrain 등
- Exclude Layers: Water, Obstacles 등
                </div>
                
                <h4>Area Types 설정</h4>
                <ul class="content-list">
                    <li><strong>Walkable</strong>: Cost 1.0 (기본 이동 가능 영역)</li>
                    <li><strong>Water</strong>: Cost 5.0 (물 - 이동 비용 높음)</li>
                    <li><strong>Rough Terrain</strong>: Cost 2.0 (거친 지형)</li>
                    <li><strong>Impassable</strong>: Cost 무한대 (통과 불가능)</li>
                </ul>
            </div>
        </div>

        <div class="lecture-section" id="lecture9">
            <h2 class="lecture-title">🤖 강의 9: NavMesh Agent 시스템</h2>
            
            <div class="lecture-goal">
                <h3>🎯 강의 목표</h3>
                <p>AI 로봇들이 <strong>NavMesh Agent</strong> 컴포넌트를 사용해서 목표 지점까지 자동으로 이동하는 방법을 학습합니다.</p>
            </div>
            
            <div class="content-section">
                <h3>📋 주요 내용</h3>
                
                <h4>1. NavMesh Agent란? (쉽게 설명)</h4>
                <ul class="content-list">
                    <li><strong>NavMesh Agent</strong>: AI가 목표까지 자동으로 길을 찾아 이동하게 해주는 컴포넌트</li>
                    <li><strong>Player Controller for AI</strong>: 플레이어가 직접 조작하는 대신 AI가 스스로 움직이게 해주는 도구</li>
                    <li><strong>자동 경로 계산</strong>: 목표까지 가는 최적의 길을 자동으로 찾아줌</li>
                    <li><strong>충돌 회피</strong>: 다른 AI들과 부딪히지 않게 피해서 이동</li>
                </ul>
                
                <h4>2. NavMesh Agent 컴포넌트 설정 (단계별)</h4>
                <div class="step-guide">
                    <h5>🔧 Agent 컴포넌트 추가하기</h5>
                    <ol>
                        <li><strong>Worker 프리팹 선택</strong> (Project → Units → Worker)</li>
                        <li><strong>Inspector에서 "Add Component" 클릭</strong></li>
                        <li><strong>"NavMesh Agent" 검색해서 추가</strong></li>
                        <li><strong>씬에서 원통형 기즈모 확인</strong> (Agent의 크기 표시)</li>
                    </ol>
                </div>
                
                <h4>3. Agent 설정값들 (상세 설명)</h4>
                <div class="option-explanation">
                    <h5>📏 Agent Size (크기 설정)</h5>
                    <ul>
                        <li><strong>Radius (반지름)</strong>: 0.5 (권장값)
                            <ul>
                                <li>의미: AI가 통과할 수 있는 통로의 최소 폭</li>
                                <li>다른 AI들과의 충돌 회피 거리</li>
                                <li>너무 크면: 좁은 곳을 못 지나감</li>
                                <li>너무 작으면: 다른 AI와 부딪힘</li>
                            </ul>
                        </li>
                        <li><strong>Height (높이)</strong>: 2.0 (기본값)
                            <ul>
                                <li>의미: AI의 키 (천장이 있는 곳 통과 시 필요)</li>
                                <li>RTS에서는 보통 중요하지 않음</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>🚀 Steering (이동 제어)</h5>
                    <ul>
                        <li><strong>Speed (속도)</strong>: 3.5 (권장값)
                            <ul>
                                <li>의미: 초당 이동 거리 (유닛/초)</li>
                                <li>0에서 3.5까지 1초에 이동</li>
                                <li>로봇 타입별로 다르게 설정 가능</li>
                            </ul>
                        </li>
                        <li><strong>Angular Speed (회전 속도)</strong>: 120 (기본값)
                            <ul>
                                <li>의미: 초당 회전 각도 (도/초)</li>
                                <li>낮으면: 천천히 돌아서 부자연스러움</li>
                                <li>높으면: 빠르게 돌아서 자연스러움</li>
                            </ul>
                        </li>
                        <li><strong>Acceleration (가속도)</strong>: 8 (기본값)
                            <ul>
                                <li>의미: 속도 변화의 빠름 정도</li>
                                <li>낮으면: 천천히 가속, 자연스러운 움직임</li>
                                <li>높으면: 빠르게 가속, 반응적 움직임</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>🛑 Stopping Distance (정지 거리)</h5>
                    <ul>
                        <li><strong>의미</strong>: 목표에서 얼마나 떨어져 있어도 "도착했다"고 인식할지</li>
                        <li><strong>권장값</strong>: 1.0 (Agent의 Radius와 같게)</li>
                        <li><strong>문제 해결</strong>: 다른 AI를 계속 밀어내는 문제 해결</li>
                    </ul>
                </div>
                
                <h4>4. Worker 스크립트 작성 (구체적인 방법)</h4>
                <div class="step-guide">
                    <h5>💻 C# 스크립트 만들기</h5>
                    <ol>
                        <li><strong>Project → Scripts → Units 폴더에서 우클릭</strong></li>
                        <li><strong>Create → C# Script → "Worker" 이름으로 생성</strong></li>
                        <li><strong>VS Code에서 열기</strong></li>
                        <li><strong>다음 코드 작성</strong>:</li>
                    </ol>
                </div>
                
                <div class="code-block">
<span class="comment">// NavMesh Agent를 사용한 기본 이동 스크립트</span>
<span class="comment">// UnityEngine.AI: NavMeshAgent 관련 클래스들을 포함하는 네임스페이스</span>
<span class="keyword">using</span> UnityEngine;
<span class="keyword">using</span> UnityEngine.AI;

<span class="keyword">namespace</span> GameDev.Units
{
    <span class="comment">// RequireComponent: 이 스크립트가 추가되면 자동으로 NavMeshAgent도 추가됨</span>
    <span class="comment">// Unity의 컴포넌트 의존성을 강제하는 방법</span>
    [RequireComponent(<span class="keyword">typeof</span>(NavMeshAgent))]
    <span class="comment">// Worker 클래스: MonoBehaviour를 상속받는 기본 유닛 클래스</span>
    <span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
    <span class="keyword">public class</span> Worker : MonoBehaviour
    {
        <span class="comment">// NavMeshAgent 컴포넌트 참조</span>
        <span class="comment">// NavMeshAgent: Unity의 AI 이동을 담당하는 컴포넌트</span>
        <span class="keyword">private</span> NavMeshAgent agent;
        
        <span class="comment">// 이동할 목표 지점</span>
        <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 하는 Unity 어트리뷰트</span>
        <span class="comment">// Transform: GameObject의 위치, 회전, 크기 정보를 담는 컴포넌트</span>
        [SerializeField] <span class="keyword">private</span> Transform target;
        
        <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
        <span class="comment">// Awake: GameObject가 생성될 때 한 번만 호출되는 Unity 생명주기 메서드</span>
        <span class="keyword">private void</span> Awake()
        {
            <span class="comment">// 같은 GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
            <span class="comment">// GetComponent: GameObject에 연결된 특정 컴포넌트를 찾는 Unity 메서드</span>
            agent = <span class="keyword">GetComponent</span>&lt;NavMeshAgent&gt;();
        }
        
        <span class="comment">// 매 프레임마다 호출되는 Unity 생명주기 메서드</span>
        <span class="comment">// Update: 게임이 실행되는 동안 매 프레임마다 호출됨</span>
        <span class="keyword">private void</span> Update()
        {
            <span class="comment">// 목표가 설정되어 있는지 확인</span>
            <span class="comment">// target != null: 목표 오브젝트가 할당되어 있음</span>
            <span class="keyword">if</span> (target != <span class="keyword">null</span>)
            {
                <span class="comment">// NavMeshAgent에게 목표 지점을 설정</span>
                <span class="comment">// SetDestination: AI가 이동할 목표 지점을 지정하는 메서드</span>
                <span class="comment">// target.position: 목표 오브젝트의 현재 위치 (Vector3)</span>
                <span class="comment">// AI가 자동으로 최적의 경로를 계산하여 이동함</span>
                agent.SetDestination(target.position);
            }
        }
    }
}
                </div>
                
                <h4>5. Obstacle Avoidance (충돌 회피) 설정</h4>
                <div class="option-explanation">
                    <h5>🎯 Avoidance Quality (회피 품질)</h5>
                    <ul>
                        <li><strong>None</strong>: 충돌 회피 없음
                            <ul>
                                <li>용도: 자원 수집 시 다른 AI를 통과</li>
                                <li>장점: 성능 좋음, 간단함</li>
                                <li>단점: AI들이 겹쳐서 이동</li>
                            </ul>
                        </li>
                        <li><strong>Low Quality</strong>: 기본적인 회피
                            <ul>
                                <li>용도: 성능이 중요한 경우</li>
                                <li>특징: 적은 데이터 포인트로 빠른 처리</li>
                            </ul>
                        </li>
                        <li><strong>High Quality</strong>: 정밀한 회피 (권장)
                            <ul>
                                <li>용도: 정확한 충돌 회피가 필요한 경우</li>
                                <li>특징: 많은 데이터 포인트로 정밀한 처리</li>
                                <li>성능: 상대적으로 느림</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>⚡ Priority (우선순위)</h5>
                    <ul>
                        <li><strong>의미</strong>: AI들 간의 밀어내기 우선순위</li>
                        <li><strong>낮은 숫자</strong>: 높은 우선순위 (다른 AI를 밀어낼 수 있음)</li>
                        <li><strong>높은 숫자</strong>: 낮은 우선순위 (다른 AI에게 밀려남)</li>
                        <li><strong>예시</strong>: 탱크(40) vs 보병(50) → 탱크가 보병을 밀어냄</li>
                    </ul>
                </div>
                
                <h4>6. 문제 해결법 (실제 발생한 문제들)</h4>
                <div class="problem-solution">
                    <h5>🚫 AI가 다른 AI를 계속 밀어내는 문제</h5>
                    <p><strong>문제</strong>: Worker가 목표 Worker를 계속 밀어내면서 이동</p>
                    <p><strong>원인</strong>: Stopping Distance가 너무 작아서 목표에 도달했다고 인식하지 못함</p>
                    <p><strong>해결법</strong>:
                        <ul>
                            <li>Stopping Distance를 1.0으로 설정 (Agent Radius와 같게)</li>
                            <li>목표에 충분히 가까워지면 이동을 멈춤</li>
                        </ul>
                    </p>
                    
                    <h5>🔄 AI가 잘못된 방향으로 이동하는 문제</h5>
                    <p><strong>문제</strong>: AI가 목표를 향해 이동하지만 몸은 다른 방향을 향함</p>
                    <p><strong>원인</strong>: Angular Speed가 너무 낮아서 회전이 느림</p>
                    <p><strong>해결법</strong>:
                        <ul>
                            <li>Angular Speed를 720으로 증가 (기본값 120보다 높게)</li>
                            <li>Acceleration과 Angular Speed의 균형 맞추기</li>
                        </ul>
                    </p>
                </div>
            </div>
            
            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
                
                <h4>로봇 AI 이동 시스템</h4>
                <ul class="content-list">
                    <li><strong>로봇 타입별 설정</strong>:
                        <ul>
                            <li>경량 로봇: Speed 5.0, Angular Speed 360</li>
                            <li>중형 로봇: Speed 3.5, Angular Speed 180</li>
                            <li>중장갑 로봇: Speed 2.0, Angular Speed 120</li>
                        </ul>
                    </li>
                    <li><strong>전투 AI</strong>: 적 로봇을 추적하거나 전략적 위치로 이동</li>
                    <li><strong>팀워크 AI</strong>: 팀원들과 협력하여 포지셔닝</li>
                </ul>
                
                <h4>4:4 팀전 활용</h4>
                <ul class="content-list">
                    <li><strong>팀 우선순위 시스템</strong>:
                        <ul>
                            <li>탱크 로봇: Priority 40 (다른 로봇들을 밀어냄)</li>
                            <li>스카우트 로봇: Priority 50 (탱크에게 밀려남)</li>
                            <li>지원 로봇: Priority 45 (중간 우선순위)</li>
                        </ul>
                    </li>
                    <li><strong>전술적 이동</strong>: 팀원들과 함께 포메이션 유지하며 이동</li>
                    <li><strong>적 회피</strong>: High Quality Avoidance로 정밀한 전투 기동</li>
                </ul>
                
                <h4>로봇 파츠별 특성</h4>
                <ul class="content-list">
                    <li><strong>다리 파츠</strong>: 이동 속도와 회전 속도에 영향
                        <ul>
                            <li>바퀴형: 빠른 속도, 느린 회전</li>
                            <li>이족보행: 중간 속도, 빠른 회전</li>
                            <li>궤도형: 느린 속도, 매우 느린 회전</li>
                        </ul>
                    </li>
                    <li><strong>몸통 파츠</strong>: Agent 크기와 우선순위에 영향</li>
                    <li><strong>무기 파츠</strong>: 전투 시 회피 행동에 영향</li>
                </ul>
            </div>
            
            <div class="tech-stack">
                <h3>🔧 핵심 기술</h3>
                
                <h4>NavMesh Agent 설정값</h4>
                <div class="code-block">
// 권장 설정값들
- Radius: 0.5 (통과 가능한 최소 폭)
- Height: 2.0 (로봇의 키)
- Speed: 3.5 (초당 이동 거리)
- Angular Speed: 720 (빠른 회전을 위해 증가)
- Acceleration: 8 (자연스러운 가속)
- Stopping Distance: 1.0 (목표 도달 인식 거리)
- Avoidance Quality: High (정밀한 충돌 회피)
- Priority: 50 (기본 우선순위)
                </div>
                
                <h4>스크립트 패턴</h4>
                <ul class="content-list">
                    <li><strong>RequireComponent</strong>: 필수 컴포넌트 자동 추가</li>
                    <li><strong>Awake에서 GetComponent</strong>: 컴포넌트 참조 초기화</li>
                    <li><strong>Update에서 SetDestination</strong>: 매 프레임 목표 설정</li>
                </ul>
            </div>
        </div>

        <!-- 강의 10: Unit Selection -->
        <div class="lecture-section" id="lecture-10">
            <h2 class="lecture-title">📚 강의 10: Unit Selection (유닛 선택)</h2>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>마우스 좌클릭으로 유닛 선택 구현</li>
                    <li>Decal Projector를 사용한 선택 표시</li>
                    <li>Interface를 활용한 확장 가능한 선택 시스템</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📝 핵심 개념</h3>

                <h4>1. URP Decal Projector</h4>
                <p><strong>선택된 유닛 시각적 표시</strong></p>
                <ul class="content-list">
                    <li>Hierarchy → 우클릭 → Rendering → URP → Decal Projector</li>
                    <li>유닛 위에 원형 표시를 투영하는 방식</li>
                </ul>

                <div class="step-guide">
                    <h5>⚙️ Decal 설정 단계</h5>
                    <ol>
                        <li>Worker Prefab에 Decal Projector 추가</li>
                        <li>URP Renderer에 Decal Feature 추가
                            <ul>
                                <li>Project Settings → Graphics → URP Renderer</li>
                                <li>Add Renderer Feature → Decal</li>
                                <li>Use Rendering Layers 체크</li>
                            </ul>
                        </li>
                        <li>Selection Decal Material 생성
                            <ul>
                                <li>Shader: Shader Graphs/Decal</li>
                                <li>Base Map: Selection Ring 텍스처</li>
                            </ul>
                        </li>
                        <li>Size 조정: Width 1.5, Height 1.5, Projection Depth 8</li>
                    </ol>
                </div>

                <h4>2. Raycast를 통한 유닛 감지</h4>
                <p><strong>Physics Raycast 개념</strong></p>
                <ul class="content-list">
                    <li>원점에서 방향으로 무한히 얇은 선을 쏘는 Physics API</li>
                    <li>충돌 시 true 반환 및 RaycastHit 정보 제공</li>
                    <li>LayerMask로 특정 레이어만 감지 가능</li>
                </ul>

                <p><strong>Camera ScreenPointToRay</strong></p>
                <div class="code-block">Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());</div>
                <ul class="content-list">
                    <li>마우스 화면 좌표를 카메라 관점의 Ray로 변환</li>
                    <li>3D 공간에서 클릭 위치 계산</li>
                </ul>

                <h4>3. Interface를 통한 확장성</h4>
                <p><strong>ISelectable Interface</strong></p>
                <ul class="content-list">
                    <li>다양한 선택 가능 객체(유닛, 건물 등)에 대응</li>
                    <li>각 클래스가 독립적으로 선택/해제 동작 구현</li>
                </ul>

                <div class="code-block"><span class="comment">// 선택 가능한 객체를 정의하는 인터페이스</span>
<span class="comment">// Interface: 클래스가 반드시 구현해야 하는 메서드들을 정의하는 계약</span>
<span class="comment">// ISelectable: "선택 가능한" 객체라는 의미를 가진 인터페이스 이름</span>
<span class="keyword">public interface</span> ISelectable
{
    <span class="comment">// 객체를 선택할 때 호출되는 메서드</span>
    <span class="comment">// Select: 선택 상태로 변경하고 시각적 표시를 활성화</span>
    <span class="keyword">void</span> Select();
    
    <span class="comment">// 객체의 선택을 해제할 때 호출되는 메서드</span>
    <span class="comment">// Deselect: 선택 해제 상태로 변경하고 시각적 표시를 비활성화</span>
    <span class="keyword">void</span> Deselect();
}</div>

                <p><strong>Interface 장점</strong></p>
                <ul class="content-list">
                    <li><code>GetComponent&lt;ISelectable&gt;()</code> 동작</li>
                    <li>Worker, Building 등 다양한 타입에 적용 가능</li>
                    <li>확장성 높은 설계</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>💻 구현 코드</h3>

                <h4>PlayerInput.cs</h4>
                <div class="code-block"><span class="comment">// 플레이어 입력을 처리하는 클래스</span>
<span class="comment">// GameDevTV.RTS.Units: 유닛 관련 클래스들을 포함하는 네임스페이스</span>
<span class="keyword">using</span> GameDevTV.RTS.Units;

<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="comment">// PlayerInput: 플레이어의 입력(마우스, 키보드)을 처리하는 클래스</span>
<span class="keyword">public class</span> PlayerInput : MonoBehaviour
{
    <span class="comment">// 카메라 참조 - 화면 좌표를 월드 좌표로 변환하기 위해 필요</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 하는 Unity 어트리뷰트</span>
    <span class="comment">// new Camera: 부모 클래스의 camera 필드를 숨기기 위해 new 키워드 사용</span>
    [SerializeField] <span class="keyword">private new</span> Camera camera;
    
    <span class="comment">// 현재 선택된 유닛을 저장하는 변수</span>
    <span class="comment">// ISelectable: 선택 가능한 객체를 나타내는 인터페이스</span>
    <span class="keyword">private</span> ISelectable selectedUnit;

    <span class="comment">// 매 프레임마다 호출되는 Unity 생명주기 메서드</span>
    <span class="comment">// Update: 게임이 실행되는 동안 매 프레임마다 호출됨</span>
    <span class="keyword">private void</span> Update()
    {
        <span class="comment">// 각종 입력 처리 메서드들을 매 프레임 호출</span>
        HandlePanning();    <span class="comment">// 카메라 팬닝 (이동) 처리</span>
        HandleZooming();    <span class="comment">// 줌 인/아웃 처리</span>
        HandleRotation();   <span class="comment">// 카메라 회전 처리</span>
        HandleLeftClick();  <span class="comment">// 왼쪽 마우스 클릭 처리</span>
    }

    <span class="comment">// 왼쪽 마우스 클릭을 처리하는 메서드</span>
    <span class="keyword">private void</span> HandleLeftClick()
    {
        <span class="comment">// 카메라가 없으면 메서드 종료 (Guardian Pattern)</span>
        <span class="comment">// Guardian Pattern: 조건을 먼저 확인하여 안전하게 처리하는 패턴</span>
        <span class="keyword">if</span> (camera == <span class="keyword">null</span>) <span class="keyword">return</span>;

        <span class="comment">// 카메라에서 마우스 위치로 레이를 생성</span>
        <span class="comment">// ScreenPointToRay: 화면의 픽셀 좌표를 3D 월드의 레이로 변환</span>
        <span class="comment">// Mouse.current.position.ReadValue(): 현재 마우스 위치를 Vector2로 반환</span>
        Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

        <span class="comment">// 왼쪽 마우스 버튼이 이번 프레임에 놓아졌는지 확인</span>
        <span class="comment">// wasReleasedThisFrame: 버튼이 눌렸다가 놓아진 순간을 감지</span>
        <span class="keyword">if</span> (Mouse.current.leftButton.wasReleasedThisFrame)
        {
            <span class="comment">// 기존 선택 해제</span>
            <span class="comment">// 이전에 선택된 유닛이 있으면 선택 해제</span>
            <span class="keyword">if</span> (selectedUnit != <span class="keyword">null</span>)
            {
                <span class="comment">// 선택된 유닛의 Deselect 메서드 호출</span>
                selectedUnit.Deselect();
                <span class="comment">// 선택된 유닛 참조를 null로 초기화</span>
                selectedUnit = <span class="keyword">null</span>;
            }

            <span class="comment">// 새 유닛 선택</span>
            <span class="comment">// 레이캐스팅으로 클릭한 지점의 오브젝트 감지</span>
            <span class="comment">// Physics.Raycast: 레이를 발사하여 충돌하는 오브젝트를 찾는 Unity 메서드</span>
            <span class="comment">// out RaycastHit hit: 충돌 정보를 담을 변수 (out 키워드로 참조 전달)</span>
            <span class="comment">// float.MaxValue: 무한대 거리까지 레이를 발사</span>
            <span class="comment">// LayerMask.GetMask("Default"): Default 레이어에 있는 오브젝트만 감지</span>
            <span class="keyword">if</span> (Physics.Raycast(cameraRay, <span class="keyword">out</span> RaycastHit hit, <span class="keyword">float</span>.MaxValue, LayerMask.GetMask(<span class="string">"Default"</span>))
                <span class="comment">// 충돌한 오브젝트에서 ISelectable 컴포넌트를 찾음</span>
                <span class="comment">// && 연산자: 앞의 조건이 true일 때만 뒤의 조건을 확인 (단축 평가)</span>
                <span class="comment">// TryGetComponent: 컴포넌트를 찾고 성공 여부를 bool로 반환</span>
                <span class="comment">// out ISelectable selectable: 찾은 ISelectable 컴포넌트를 담을 변수</span>
                && hit.collider.TryGetComponent(<span class="keyword">out</span> ISelectable selectable))
            {
                <span class="comment">// 새로 클릭한 유닛을 선택</span>
                selectable.Select();
                <span class="comment">// 현재 선택된 유닛으로 설정</span>
                selectedUnit = selectable;
            }
        }
    }
}</div>

                <h4>ISelectable.cs</h4>
                <div class="code-block"><span class="comment">// 네임스페이스: 관련된 클래스들을 그룹화하는 C# 기능</span>
<span class="comment">// GameDevTV.RTS.Units: 유닛 관련 클래스들을 포함하는 네임스페이스</span>
<span class="keyword">namespace</span> GameDevTV.RTS.Units
{
    <span class="comment">// 선택 가능한 객체를 정의하는 인터페이스</span>
    <span class="comment">// Interface: 클래스가 반드시 구현해야 하는 메서드들을 정의하는 계약</span>
    <span class="comment">// ISelectable: "선택 가능한" 객체라는 의미를 가진 인터페이스 이름</span>
    <span class="keyword">public interface</span> ISelectable
    {
        <span class="comment">// 객체를 선택할 때 호출되는 메서드</span>
        <span class="comment">// Select: 선택 상태로 변경하고 시각적 표시를 활성화</span>
        <span class="keyword">void</span> Select();
        
        <span class="comment">// 객체의 선택을 해제할 때 호출되는 메서드</span>
        <span class="comment">// Deselect: 선택 해제 상태로 변경하고 시각적 표시를 비활성화</span>
        <span class="keyword">void</span> Deselect();
    }
}</div>

                <h4>Worker.cs</h4>
                <div class="code-block"><span class="comment">// URP Decal Projector를 사용하기 위한 네임스페이스</span>
<span class="comment">// UnityEngine.Rendering.Universal: URP(Universal Render Pipeline) 관련 클래스들</span>
<span class="keyword">using</span> UnityEngine.Rendering.Universal;

<span class="comment">// RequireComponent: 이 컴포넌트가 추가되면 자동으로 NavMeshAgent 컴포넌트도 추가됨</span>
<span class="comment">// typeof(NavMeshAgent): NavMeshAgent 타입을 가져오는 C# 연산자</span>
[RequireComponent(<span class="keyword">typeof</span>(NavMeshAgent))]
<span class="comment">// Worker 클래스: MonoBehaviour를 상속받고 ISelectable 인터페이스를 구현</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="comment">// ISelectable: 선택 가능한 객체를 나타내는 인터페이스</span>
<span class="keyword">public class</span> Worker : MonoBehaviour, ISelectable
{
    <span class="comment">// Decal Projector 컴포넌트 참조</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 하는 Unity 어트리뷰트</span>
    <span class="comment">// DecalProjector: URP에서 데칼(투영) 효과를 만드는 컴포넌트</span>
    [SerializeField] <span class="keyword">private</span> DecalProjector decalProjector;

    <span class="comment">// ISelectable 인터페이스의 Select 메서드 구현</span>
    <span class="comment">// 유닛이 선택되었을 때 호출되는 메서드</span>
    <span class="keyword">public void</span> Select()
    {
        <span class="comment">// Decal Projector가 null이 아닌지 확인 (Guardian Pattern)</span>
        <span class="comment">// null 체크: 컴포넌트가 할당되지 않았을 때 오류를 방지</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        {
            <span class="comment">// Decal Projector의 GameObject를 활성화</span>
            <span class="comment">// SetActive(true): GameObject를 활성화하여 시각적으로 표시</span>
            <span class="comment">// 선택된 유닛 위에 원형 표시가 나타남</span>
            decalProjector.gameObject.SetActive(<span class="keyword">true</span>);
        }
    }

    <span class="comment">// ISelectable 인터페이스의 Deselect 메서드 구현</span>
    <span class="comment">// 유닛의 선택이 해제되었을 때 호출되는 메서드</span>
    <span class="keyword">public void</span> Deselect()
    {
        <span class="comment">// Decal Projector가 null이 아닌지 확인 (Guardian Pattern)</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        {
            <span class="comment">// Decal Projector의 GameObject를 비활성화</span>
            <span class="comment">// SetActive(false): GameObject를 비활성화하여 시각적으로 숨김</span>
            <span class="comment">// 선택 해제된 유닛의 원형 표시가 사라짐</span>
            decalProjector.gameObject.SetActive(<span class="keyword">false</span>);
        }
    }
}</div>
            </div>

            <div class="content-section">
                <h3>⚙️ Unity 설정</h3>

                <h4>Decal Projector 설정</h4>
                <div class="code-block">Width: 1.5
Height: 1.5
Projection Depth: 8
Material: Selection Decal
기본 상태: Disabled (선택되지 않음)</div>

                <h4>Worker Prefab 설정</h4>
                <ol>
                    <li>Capsule Collider 추가
                        <ul>
                            <li>Center Y: 1</li>
                            <li>Height: 2</li>
                        </ul>
                    </li>
                    <li>Decal Projector 컴포넌트 참조 연결</li>
                    <li>Prefab Overrides → Apply All</li>
                </ol>

                <h4>PlayerInput 설정</h4>
                <ul class="content-list">
                    <li>Camera 참조 연결 (Main Camera)</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🐛 버그 수정</h3>

                <div class="problem-solution">
                    <h5>❌ 문제: 같은 유닛 두 번 클릭 시 선택 해제</h5>

                    <p><strong>원인:</strong></p>
                    <div class="code-block">// 잘못된 순서
if (raycast hit && TryGetComponent)
{
    selectable.Select();
    selectedUnit = selectable;
}

if (selectedUnit != null)
{
    selectedUnit.Deselect();
    selectedUnit = null;
}</div>

                    <p><strong>해결:</strong></p>
                    <div class="code-block">// 올바른 순서: 먼저 해제, 그 다음 선택
if (Mouse.current.leftButton.wasReleasedThisFrame)
{
    if (selectedUnit != null)
    {
        selectedUnit.Deselect();
        selectedUnit = null;
    }

    if (raycast hit && TryGetComponent)
    {
        selectable.Select();
        selectedUnit = selectable;
    }
}</div>
                </div>
            </div>

            <div class="content-section">
                <h3>🎓 학습 포인트</h3>

                <h4>1. URP Decal System</h4>
                <ul class="content-list">
                    <li>지형에 관계없이 투영되는 시각적 표시</li>
                    <li>Rendering Layers로 최적화 가능</li>
                    <li>높이 조정으로 지형 돌출 방지</li>
                </ul>

                <h4>2. Raycast 활용</h4>
                <ul class="content-list">
                    <li>ScreenPointToRay로 2D → 3D 변환</li>
                    <li>float.MaxValue로 무한 거리 감지</li>
                    <li>LayerMask로 필요한 객체만 감지</li>
                </ul>

                <h4>3. Interface 패턴</h4>
                <ul class="content-list">
                    <li>다형성을 통한 확장 가능한 설계</li>
                    <li>유닛/건물 등 다양한 타입 지원</li>
                    <li>GetComponent/TryGetComponent 호환</li>
                </ul>

                <h4>4. 상태 관리</h4>
                <ul class="content-list">
                    <li>selectedUnit으로 현재 선택 추적</li>
                    <li>선택 해제 후 새 선택 방식</li>
                    <li>null 체크로 안전성 보장</li>
                </ul>
            </div>

            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>

                <h4>로봇 선택 시스템</h4>
                <ul class="content-list">
                    <li><strong>3개 파츠 로봇</strong>: WorkerThreeRobot도 ISelectable 구현</li>
                    <li><strong>팀 구분 표시</strong>: 아군/적군 색상 다른 Decal 사용</li>
                    <li><strong>선택 피드백</strong>: 로봇 선택 시 UI에 정보 표시</li>
                </ul>

                <h4>4:4 팀전 활용</h4>
                <ul class="content-list">
                    <li><strong>다중 선택</strong>: Shift 클릭으로 여러 로봇 선택</li>
                    <li><strong>드래그 선택</strong>: 박스 드래그로 영역 선택</li>
                    <li><strong>팀 전체 선택</strong>: 단축키로 팀 전체 선택</li>
                </ul>
            </div>

            <div class="tech-stack">
                <h3>🔧 핵심 기술</h3>

                <h4>주요 변경 파일</h4>
                <div class="code-block">Assets/Materials/Selection Decal.mat (신규)
Assets/Scripts/Player/PlayerInput.cs (수정)
Assets/Scripts/Units/ISelectable.cs (신규)
Assets/Scripts/Units/Worker.cs (수정)
Assets/Settings/PC_Renderer.asset (수정)
Assets/Units/Worker/Worker.prefab (수정)</div>

                <h4>다음 단계</h4>
                <ul class="content-list">
                    <li>다중 유닛 선택</li>
                    <li>드래그 박스 선택</li>
                    <li>선택된 유닛 그룹 관리</li>
                </ul>
            </div>
        </div>

        <!-- 강의 11: Unit & Decal Rendering Layers -->
        <div class="lecture-section" id="lecture-11">
            <h2 class="lecture-title">📚 강의 11: Unit & Decal Rendering Layers (유닛 & 데칼 렌더링 레이어)</h2>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Decal Projector가 다른 유닛 위에 렌더링되지 않도록 설정</li>
                    <li>Rendering Layers를 사용하여 바닥에만 투영</li>
                    <li>Physics Layers로 유닛/건물 선택 정밀도 향상</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📝 핵심 개념</h3>

                <h4>1. 문제 상황</h4>
                <p><strong>현재 문제점</strong></p>
                <ul class="content-list">
                    <li>선택된 유닛을 다른 유닛 근처로 이동하면 Decal이 다른 유닛 발 위에도 렌더링됨</li>
                    <li>모든 객체가 기본적으로 Default Rendering Layer에 있음</li>
                    <li>Raycast가 Default Physics Layer의 모든 객체를 감지</li>
                </ul>

                <h4>2. URP Rendering Layers</h4>
                <p><strong>Rendering Layer 개념</strong></p>
                <ul class="content-list">
                    <li>물리 레이어와 별개로 렌더링 제어용 레이어</li>
                    <li>총 8개 레이어 사용 가능 (Unity 권장: 최소한으로 유지)</li>
                    <li>Layer 0: Default (기본값)</li>
                    <li>Decal Projector가 특정 레이어만 영향받도록 제한 가능</li>
                </ul>

                <div class="step-guide">
                    <h5>⚙️ Rendering Layer 설정</h5>
                    <ol>
                        <li>Tags & Layers 창 열기: Edit → Project Settings → Tags and Layers</li>
                        <li>Rendering Layers 섹션 확장</li>
                        <li>Light Layer 1 ~ 7 제거 (최소화)</li>
                        <li>Light Layer 1을 "Floor"로 이름 변경</li>
                    </ol>
                </div>

                <h4>3. Physics Layers</h4>
                <p><strong>Physics Layer 분리</strong></p>
                <ul class="content-list">
                    <li><strong>Units Layer</strong>: 모든 유닛 객체</li>
                    <li><strong>Buildings Layer</strong>: 모든 건물 객체</li>
                    <li>Raycast 시 특정 레이어만 감지하여 정밀도 향상</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>💻 구현 코드</h3>

                <h4>PlayerInput.cs - LayerMask 사용</h4>
                <div class="code-block">public class PlayerInput : MonoBehaviour
{
    [SerializeField] private new Camera camera;
    [SerializeField] private LayerMask selectableUnitsLayers;  // 추가
    private ISelectable selectedUnit;

    private void HandleLeftClick()
    {
        if (camera == null) return;

        Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

        if (Mouse.current.leftButton.wasReleasedThisFrame)
        {
            if (selectedUnit != null)
            {
                selectedUnit.Deselect();
                selectedUnit = null;
            }

            // LayerMask.GetMask("Default") 대신 selectableUnitsLayers 사용
            if (Physics.Raycast(cameraRay, out RaycastHit hit, float.MaxValue, selectableUnitsLayers)
                && hit.collider.TryGetComponent(out ISelectable selectable))
            {
                selectable.Select();
                selectedUnit = selectable;
            }
        }
    }
}</div>
            </div>

            <div class="content-section">
                <h3>⚙️ Unity 설정</h3>

                <h4>1. Rendering Layers 설정</h4>
                <div class="step-guide">
                    <h5>Tags and Layers 설정</h5>
                    <ol>
                        <li>Edit → Project Settings → Tags and Layers</li>
                        <li>Rendering Layers 확장</li>
                        <li>Light Layer 1 = "Floor"</li>
                        <li>나머지 레이어 비활성화</li>
                    </ol>
                </div>

                <h4>2. Decal Projector 설정</h4>
                <div class="step-guide">
                    <h5>Decal이 Floor만 영향받도록</h5>
                    <ol>
                        <li>Worker Prefab의 Decal Projector 선택</li>
                        <li>Rendering Layers: Default 끄고 Floor만 체크</li>
                        <li>Prefab Overrides → Apply All</li>
                        <li>기본 상태: Disabled 확인</li>
                    </ol>
                </div>

                <h4>3. Terrain Rendering Layer 설정</h4>
                <div class="step-guide">
                    <h5>Terrain이 Floor Decal을 받도록</h5>
                    <ol>
                        <li>Terrain 선택</li>
                        <li>Inspector 오른쪽 끝 → Terrain Settings</li>
                        <li>맨 아래 Rendering Layer Mask</li>
                        <li>Default + Floor 체크</li>
                    </ol>
                </div>

                <div class="option-explanation">
                    <h5>💡 참고: 다른 객체 설정</h5>
                    <p><strong>Water (물)</strong></p>
                    <ul class="content-list">
                        <li>투명 객체에는 Decal이 투영되지 않음 (URP 제한)</li>
                        <li>Floor 레이어 추가해도 효과 없음</li>
                    </ul>

                    <p><strong>Coral (산호) 등 환경 객체</strong></p>
                    <ul class="content-list">
                        <li>원하면 Mesh Renderer → Additional Settings → Rendering Layer Mask에 Floor 추가</li>
                        <li>권장: Terrain만 Floor 레이어 사용 (깔끔한 시각)</li>
                    </ul>
                </div>

                <h4>4. Physics Layers 설정</h4>
                <div class="step-guide">
                    <h5>유닛/건물 레이어 추가</h5>
                    <ol>
                        <li>Edit → Project Settings → Tags and Layers</li>
                        <li>Layers 섹션 확장</li>
                        <li>빈 레이어에 "Units" 추가</li>
                        <li>빈 레이어에 "Buildings" 추가</li>
                    </ol>
                </div>

                <h4>5. Worker Prefab Layer 설정</h4>
                <div class="step-guide">
                    <h5>Worker를 Units 레이어로</h5>
                    <ol>
                        <li>Worker Prefab의 루트 GameObject 선택</li>
                        <li>Inspector 상단 Layer → Units</li>
                        <li>"Change This Object Only" 선택 (Collider가 있는 루트만)</li>
                        <li>Prefab Overrides → Apply All</li>
                    </ol>
                </div>

                <h4>6. PlayerInput LayerMask 설정</h4>
                <div class="step-guide">
                    <h5>선택 가능한 레이어 지정</h5>
                    <ol>
                        <li>Main Camera (PlayerInput 컴포넌트 있음) 선택</li>
                        <li>Selectable Units Layers 필드</li>
                        <li>Units + Buildings 체크</li>
                    </ol>
                </div>

                <h4>7. Physics Collision Matrix 설정</h4>
                <div class="step-guide">
                    <h5>⚠️ 중요: 충돌 제거</h5>
                    <ol>
                        <li>Edit → Project Settings → Physics</li>
                        <li>Layer Collision Matrix (Shared 탭)</li>
                        <li>Units와 World Bounds 충돌 체크 해제</li>
                        <li>Buildings와 World Bounds 충돌 체크 해제</li>
                    </ol>
                    <p><strong>이유</strong>: 카메라 타겟의 World Collider Bounds가 유닛과 충돌하지 않도록</p>
                </div>
            </div>

            <div class="content-section">
                <h3>🎓 학습 포인트</h3>

                <h4>1. Rendering Layers vs Physics Layers</h4>
                <ul class="content-list">
                    <li><strong>Rendering Layers</strong>: 렌더링 제어용 (Decal, Light 등)</li>
                    <li><strong>Physics Layers</strong>: 물리 충돌 및 Raycast 제어용</li>
                    <li>두 레이어 시스템은 완전히 독립적</li>
                </ul>

                <h4>2. Serialized LayerMask</h4>
                <ul class="content-list">
                    <li>코드에 레이어 이름 하드코딩 대신 Inspector에서 설정</li>
                    <li>유지보수성 향상: 레이어 추가 시 코드 수정 불필요</li>
                    <li><code>[SerializeField] private LayerMask selectableUnitsLayers;</code></li>
                </ul>

                <h4>3. Layer Collision Matrix</h4>
                <ul class="content-list">
                    <li>새 레이어 추가 시 반드시 충돌 매트릭스 확인</li>
                    <li>기본적으로 모든 레이어가 서로 충돌 설정됨</li>
                    <li>불필요한 충돌은 성능 저하 원인</li>
                </ul>

                <h4>4. URP Decal 제한사항</h4>
                <ul class="content-list">
                    <li>투명 객체(Transparent)에는 투영 불가</li>
                    <li>물, 유리 등에는 Decal 표시 안 됨</li>
                    <li>Opaque 객체에만 투영 가능</li>
                </ul>
            </div>

            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>

                <h4>렌더링 레이어 활용</h4>
                <ul class="content-list">
                    <li><strong>팀 구분 Decal</strong>:
                        <ul>
                            <li>Team1Floor, Team2Floor 레이어 추가</li>
                            <li>아군/적군 다른 색상 Decal 표시</li>
                        </ul>
                    </li>
                    <li><strong>전투 이펙트</strong>: 폭발 Decal은 모든 객체에 투영</li>
                    <li><strong>최적화</strong>: 레이어 분리로 렌더링 부하 감소</li>
                </ul>

                <h4>피직스 레이어 체계</h4>
                <ul class="content-list">
                    <li><strong>Units</strong>: 모든 로봇 유닛</li>
                    <li><strong>Buildings</strong>: 기지, 터렛 등</li>
                    <li><strong>Projectiles</strong>: 미사일, 총알 (Units/Buildings와만 충돌)</li>
                    <li><strong>Team1/Team2</strong>: 팀별 레이어로 아군 오인 사격 방지</li>
                </ul>

                <h4>4:4 팀전 최적화</h4>
                <ul class="content-list">
                    <li><strong>Raycast 정밀도</strong>: 유닛 선택 시 바닥/벽 무시</li>
                    <li><strong>충돌 최소화</strong>: 같은 팀 로봇끼리 충돌 방지</li>
                    <li><strong>Layer 수 제한</strong>: 8개 이하 유지 (성능)</li>
                </ul>
            </div>

            <div class="tech-stack">
                <h3>🔧 핵심 기술</h3>

                <h4>주요 설정 파일</h4>
                <div class="code-block">TagManager.asset (Layers, Rendering Layers)
DynamicsManager.asset (Layer Collision Matrix)
Assets/Scripts/Player/PlayerInput.cs (수정)
Assets/Units/Worker/Worker.prefab (수정)</div>

                <h4>검증 체크리스트</h4>
                <ul class="content-list">
                    <li>✓ Decal이 다른 유닛 위에 렌더링되지 않음</li>
                    <li>✓ Decal이 Terrain에만 표시됨</li>
                    <li>✓ 유닛 클릭 선택이 정상 작동</li>
                    <li>✓ 유닛이 카메라 바운더리와 충돌하지 않음</li>
                </ul>

                <h4>다음 단계</h4>
                <ul class="content-list">
                    <li>다중 유닛 선택 (박스 드래그)</li>
                    <li>유닛 그룹 관리</li>
                    <li>명령 시스템 (이동, 공격)</li>
                </ul>
            </div>
        </div>

        <!-- 강의 12: Unit Movement -->
        <div class="lecture-section" id="lecture-12">
            <h2 class="lecture-title">📚 강의 12: Unit Movement (유닛 우클릭 이동)</h2>

            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>마우스 우클릭으로 선택된 유닛을 이동시키기</li>
                    <li>IMovable 인터페이스로 이동 가능한 객체 정의</li>
                    <li>Floor 레이어로 이동 가능 영역 제한</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📝 핵심 개념</h3>

                <h4>1. 유닛 이동 시스템</h4>
                <p><strong>동작 흐름</strong></p>
                <ul class="content-list">
                    <li>좌클릭으로 유닛 선택 (ISelectable)</li>
                    <li>우클릭으로 이동 목표 지점 지정</li>
                    <li>Raycast로 클릭 위치의 World 좌표 획득</li>
                    <li>NavMeshAgent.SetDestination()으로 이동</li>
                </ul>

                <h4>2. IMovable 인터페이스</h4>
                <p><strong>이동 가능 객체 추상화</strong></p>
                <ul class="content-list">
                    <li>ISelectable처럼 다형성 활용</li>
                    <li>유닛, 차량 등 다양한 이동 객체에 적용 가능</li>
                    <li><code>MoveTo(Vector3 position)</code> 메서드 정의</li>
                </ul>

                <div class="code-block"><span class="comment">// 이동 가능한 객체를 정의하는 인터페이스</span>
<span class="comment">// Interface: 클래스가 반드시 구현해야 하는 메서드들을 정의하는 계약</span>
<span class="comment">// IMovable: "이동 가능한" 객체라는 의미를 가진 인터페이스 이름</span>
<span class="keyword">public interface</span> IMovable
{
    <span class="comment">// 객체를 지정된 위치로 이동시키는 메서드</span>
    <span class="comment">// MoveTo: 이동 목표 지점을 받아서 해당 위치로 이동</span>
    <span class="comment">// Vector3 position: 이동할 목표 위치 (3차원 좌표)</span>
    <span class="comment">// void: 반환값이 없음 (이동 명령만 실행)</span>
    <span class="keyword">void</span> MoveTo(Vector3 position);
}</div>

                <p><strong>⚠️ 주의: Vector3 임포트</strong></p>
                <ul class="content-list">
                    <li>VS Code가 자동으로 <code>System.Numerics.Vector3</code> 임포트할 수 있음</li>
                    <li>반드시 <code>UnityEngine.Vector3</code> 사용해야 함</li>
                    <li>잘못된 임포트 시 컴파일 에러 발생</li>
                </ul>

                <h4>3. Pattern Matching (is 연산자)</h4>
                <p><strong>타입 체크와 캐스팅 동시 수행</strong></p>
                <div class="code-block">// 기존 방식
if (selectedUnit != null)
{
    IMovable movable = selectedUnit as IMovable;
    if (movable != null)
    {
        movable.MoveTo(position);
    }
}

// Pattern Matching 방식 (간결)
if (selectedUnit is IMovable movable)
{
    movable.MoveTo(position);
}</div>

                <h4>4. Floor Layer 분리</h4>
                <p><strong>이동 가능 영역 제한</strong></p>
                <ul class="content-list">
                    <li>Terrain과 Water만 Floor 레이어로 설정</li>
                    <li>미네랄, 가스, 건물 등은 클릭 불가</li>
                    <li>Raycast 시 Floor 레이어만 감지</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>💻 구현 코드</h3>

                <h4>IMovable.cs</h4>
                <div class="code-block">using UnityEngine;

namespace GameDevTV.RTS.Units
{
    public interface IMovable
    {
        void MoveTo(Vector3 position);
    }
}</div>

                <h4>PlayerInput.cs - HandleRightClick 추가</h4>
                <div class="code-block">public class PlayerInput : MonoBehaviour
{
    [SerializeField] private new Camera camera;
    [SerializeField] private LayerMask selectableUnitsLayers;
    [SerializeField] private LayerMask floorLayers;  // 추가
    private ISelectable selectedUnit;

    private void Update()
    {
        HandlePanning();
        HandleZooming();
        HandleRotation();
        HandleLeftClick();
        HandleRightClick();  // 추가
    }

    private void HandleRightClick()
    {
        // 선택된 유닛이 없거나 이동 불가능하면 리턴
        if (selectedUnit == null || selectedUnit is not IMovable movable)
        {
            return;
        }

        Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

        // 우클릭 + Floor 레이어 Raycast
        if (Mouse.current.rightButton.wasReleasedThisFrame
            && Physics.Raycast(cameraRay, out RaycastHit hit, float.MaxValue, floorLayers))
        {
            // 클릭한 지점으로 이동
            movable.MoveTo(hit.point);
        }
    }
}</div>

                <h4>Worker.cs - IMovable 구현</h4>
                <div class="code-block"><span class="comment">// URP Decal Projector를 사용하기 위한 네임스페이스</span>
<span class="comment">// UnityEngine.Rendering.Universal: URP(Universal Render Pipeline) 관련 클래스들</span>
<span class="keyword">using</span> UnityEngine.Rendering.Universal;

<span class="comment">// RequireComponent: 이 컴포넌트가 추가되면 자동으로 NavMeshAgent 컴포넌트도 추가됨</span>
<span class="comment">// typeof(NavMeshAgent): NavMeshAgent 타입을 가져오는 C# 연산자</span>
[RequireComponent(<span class="keyword">typeof</span>(NavMeshAgent))]
<span class="comment">// Worker 클래스: MonoBehaviour를 상속받고 두 개의 인터페이스를 구현</span>
<span class="comment">// MonoBehaviour: Unity에서 GameObject에 컴포넌트로 추가할 수 있는 기본 클래스</span>
<span class="comment">// ISelectable: 선택 가능한 객체를 나타내는 인터페이스</span>
<span class="comment">// IMovable: 이동 가능한 객체를 나타내는 인터페이스</span>
<span class="keyword">public class</span> Worker : MonoBehaviour, ISelectable, IMovable
{
    <span class="comment">// Decal Projector 컴포넌트 참조</span>
    <span class="comment">// [SerializeField]: Inspector에서 할당 가능하도록 하는 Unity 어트리뷰트</span>
    <span class="comment">// DecalProjector: URP에서 데칼(투영) 효과를 만드는 컴포넌트</span>
    [SerializeField] <span class="keyword">private</span> DecalProjector decalProjector;
    
    <span class="comment">// NavMeshAgent 컴포넌트 참조</span>
    <span class="comment">// NavMeshAgent: Unity의 AI 이동을 담당하는 컴포넌트</span>
    <span class="keyword">private</span> NavMeshAgent agent;

    <span class="comment">// 컴포넌트 초기화 - Start보다 먼저 실행됨</span>
    <span class="comment">// Awake: GameObject가 생성될 때 한 번만 호출되는 Unity 생명주기 메서드</span>
    <span class="keyword">private void</span> Awake()
    {
        <span class="comment">// 같은 GameObject에서 NavMeshAgent 컴포넌트를 가져옴</span>
        <span class="comment">// GetComponent: GameObject에 연결된 특정 컴포넌트를 찾는 Unity 메서드</span>
        agent = <span class="keyword">GetComponent</span>&lt;NavMeshAgent&gt;();
    }

    <span class="comment">// ISelectable 인터페이스의 Select 메서드 구현</span>
    <span class="comment">// 유닛이 선택되었을 때 호출되는 메서드</span>
    <span class="keyword">public void</span> Select()
    {
        <span class="comment">// Decal Projector가 null이 아닌지 확인 (Guardian Pattern)</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        {
            <span class="comment">// Decal Projector의 GameObject를 활성화</span>
            <span class="comment">// SetActive(true): GameObject를 활성화하여 시각적으로 표시</span>
            <span class="comment">// 선택된 유닛 위에 원형 표시가 나타남</span>
            decalProjector.gameObject.SetActive(<span class="keyword">true</span>);
        }
    }

    <span class="comment">// ISelectable 인터페이스의 Deselect 메서드 구현</span>
    <span class="comment">// 유닛의 선택이 해제되었을 때 호출되는 메서드</span>
    <span class="keyword">public void</span> Deselect()
    {
        <span class="comment">// Decal Projector가 null이 아닌지 확인 (Guardian Pattern)</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        {
            <span class="comment">// Decal Projector의 GameObject를 비활성화</span>
            <span class="comment">// SetActive(false): GameObject를 비활성화하여 시각적으로 숨김</span>
            <span class="comment">// 선택 해제된 유닛의 원형 표시가 사라짐</span>
            decalProjector.gameObject.SetActive(<span class="keyword">false</span>);
        }
    }

    <span class="comment">// IMovable 인터페이스의 MoveTo 메서드 구현</span>
    <span class="comment">// 유닛을 지정된 위치로 이동시키는 메서드</span>
    <span class="keyword">public void</span> MoveTo(Vector3 position)
    {
        <span class="comment">// NavMeshAgent에게 목표 지점을 설정</span>
        <span class="comment">// SetDestination: AI가 이동할 목표 지점을 지정하는 메서드</span>
        <span class="comment">// position: 이동할 목표 위치 (Vector3)</span>
        <span class="comment">// AI가 자동으로 최적의 경로를 계산하여 이동함</span>
        agent.SetDestination(position);
    }
}</div>
            </div>

            <div class="content-section">
                <h3>⚙️ Unity 설정</h3>

                <h4>1. Floor Layer 추가</h4>
                <div class="step-guide">
                    <h5>Layer 생성</h5>
                    <ol>
                        <li>Edit → Project Settings → Tags and Layers</li>
                        <li>Layers 섹션 확장</li>
                        <li>User Layer 8에 "Floor" 추가</li>
                    </ol>
                </div>

                <h4>2. Terrain과 Water를 Floor 레이어로</h4>
                <div class="step-guide">
                    <h5>계층 구조에서 Floor 선택</h5>
                    <ol>
                        <li>Hierarchy에서 Floor GameObject 선택</li>
                        <li>자식 Terrain과 Water 모두 선택 (Ctrl/Cmd + 클릭)</li>
                        <li>Inspector 상단 Layer → Floor</li>
                        <li>"No, this object only" 선택 (자식 객체는 변경 안 함)</li>
                    </ol>
                </div>

                <h4>3. Physics Collision Matrix 설정</h4>
                <div class="step-guide">
                    <h5>⚠️ 중요: Floor와 World Bounds 충돌 제거</h5>
                    <ol>
                        <li>Edit → Project Settings → Physics</li>
                        <li>Layer Collision Matrix (Shared 탭)</li>
                        <li>Floor와 World Bounds 충돌 체크 해제</li>
                    </ol>
                    <p><strong>이유</strong>: 바닥이 카메라 경계와 충돌하면 안 됨</p>
                </div>

                <h4>4. PlayerInput LayerMask 설정</h4>
                <div class="step-guide">
                    <h5>Floor Layers 필드 설정</h5>
                    <ol>
                        <li>Main Camera (PlayerInput 컴포넌트) 선택</li>
                        <li>Floor Layers 필드에 Floor만 체크</li>
                    </ol>
                </div>
            </div>

            <div class="content-section">
                <h3>🎓 학습 포인트</h3>

                <h4>1. RaycastHit.point</h4>
                <ul class="content-list">
                    <li>Raycast가 충돌한 World 좌표</li>
                    <li>마우스 클릭 위치를 3D 좌표로 변환</li>
                    <li>NavMeshAgent.SetDestination()에 직접 전달 가능</li>
                </ul>

                <h4>2. Pattern Matching (C# 7.0+)</h4>
                <ul class="content-list">
                    <li><code>is</code> 연산자로 타입 체크 + 변수 할당</li>
                    <li><code>is not</code>으로 부정 체크 (C# 9.0+)</li>
                    <li>코드 간결성 향상</li>
                </ul>

                <h4>3. Guardian Pattern</h4>
                <ul class="content-list">
                    <li>조기 리턴(Early Return)으로 중첩 if 방지</li>
                    <li><code>if (condition) return;</code> 형태</li>
                    <li>가독성과 유지보수성 향상</li>
                </ul>

                <h4>4. Layer 분리 전략</h4>
                <ul class="content-list">
                    <li><strong>Selectable Layers</strong>: 선택 가능한 객체 (Units, Buildings)</li>
                    <li><strong>Floor Layers</strong>: 이동 가능한 지형 (Terrain, Water)</li>
                    <li><strong>Rendering Layers</strong>: 렌더링 제어 (Floor Decal)</li>
                    <li>각 용도에 맞는 레이어 분리로 정밀 제어</li>
                </ul>
            </div>

            <div class="project-application">
                <h3>🎮 노바1492 프로젝트 적용 포인트</h3>

                <h4>로봇 이동 시스템</h4>
                <ul class="content-list">
                    <li><strong>3파츠 로봇</strong>: WorkerThreeRobot도 IMovable 구현</li>
                    <li><strong>이동 애니메이션</strong>: MoveTo 호출 시 Walk 애니메이션 재생</li>
                    <li><strong>이동 이펙트</strong>: 목표 지점에 링 이펙트 표시</li>
                </ul>

                <h4>4:4 팀전 명령 시스템</h4>
                <ul class="content-list">
                    <li><strong>다중 유닛 이동</strong>: 선택된 여러 유닛을 포메이션으로 이동</li>
                    <li><strong>공격 이동</strong>: Shift + 우클릭으로 경로에 적 자동 공격</li>
                    <li><strong>순찰 명령</strong>: Ctrl + 우클릭으로 순찰 경로 설정</li>
                </ul>

                <h4>Layer 체계 확장</h4>
                <ul class="content-list">
                    <li><strong>Floor</strong>: 일반 지형 (모든 유닛 이동 가능)</li>
                    <li><strong>FlyingFloor</strong>: 공중 유닛만 이동 가능</li>
                    <li><strong>RestrictedArea</strong>: 특정 팀만 이동 가능 (기지 내부)</li>
                </ul>
            </div>

            <div class="tech-stack">
                <h3>🔧 핵심 기술</h3>

                <h4>주요 변경 파일</h4>
                <div class="code-block">Assets/Scripts/Units/IMovable.cs (신규)
Assets/Scripts/Player/PlayerInput.cs (수정)
Assets/Scripts/Units/Worker.cs (수정)
ProjectSettings/TagManager.asset (Floor 레이어 추가)
ProjectSettings/DynamicsManager.asset (충돌 매트릭스 수정)</div>

                <h4>검증 체크리스트</h4>
                <ul class="content-list">
                    <li>✓ 좌클릭으로 유닛 선택</li>
                    <li>✓ 우클릭으로 유닛 이동</li>
                    <li>✓ 지형(Terrain)만 클릭 가능</li>
                    <li>✓ 미네랄/가스는 클릭 불가</li>
                    <li>✓ 여러 유닛이 서로 회피하며 이동</li>
                </ul>

                <h4>다음 단계</h4>
                <ul class="content-list">
                    <li>다중 유닛 선택 (박스 드래그)</li>
                    <li>유닛 포메이션 이동</li>
                    <li>공격 명령 시스템</li>
                    <li>건물 건설 시스템</li>
                </ul>
            </div>
        </div>

        <div class="summary-section" id="summary">
            <h2>🎯 노바1492 프로젝트 종합 적용 방안</h2>
            
            <h3>🚀 핵심 시스템 통합</h3>
            <p><strong>로봇 파츠 커스터마이징 시스템</strong>: SciFi Pack 모델들을 로봇 파츠 기본 형태로 활용</p>
            <p><strong>4:4 팀전 카메라 시스템</strong>: 전체 전장 관찰과 개별 로봇 관리</p>
            <p><strong>서버 분리 아키텍처</strong>: 모듈화된 구조로 나중에 멀티플레이어 지원</p>
            
            <h3>🔧 기술 스택 통합</h3>
            <p><strong>Unity 6.0 + C#</strong>: 새로운 Input System, Cinemachine, URP</p>
            <p><strong>멀티플레이어 준비</strong>: Photon 또는 Mirror로 4:4 팀 매칭 시스템</p>
            
            <h3>📊 강의 통계</h3>
            <p><strong>총 14개 강의</strong> | <strong>10-11시간</strong> | <strong>난이도: ⭐⭐⭐☆☆</strong></p>

            <h3>🚀 다음 단계</h3>
            <p>유닛 시스템 구현 → 전투 시스템 구현 → UI 시스템 구현 → 멀티플레이어 구현</p>
            <p>각 강의에서 학습한 내용을 <strong>노바1492 스타일 로봇 대전 게임</strong>에 적용하여 3개월 내에 MVP를 완성할 수 있을 것입니다! 🎮</p>
        </div>
    </div>

    <!-- ==================== 강의 13 ==================== -->
    <div class="lecture-section" id="lecture-13">
        <h2 class="lecture-title">강의 13: Drag Selection UI (드래그 선택 UI 구현)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>마우스 드래그로 다중 유닛 선택을 위한 **UI 박스** 구현</li>
                <li>**RectTransform**을 사용한 UI 동적 크기 조정</li>
                <li>드래그 선택의 3단계 상태 관리 (시작, 드래그 중, 종료)</li>
                <li>UI Canvas 설정과 Pixel Perfect 렌더링</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. 드래그 선택 상태 관리</h4>
            <p>드래그 선택은 3가지 상태로 나뉩니다:</p>
            <div class="code-block">// 1. 마우스 왼쪽 버튼 **처음 눌렀을 때** (wasPressedThisFrame)
- Selection Box UI 활성화
- 시작 위치 저장

// 2. 마우스 왼쪽 버튼 **누르고 있는 동안** (isPressed && !wasPressedThisFrame)
- Selection Box 크기 조정 (ResizeSelectionBox)

// 3. 마우스 왼쪽 버튼 **놓았을 때** (wasReleasedThisFrame)
- 박스 안의 유닛 선택 (다음 강의에서 구현)
- 박스 밖의 유닛 선택 해제
- Selection Box UI 비활성화</div>

            <h4>2. RectTransform UI 위치/크기 조정</h4>
            <p>UI는 Transform이 아닌 **RectTransform**을 사용합니다:</p>
            <div class="code-block">// anchoredPosition: Anchor 기준 상대 위치
selectionBox.anchoredPosition = startingMousePosition + new Vector2(width / 2, height / 2);

// sizeDelta: UI 요소의 크기
selectionBox.sizeDelta = new Vector2(Mathf.Abs(width), Mathf.Abs(height));</div>

            <h4>3. UI Pivot과 Anchor</h4>
            <p>**Pivot (0.5, 0.5)**: UI 중심점이 중앙에 있음 → 크기 변경 시 양쪽으로 확장</p>
            <p>**Anchor (0, 0)**: UI 좌표 원점이 좌하단 → 마우스 좌표와 일치</p>
            <div class="code-block">// Pivot이 중앙이므로 위치를 width/2, height/2만큼 이동
// 마우스 시작점 + (현재점 - 시작점) / 2 = 박스 중심
anchoredPosition = start + (current - start) / 2

// 크기는 절댓값으로 설정 (음수 방향 드래그 대응)
sizeDelta = new Vector2(Mathf.Abs(width), Mathf.Abs(height))</div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>PlayerInput.cs 수정</h4>
            <div class="code-block">using GameDevTV.RTS.Units;
using Unity.Cinemachine;
using UnityEngine;
using UnityEngine.InputSystem;

namespace GameDevTV.RTS.Player
{
    public class PlayerInput : MonoBehaviour
    {
        [SerializeField] private RectTransform selectionBox;  // ✅ 추가

        private Vector2 startingMousePosition;  // ✅ 추가
        private ISelectable selectedUnit;

        private void Update()
        {
            HandlePanning();
            HandleZooming();
            HandleRotation();
            HandleLeftClick();
            HandleRightClick();
            HandleDragSelect();  // ✅ 추가
        }

        private void HandleDragSelect()
        {
            if (selectionBox == null) 
            { 
                return; 
            }  // Guardian Pattern

            // 1️⃣ 마우스 왼쪽 버튼 처음 눌렀을 때
            if (Mouse.current.leftButton.wasPressedThisFrame)
            {
                selectionBox.gameObject.SetActive(true);
                startingMousePosition = Mouse.current.position.ReadValue();
            }
            // 2️⃣ 드래그 중 (누르고 있는 동안)
            else if (Mouse.current.leftButton.isPressed && !Mouse.current.leftButton.wasPressedThisFrame)
            {
                ResizeSelectionBox();
            }
            // 3️⃣ 마우스 왼쪽 버튼 놓았을 때
            else if (Mouse.current.leftButton.wasReleasedThisFrame)
            {
                // TODO: select new units
                // TODO: deselect non-included units
                selectionBox.gameObject.SetActive(false);
            }
        }

        private void ResizeSelectionBox()
        {
            Vector2 mousePosition = Mouse.current.position.ReadValue();

            float width = mousePosition.x - startingMousePosition.x;
            float height = mousePosition.y - startingMousePosition.y;

            // Pivot이 중앙이므로 width/2, height/2만큼 이동
            selectionBox.anchoredPosition = startingMousePosition + new Vector2(width / 2, height / 2);

            // 음수 방향 드래그를 위해 절댓값 사용
            selectionBox.sizeDelta = new Vector2(Mathf.Abs(width), Mathf.Abs(height));
        }
    }
}</div>
        </div>

        <div class="content-section">
            <h3>⚙️ Unity 설정</h3>

            <div class="step-guide">
                <h5>📌 Selection Canvas 생성</h5>
                <ol>
                    <li>Hierarchy 우클릭 → UI → Canvas → 이름: <code>Selection Canvas</code></li>
                    <li>Canvas Scaler 설정:
                        <ul>
                            <li>UI Scale Mode: <code>Constant Pixel Size</code> ⚠️ 중요</li>
                            <li>Scale Factor: <code>1</code></li>
                            <li>Reference Pixels Per Unit: <code>100</code></li>
                        </ul>
                    </li>
                    <li>이유: 다른 UI Scale Mode는 마우스 좌표와 매칭이 안 됨</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>📌 Selection Box UI 생성</h5>
                <ol>
                    <li>Selection Canvas 우클릭 → UI → Image → 이름: <code>Selection Box</code></li>
                    <li>Inspector 설정:
                        <ul>
                            <li>Color: <code>#68BBFC</code>, Alpha: <code>0.2</code> (반투명 파랑)</li>
                            <li>Rect Transform → Anchors: <code>Bottom Left (0, 0)</code> ⚠️ 중요</li>
                            <li>Width: <code>0</code>, Height: <code>0</code></li>
                            <li>GameObject: <code>비활성화</code> (기본 숨김)</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>📌 PlayerInput 연결</h5>
                <ol>
                    <li>Hierarchy → Main Camera 선택</li>
                    <li>PlayerInput 컴포넌트 → Selection Box 필드에 <code>Selection Box</code> 드래그</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul class="content-list">
                <li><strong>Canvas Scaler의 중요성</strong>: Constant Pixel Size가 아니면 마우스 좌표 계산이 틀어짐</li>
                <li><strong>RectTransform.anchoredPosition</strong>: Anchor 기준 상대 위치 (Transform.position과 다름)</li>
                <li><strong>RectTransform.sizeDelta</strong>: UI 크기 직접 설정</li>
                <li><strong>Pivot 중앙 (0.5, 0.5)</strong>: 크기 변경 시 중심에서 양쪽으로 확장</li>
                <li><strong>Mathf.Abs()</strong>: 음수 방향 드래그 (오른쪽→왼쪽, 위→아래)도 정상 작동</li>
                <li><strong>Guardian Pattern</strong>: <code>if (selectionBox == null) return;</code>으로 null 체크</li>
                <li><strong>상태 기반 로직</strong>: wasPressedThisFrame → isPressed → wasReleasedThisFrame 순서 중요</li>
            </ul>
        </div>

        <div class="project-application">
            <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>다중 로봇 선택</strong>: 4:4 팀전에서 여러 로봇을 한 번에 선택하여 명령</li>
                <li><strong>팀 단위 작전</strong>: 드래그로 로봇 그룹 선택 후 포메이션 이동</li>
                <li><strong>선택 UI 커스터마이징</strong>: 팀 색상에 맞춘 Selection Box (파랑/빨강)</li>
                <li><strong>선택 제한</strong>: 아군 로봇만 선택 가능하도록 LayerMask 필터링</li>
                <li><strong>선택 피드백</strong>: Selection Box 테두리 애니메이션 또는 그라디언트 효과</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>RectTransform</strong>: UI 위치/크기 동적 조정</li>
                <li><strong>Canvas Scaler</strong>: Constant Pixel Size로 픽셀 좌표 매칭</li>
                <li><strong>Anchor & Pivot</strong>: UI 좌표계 이해</li>
                <li><strong>Input System</strong>: wasPressedThisFrame, isPressed, wasReleasedThisFrame</li>
                <li><strong>Vector2 연산</strong>: 마우스 시작/종료 좌표로 박스 크기 계산</li>
                <li><strong>Mathf.Abs()</strong>: 음수 드래그 대응</li>
            </ul>
        </div>
    </div>

    <!-- ==================== 강의 14 ==================== -->
    <div class="lecture-section" id="lecture-14">
        <h2 class="lecture-title">강의 14: The Event Bus (이벤트 버스 디자인 패턴)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>**Event Bus** 디자인 패턴으로 컴포넌트 간 **느슨한 결합(Loose Coupling)** 구현</li>
                <li>**Generic Type**과 **Delegate**를 사용한 타입 안전 이벤트 시스템</li>
                <li>**Publisher-Consumer** 패턴으로 컴포넌트 간 통신 분리</li>
                <li>Singleton을 대체하는 **상태 없는 정적 클래스** 설계</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. Event Bus란?</h4>
            <p>Event Bus는 **Publisher(발행자)**와 **Consumer(구독자)** 간 통신을 **중개**하는 디자인 패턴입니다:</p>
            <div class="code-block">Publisher (발행자)          Event Bus (중개자)         Consumer (구독자)
     Worker                       ↓                    PlayerInput
        |                         |                         ↑
        | Raise(UnitSelectedEvent) → Bus.OnEvent ──────────┘
        |                         |
        └─────────────────────────┴── 서로를 몰라도 통신 가능</div>

            <h4>2. 느슨한 결합(Loose Coupling)의 장점</h4>
            <ul class="content-list">
                <li>**Publisher와 Consumer가 서로를 모름** → 의존성 제거</li>
                <li>**Singleton 패턴 회피** → 전역 상태(Global State) 없음</li>
                <li>**변경 격리** → 한 시스템 변경이 다른 시스템에 영향 없음</li>
                <li>**테스트 용이** → 각 컴포넌트를 독립적으로 테스트 가능</li>
            </ul>

            <h4>3. Generic Type과 Delegate</h4>
            <p>**Generic Type `<T>`**: 어떤 타입이든 받을 수 있는 재사용 가능 클래스</p>
            <div class="code-block">// T는 임의의 타입 (UnitSelectedEvent, UnitDeselectedEvent 등)
public static class Bus<T> where T : IEvent
{
    // delegate: 특정 함수 시그니처를 정의하는 타입
    public delegate void Event(T args);

    // event 키워드: 외부에서 직접 Invoke 불가, Raise()만 호출 가능
    public static event Event OnEvent;
}</div>

            <h4>4. Subscribe / Unsubscribe 패턴</h4>
            <div class="code-block">// 구독 (+=)
Bus<UnitSelectedEvent>.OnEvent += HandleUnitSelected;

// 구독 해제 (-=)
Bus<UnitSelectedEvent>.OnEvent -= HandleUnitSelected;

// ⚠️ 중요: 구독 해제를 안 하면 메모리 누수 발생!</div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>1. IEvent.cs (이벤트 마커 인터페이스)</h4>
            <div class="code-block">using GameDevTV.RTS.EventBus;

namespace GameDevTV.RTS.EventBus
{
    public interface IEvent
    {
        // 마커 인터페이스: 이벤트 버스를 통과할 타입을 제한
    }
}</div>

            <h4>2. Bus.cs (Generic Event Bus)</h4>
            <div class="code-block">using GameDevTV.RTS.EventBus;

namespace GameDevTV.RTS.EventBus
{
    public static class Bus<T> where T : IEvent
    {
        // Delegate: 함수 시그니처 정의 (T를 인자로 받는 함수)
        public delegate void Event(T args);

        // event 키워드: 외부에서 OnEvent?.Invoke() 직접 호출 불가
        public static event Event OnEvent;

        // Raise: 이벤트 발행 (Publisher가 호출)
        public static void Raise(T evt) => OnEvent?.Invoke(evt);

        // ?: Null-conditional operator (OnEvent가 null이면 호출 안 함)
    }
}</div>

            <h4>3. UnitSelectedEvent.cs (구체적 이벤트 타입)</h4>
            <div class="code-block">using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Units;

namespace GameDevTV.RTS.Events
{
    public struct UnitSelectedEvent : IEvent
    {
        // Immutable: 외부에서 변경 불가
        public ISelectable Unit 
        { 
            get; 
            private set; 
        }

        public UnitSelectedEvent(ISelectable unit)
        {
            Unit = unit;
        }
    }
}</div>

            <h4>4. Worker.cs (Publisher 역할)</h4>
            <div class="code-block">using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;

public class Worker : MonoBehaviour, ISelectable, IMoveable
{
    public void Select()
    {
        if (decalProjector != null)
        {
            decalProjector.gameObject.SetActive(true);
        }

        // ✅ 이벤트 발행 (Publisher)
        Bus<UnitSelectedEvent>.Raise(new UnitSelectedEvent(this));
    }
}</div>

            <h4>5. PlayerInput.cs (Consumer 역할)</h4>
            <div class="code-block">using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;

public class PlayerInput : MonoBehaviour
{
    private ISelectable selectedUnit;

    private void Awake()
    {
        // ✅ 이벤트 구독 (Consumer)
        Bus<UnitSelectedEvent>.OnEvent += HandleUnitSelected;
    }

    private void OnDestroy()
    {
        // ✅ 이벤트 구독 해제 (메모리 누수 방지)
        Bus<UnitSelectedEvent>.OnEvent -= HandleUnitSelected;
    }

    private void HandleUnitSelected(UnitSelectedEvent evt)
    {
        // 기존 선택 유닛 해제
        if (selectedUnit != null)
        {
            selectedUnit.Deselect();
        }

        // 새 유닛 선택
        selectedUnit = evt.Unit;
    }

    private void HandleLeftClick()
    {
        // ... (Raycast로 유닛 클릭 감지)
        if (Physics.Raycast(..., out ISelectable selectable))
        {
            selectable.Select(); // → Worker.Select() → Bus.Raise()
            // selectedUnit = selectable; ❌ 제거 (이벤트 핸들러에서 처리)
        }
    }
}</div>
        </div>

        <div class="content-section">
            <h3>⚙️ 실행 흐름</h3>

            <div class="step-guide">
                <h5>📌 이벤트 발행 → 구독 → 처리 흐름</h5>
                <ol>
                    <li><strong>Awake()</strong>: PlayerInput이 <code>Bus&lt;UnitSelectedEvent&gt;.OnEvent</code>에 구독</li>
                    <li><strong>좌클릭</strong>: Raycast로 Worker 클릭 감지</li>
                    <li><strong>Worker.Select()</strong>: <code>Bus&lt;UnitSelectedEvent&gt;.Raise(new UnitSelectedEvent(this))</code> 호출</li>
                    <li><strong>Bus.Raise()</strong>: <code>OnEvent?.Invoke(evt)</code> → 모든 구독자에게 알림</li>
                    <li><strong>HandleUnitSelected()</strong>: PlayerInput이 이벤트 받아서 <code>selectedUnit</code> 업데이트</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul class="content-list">
                <li><strong>Generic Type `<T>`</strong>: 타입 파라미터로 재사용 가능한 클래스 작성</li>
                <li><strong>where T : IEvent</strong>: Generic 제약 조건 (IEvent만 허용)</li>
                <li><strong>Delegate</strong>: 함수 시그니처를 타입으로 정의 (<code>delegate void Event(T args)</code>)</li>
                <li><strong>event 키워드</strong>: 외부에서 직접 Invoke 불가, Raise()만 호출 가능</li>
                <li><strong>?. (Null-conditional)</strong>: <code>OnEvent?.Invoke(evt)</code> → OnEvent가 null이면 호출 안 함</li>
                <li><strong>Expression-bodied function</strong>: <code>public static void Raise(T evt) => OnEvent?.Invoke(evt);</code></li>
                <li><strong>+=/-= 연산자</strong>: 이벤트 구독/구독 해제</li>
                <li><strong>Awake/OnDestroy 쌍</strong>: 구독은 Awake, 해제는 OnDestroy에서 (메모리 누수 방지)</li>
            </ul>
        </div>

        <div class="project-application">
            <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>다중 이벤트 시스템</strong>: UnitDied, RobotDamaged, TeamScoreChanged 등</li>
                <li><strong>UI 업데이트 분리</strong>: 게임 로직과 UI를 이벤트로 분리 (체력바, 점수판)</li>
                <li><strong>멀티플레이어 대응</strong>: 네트워크 이벤트와 로컬 이벤트 분리</li>
                <li><strong>시스템 간 통신</strong>: 전투 시스템 ↔ 경제 시스템 ↔ UI 시스템 느슨한 결합</li>
                <li><strong>디버깅 용이</strong>: 이벤트 로그로 시스템 간 상호작용 추적</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>Generic Type</strong>: <code>Bus&lt;T&gt; where T : IEvent</code></li>
                <li><strong>Delegate</strong>: 함수 시그니처 타입 정의</li>
                <li><strong>Event 키워드</strong>: 캡슐화된 이벤트 발행</li>
                <li><strong>Null-conditional (?.)  </strong>: 안전한 메서드 호출</li>
                <li><strong>Expression-bodied members</strong>: 한 줄 함수 간결 표현</li>
                <li><strong>Publisher-Consumer 패턴</strong>: 이벤트 기반 아키텍처</li>
            </ul>
        </div>
    </div>

    <!-- 강의 15: Deselecting Units with Event Bus -->
    <div class="lecture-section" id="lecture-15">
        <h2 class="lecture-title">📚 강의 15: Deselecting Units with Event Bus (이벤트 버스로 유닛 선택 해제)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>UnitDeselectedEvent 생성하여 선택 해제 이벤트 구현</li>
                <li>Event Bus 패턴 확장하여 여러 이벤트 타입 관리</li>
                <li>상태 관리 로직을 이벤트 핸들러로 분리</li>
                <li>OnDestroy에서 이벤트 구독 해제하여 메모리 누수 방지</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. Discrete Event Structs (개별 이벤트 구조체)</h4>
            <p>각 이벤트마다 별도의 struct를 생성하는 이유:</p>
            <div class="code-block">
<span class="comment">// ❌ Bad: 하나의 이벤트에 여러 상태 포함</span>
<span class="keyword">public struct</span> <span class="class-name">UnitSelectionEvent</span> : IEvent
<span class="keyword">{</span>
    <span class="keyword">public</span> ISelectable Unit;
    <span class="keyword">public bool</span> WasSelected;  <span class="comment">// 선택/해제를 bool로 구분 (복잡함)</span>
<span class="keyword">}</span>

<span class="comment">// ✅ Good: 각 이벤트는 명확한 단일 목적</span>
<span class="keyword">public struct</span> <span class="class-name">UnitSelectedEvent</span> : IEvent
<span class="keyword">{</span>
    <span class="keyword">public</span> ISelectable Unit 
    { 
        <span class="keyword">get</span>; 
        <span class="keyword">private set</span>; 
    }
<span class="keyword">}</span>

<span class="keyword">public struct</span> <span class="class-name">UnitDeselectedEvent</span> : IEvent
<span class="keyword">{</span>
    <span class="keyword">public</span> ISelectable Unit 
    { 
        <span class="keyword">get</span>; 
        <span class="keyword">private set</span>; 
    }
<span class="keyword">}</span>
            </div>

            <h4>2. 이벤트 핸들러 분리</h4>
            <p>상태 관리를 직접 하지 않고 이벤트 핸들러에 위임:</p>
            <div class="code-block">
<span class="comment">// Before (강의 14): HandleLeftClick에서 selectedUnit 직접 관리</span>
<span class="keyword">if</span> (selectedUnit != <span class="keyword">null</span>)
<span class="keyword">{</span>
    selectedUnit.Deselect();
    selectedUnit = <span class="keyword">null</span>;  <span class="comment">// 직접 null 설정</span>
<span class="keyword">}</span>

<span class="comment">// After (강의 15): 이벤트 발행만 하고, 핸들러가 상태 관리</span>
<span class="keyword">if</span> (selectedUnit != <span class="keyword">null</span>)
<span class="keyword">{</span>
    selectedUnit.Deselect();  <span class="comment">// UnitDeselectedEvent 발행</span>
    <span class="comment">// HandleUnitDeselected()가 selectedUnit = null 처리</span>
<span class="keyword">}</span>
            </div>

            <h4>3. 메모리 누수 방지 (Unsubscribe)</h4>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">Awake</span>()
<span class="keyword">{</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent += HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent += HandleUnitDeselected;
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">OnDestroy</span>()
<span class="keyword">{</span>
    <span class="comment">// 반드시 구독 해제! 안 하면 메모리 누수</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent -= HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent -= HandleUnitDeselected;
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>UnitDeselectedEvent.cs</h4>
            <div class="code-block">
<span class="keyword">using</span> GameDevTV.RTS.EventBus;
<span class="keyword">using</span> GameDevTV.RTS.Units;

<span class="keyword">namespace</span> GameDevTV.RTS.Events
<span class="keyword">{</span>
    <span class="keyword">public struct</span> <span class="class-name">UnitDeselectedEvent</span> : IEvent
    <span class="keyword">{</span>
        <span class="keyword">public</span> ISelectable Unit 
        { 
            <span class="keyword">get</span>; 
            <span class="keyword">private set</span>; 
        }

        <span class="keyword">public</span> <span class="method-name">UnitDeselectedEvent</span>(ISelectable unit)
        <span class="keyword">{</span>
            Unit = unit;
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>

            <h4>Worker.cs - Deselect() 이벤트 발행 (강의에서는 변경 없음)</h4>
            <p><strong>주의:</strong> Worker.cs는 이번 강의에서 수정되지 않았습니다. Deselect()는 시각적 피드백만 처리하고, 이벤트 발행은 하지 않습니다.</p>
            <div class="code-block">
<span class="keyword">public void</span> <span class="method-name">Deselect</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
    <span class="keyword">{</span>
        decalProjector.gameObject.SetActive(<span class="keyword">false</span>);
    <span class="keyword">}</span>
    <span class="comment">// 이벤트 발행 없음 (강의 내용과 다를 수 있음)</span>
<span class="keyword">}</span>
            </div>

            <h4>PlayerInput.cs - 이벤트 구독 및 핸들러</h4>
            <div class="code-block">
<span class="keyword">private</span> ISelectable selectedUnit;

<span class="keyword">private void</span> <span class="method-name">Awake</span>()
<span class="keyword">{</span>
    <span class="comment">// 기존 코드...</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent += HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent += HandleUnitDeselected;  <span class="comment">// 새 이벤트 구독</span>
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">OnDestroy</span>()
<span class="keyword">{</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent -= HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent -= HandleUnitDeselected;  <span class="comment">// 구독 해제 추가</span>
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">HandleUnitSelected</span>(UnitSelectedEvent evt)
<span class="keyword">{</span>
    selectedUnit = evt.Unit;  <span class="comment">// 간결해짐 (이전 선택 해제는 HandleLeftClick에서)</span>
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">HandleUnitDeselected</span>(UnitDeselectedEvent evt)
<span class="keyword">{</span>
    selectedUnit = <span class="keyword">null</span>;  <span class="comment">// 선택 해제 상태 관리</span>
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">HandleLeftClick</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (camera == <span class="keyword">null</span>) 
    { 
        <span class="keyword">return</span>; 
    }

    Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

    <span class="keyword">if</span> (Mouse.current.leftButton.wasReleasedThisFrame)
    <span class="keyword">{</span>
        <span class="comment">// 기존 선택 해제 (이벤트 발행)</span>
        <span class="keyword">if</span> (selectedUnit != <span class="keyword">null</span>)
        <span class="keyword">{</span>
            selectedUnit.Deselect();  <span class="comment">// UnitDeselectedEvent 발행 예상</span>
        <span class="keyword">}</span>

        <span class="comment">// 새 유닛 선택</span>
        <span class="keyword">if</span> (Physics.Raycast(cameraRay, <span class="keyword">out</span> RaycastHit hit, <span class="keyword">float</span>.MaxValue, selectableUnitsLayers)
            && hit.collider.TryGetComponent(<span class="keyword">out</span> ISelectable selectable))
        <span class="keyword">{</span>
            selectable.Select();  <span class="comment">// UnitSelectedEvent 발행</span>
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>⚙️ Unity 설정</h3>
            <p>이번 강의에서는 Unity 에디터 설정 변경이 없습니다. 모든 변경사항은 스크립트에서만 발생합니다.</p>
        </div>

        <div class="content-section">
            <h3>🐛 주의사항</h3>
            <div class="problem-solution">
                <h5>⚠️ 강의와 실제 코드 차이점</h5>
                <p><strong>강의 내용:</strong> Worker.Deselect()에서 <code>Bus&lt;UnitDeselectedEvent&gt;.Raise()</code> 호출</p>
                <p><strong>실제 커밋:</strong> Worker.cs는 수정되지 않았고, Deselect()는 이벤트를 발행하지 않음</p>
                <p><strong>이유:</strong> 강의 진행 중 구현 방식이 변경되었을 가능성. PlayerInput에서 직접 Deselect() 호출 후 별도로 상태 관리하는 방식으로 보임.</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ OnDestroy에서 구독 해제 필수</h5>
                <p>이벤트 구독을 해제하지 않으면 GameObject가 파괴되어도 이벤트 핸들러가 남아있어 메모리 누수 및 NullReferenceException 발생 가능.</p>
                <div class="code-block">
<span class="comment">// ✅ Good: Awake와 OnDestroy 쌍으로 관리</span>
<span class="keyword">private void</span> <span class="method-name">Awake</span>()
<span class="keyword">{</span>
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent += HandleUnitDeselected;
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">OnDestroy</span>()
<span class="keyword">{</span>
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent -= HandleUnitDeselected;  <span class="comment">// 반드시 해제</span>
<span class="keyword">}</span>
                </div>
            </div>
        </div>

        <div class="content-section">
            <h3>🔄 실행 흐름</h3>
            <div class="step-guide">
                <h5>📌 선택 해제 → 새 유닛 선택 흐름</h5>
                <ol>
                    <li><strong>좌클릭</strong>: HandleLeftClick() 호출</li>
                    <li><strong>기존 유닛 해제</strong>: <code>selectedUnit.Deselect()</code> → Decal 비활성화</li>
                    <li><strong>상태 업데이트</strong>: HandleUnitDeselected() → <code>selectedUnit = null</code></li>
                    <li><strong>Raycast</strong>: 새 유닛 클릭 감지</li>
                    <li><strong>새 유닛 선택</strong>: <code>selectable.Select()</code> → UnitSelectedEvent 발행</li>
                    <li><strong>상태 업데이트</strong>: HandleUnitSelected() → <code>selectedUnit = evt.Unit</code></li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul class="content-list">
                <li><strong>Discrete Events</strong>: 각 이벤트는 명확한 단일 목적 (UnitSelectedEvent vs UnitDeselectedEvent)</li>
                <li><strong>상태 관리 분리</strong>: 이벤트 핸들러가 상태 관리, 호출자는 이벤트만 발행</li>
                <li><strong>메모리 관리</strong>: OnDestroy에서 반드시 이벤트 구독 해제</li>
                <li><strong>+=/-= 연산자</strong>: 이벤트 구독 추가/제거</li>
                <li><strong>확장성</strong>: 새 이벤트 타입 추가가 쉬움 (UnitDied, UnitMoved 등)</li>
            </ul>
        </div>

        <div class="project-application">
            <h3>🎮 노바1492 프로젝트 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>다중 유닛 선택</strong>: List&lt;ISelectable&gt; 관리, UnitDeselectedEvent로 리스트에서 제거</li>
                <li><strong>팀 단위 작전</strong>: 그룹 선택/해제 이벤트 (GroupSelectedEvent, GroupDeselectedEvent)</li>
                <li><strong>UI 업데이트</strong>: 선택 해제 시 UI 패널 닫기, 정보 초기화</li>
                <li><strong>사운드 효과</strong>: 이벤트 리스너로 선택/해제 사운드 재생</li>
                <li><strong>디버그 로그</strong>: 이벤트 발생 추적으로 상태 변화 모니터링</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>Event Bus 확장</strong>: 여러 이벤트 타입 동시 관리</li>
                <li><strong>+=/-= 연산자</strong>: 이벤트 구독/해제</li>
                <li><strong>OnDestroy</strong>: GameObject 파괴 시 정리 작업</li>
                <li><strong>Discrete Event Structs</strong>: 명확한 단일 책임 이벤트</li>
                <li><strong>Null 체크</strong>: <code>if (selectedUnit != null)</code> 패턴</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>Event Bus 확장</strong>: 여러 이벤트 타입 동시 관리</li>
                <li><strong>+=/-= 연산자</strong>: 이벤트 구독/해제</li>
                <li><strong>OnDestroy</strong>: GameObject 파괴 시 정리 작업</li>
                <li><strong>Discrete Event Structs</strong>: 명확한 단일 책임 이벤트</li>
                <li><strong>Null 체크</strong>: <code>if (selectedUnit != null)</code> 패턴</li>
            </ul>

            <h4>주요 변경 파일</h4>
            <div class="code-block">Assets/Scripts/Events/UnitDeselectedEvent.cs (신규)
Assets/Scripts/Player/PlayerInput.cs (수정)</div>
        </div>
    </div>

    <div class="lecture-section">
        <h2>📚 강의 16: Drag Select Multiple Units (드래그로 다중 유닛 선택)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul>
                <li>다중 유닛 선택 시스템 구현</li>
                <li>AbstractUnit 클래스 설계 및 상속 구조 이해</li>
                <li>HashSet과 List의 차이점 및 성능 최적화</li>
                <li>드래그 선택 박스 내 유닛 감지 알고리즘</li>
                <li>Event Bus를 통한 유닛 스폰 추적</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. AbstractUnit 클래스 설계</h4>
            <p><strong>왜 필요한가?</strong> 기존에는 Worker와 WorkerThreeRobot이 각각 동일한 코드를 중복으로 가지고 있었습니다. 
            NavMeshAgent 설정, 선택/해제 로직, 이동 명령 처리가 모든 유닛에서 반복되었죠. 
            AbstractUnit을 만들면 코드 중복을 제거하고, 새로운 유닛 타입 추가 시 일관된 동작을 보장할 수 있습니다.</p>
            
            <p>모든 유닛의 공통 기능을 추상 클래스로 통합:</p>
            <div class="code-block">
<span class="keyword">public abstract class</span> <span class="class-name">AbstractUnit</span> : MonoBehaviour, ISelectable, IMoveable
<span class="keyword">{</span>
    <span class="keyword">[SerializeField] private</span> DecalProjector decalProjector;
    <span class="keyword">private</span> NavMeshAgent agent;

    <span class="keyword">private void</span> <span class="method-name">Awake</span>()
    <span class="keyword">{</span>
        agent = GetComponent&lt;NavMeshAgent&gt;();
    <span class="keyword">}</span>

    <span class="keyword">private void</span> <span class="method-name">Start</span>()
    <span class="keyword">{</span>
        <span class="comment">// 유닛 스폰 시 이벤트 발행</span>
        Bus&lt;UnitSpawnEvent&gt;.Raise(<span class="keyword">new</span> UnitSpawnEvent(<span class="keyword">this</span>));
    <span class="keyword">}</span>

    <span class="keyword">public void</span> <span class="method-name">Select</span>()
    <span class="keyword">{</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        <span class="keyword">{</span>
            decalProjector.gameObject.SetActive(<span class="keyword">true</span>);
        <span class="keyword">}</span>
        Bus&lt;UnitSelectedEvent&gt;.Raise(<span class="keyword">new</span> UnitSelectedEvent(<span class="keyword">this</span>));
    <span class="keyword">}</span>

    <span class="keyword">public void</span> <span class="method-name">Deselect</span>()
    <span class="keyword">{</span>
        <span class="keyword">if</span> (decalProjector != <span class="keyword">null</span>)
        <span class="keyword">{</span>
            decalProjector.gameObject.SetActive(<span class="keyword">false</span>);
        <span class="keyword">}</span>
        Bus&lt;UnitDeselectedEvent&gt;.Raise(<span class="keyword">new</span> UnitDeselectedEvent(<span class="keyword">this</span>));
    <span class="keyword">}</span>

    <span class="keyword">public void</span> <span class="method-name">MoveTo</span>(Vector3 position)
    <span class="keyword">{</span>
        agent.SetDestination(position);
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>

            <h4>2. 다중 유닛 선택 알고리즘</h4>
            <p><strong>왜 이런 구조인가?</strong> 단순히 클릭으로는 하나의 유닛만 선택할 수 있습니다. 
            하지만 RTS 게임에서는 여러 유닛을 동시에 선택해서 일괄 명령을 내려야 합니다. 
            드래그 박스를 그려서 그 안에 있는 모든 유닛을 선택하는 방식이 가장 직관적이고 효율적입니다.</p>
            
            <p>드래그 선택의 3단계 프로세스:</p>
            <div class="code-block">
<span class="comment">// 1단계: 드래그 시작 - 선택 박스 초기화</span>
<span class="keyword">if</span> (Mouse.current.leftButton.wasPressedThisFrame)
<span class="keyword">{</span>
    selectionBox.sizeDelta = Vector2.zero;  <span class="comment">// 이전 크기 초기화</span>
    selectionBox.gameObject.SetActive(<span class="keyword">true</span>);
    startingMousePosition = Mouse.current.position.ReadValue();
    addedUnits.Clear();  <span class="comment">// 이전 선택 초기화</span>
<span class="keyword">}</span>

<span class="comment">// 2단계: 드래그 중 - 박스 내 유닛 감지</span>
<span class="keyword">else if</span> (Mouse.current.leftButton.isPressed)
<span class="keyword">{</span>
    Bounds selectionBoxBounds = ResizeSelectionBox();
    <span class="keyword">foreach</span>(AbstractUnit unit <span class="keyword">in</span> aliveUnits)
    <span class="keyword">{</span>
        Vector2 unitPosition = camera.WorldToScreenPoint(unit.transform.position);
        <span class="keyword">if</span> (selectionBoxBounds.Contains(unitPosition))
        <span class="keyword">{</span>
            addedUnits.Add(unit);
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>

<span class="comment">// 3단계: 드래그 종료 - 선택 적용</span>
<span class="keyword">else if</span> (Mouse.current.leftButton.wasReleasedThisFrame)
<span class="keyword">{</span>
    DeselectAllUnits();  <span class="comment">// 기존 선택 해제</span>
    <span class="keyword">foreach</span>(AbstractUnit unit <span class="keyword">in</span> addedUnits)
    <span class="keyword">{</span>
        unit.Select();  <span class="comment">// 새 유닛 선택</span>
    <span class="keyword">}</span>
    selectionBox.gameObject.SetActive(<span class="keyword">false</span>);
<span class="keyword">}</span>
            </div>

            <h4>3. HashSet vs List 성능 최적화</h4>
            <p><strong>왜 HashSet을 사용하는가?</strong> 
            <code>aliveUnits</code>는 현재 살아있는 모든 유닛을 추적하는 컬렉션입니다. 
            여기서 중요한 것은 <strong>중복이 없어야 하고, 순서는 중요하지 않다</strong>는 점입니다. 
            HashSet은 중복을 자동으로 제거하고, 추가/삭제 연산이 O(1)로 매우 빠릅니다. 
            List는 중복을 허용하고 순서를 유지하는데, 이 경우에는 불필요한 오버헤드입니다.</p>
            <p>유닛 관리에 HashSet을 사용하는 이유:</p>
            <div class="code-block">
<span class="comment">// HashSet: 중복 없는 고성능 컬렉션</span>
<span class="keyword">private</span> HashSet&lt;AbstractUnit&gt; aliveUnits = <span class="keyword">new</span>(100);
<span class="keyword">private</span> HashSet&lt;AbstractUnit&gt; addedUnits = <span class="keyword">new</span>(24);

<span class="comment">// List: 순서가 중요한 선택된 유닛</span>
<span class="keyword">private</span> List&lt;ISelectable&gt; selectedUnits = <span class="keyword">new</span>(12);

<span class="comment">// HashSet 장점:</span>
<span class="comment">// - O(1) 추가/제거 성능</span>
<span class="comment">// - 중복 자동 방지</span>
<span class="comment">// - 순서 무관 (유닛 생존 상태에 적합)</span>

<span class="comment">// List 장점:</span>
<span class="comment">// - 순서 보장</span>
<span class="comment">// - 인덱스 접근 가능</span>
<span class="comment">// - 선택된 유닛 순서 유지</span>
            </div>

            <h4>4. UnitSpawnEvent 이벤트 시스템</h4>
            <p><strong>왜 UnitSpawnEvent가 필요한가?</strong> 
            PlayerInput은 드래그 선택을 위해 현재 살아있는 모든 유닛을 알아야 합니다. 
            하지만 유닛이 언제 생성되는지 직접 알 수 없죠. 
            UnitSpawnEvent를 통해 유닛이 생성될 때마다 PlayerInput이 자동으로 알 수 있게 됩니다. 
            이는 Event Bus 패턴의 핵심인 "느슨한 결합"을 보여주는 예시입니다.</p>
            
            <p>유닛 스폰 추적을 위한 새로운 이벤트:</p>
            <div class="code-block">
<span class="keyword">public struct</span> <span class="class-name">UnitSpawnEvent</span> : IEvent
<span class="keyword">{</span>
    <span class="keyword">public</span> AbstractUnit Unit 
    { 
        <span class="keyword">get</span>; 
        <span class="keyword">private set</span>; 
    }

    <span class="keyword">public</span> <span class="method-name">UnitSpawnEvent</span>(AbstractUnit unit)
    <span class="keyword">{</span>
        Unit = unit;
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>PlayerInput.cs - 다중 유닛 선택</h4>
            <div class="code-block">
<span class="keyword">private</span> HashSet&lt;AbstractUnit&gt; aliveUnits = <span class="keyword">new</span>(100);
<span class="keyword">private</span> HashSet&lt;AbstractUnit&gt; addedUnits = <span class="keyword">new</span>(24);
<span class="keyword">private</span> List&lt;ISelectable&gt; selectedUnits = <span class="keyword">new</span>(12);

<span class="keyword">private void</span> <span class="method-name">Awake</span>()
<span class="keyword">{</span>
    <span class="comment">// 기존 코드...</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent += HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent += HandleUnitDeselected;
    Bus&lt;UnitSpawnEvent&gt;.OnEvent += HandleUnitSpawn;  <span class="comment">// 새 이벤트 구독</span>
<span class="keyword">}</span>

<span class="keyword">private void</span> <span class="method-name">OnDestroy</span>()
<span class="keyword">{</span>
    Bus&lt;UnitSelectedEvent&gt;.OnEvent -= HandleUnitSelected;
    Bus&lt;UnitDeselectedEvent&gt;.OnEvent -= HandleUnitDeselected;
    Bus&lt;UnitSpawnEvent&gt;.OnEvent -= HandleUnitSpawn;  <span class="comment">// 구독 해제</span>
<span class="keyword">}</span>

<span class="comment">// Expression-bodied functions (간결한 이벤트 핸들러)</span>
<span class="keyword">private void</span> <span class="method-name">HandleUnitSelected</span>(UnitSelectedEvent evt) => selectedUnits.Add(evt.Unit);
<span class="keyword">private void</span> <span class="method-name">HandleUnitDeselected</span>(UnitDeselectedEvent evt) => selectedUnits.Remove(evt.Unit);
<span class="keyword">private void</span> <span class="method-name">HandleUnitSpawn</span>(UnitSpawnEvent evt) => aliveUnits.Add(evt.Unit);
            </div>

            <h4>DeselectAllUnits() - 안전한 선택 해제</h4>
            <p><strong>왜 ToArray()를 사용하는가?</strong> 
            <code>selectedUnits</code> 리스트를 직접 반복하면서 <code>Deselect()</code>를 호출하면 문제가 발생합니다. 
            <code>Deselect()</code>는 이벤트를 발행하고, 이벤트 핸들러가 <code>selectedUnits</code> 리스트를 수정하기 때문입니다. 
            "반복 중 컬렉션을 수정할 수 없습니다" 런타임 에러가 발생하죠. 
            <code>ToArray()</code>로 스냅샷을 만들어서 안전하게 반복할 수 있습니다.</p>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">DeselectAllUnits</span>()
<span class="keyword">{</span>
    <span class="comment">// 리스트 복사본 생성 (반복 중 변경 방지)</span>
    ISelectable[] currentlySelectedUnits = selectedUnits.ToArray();
    <span class="keyword">foreach</span>(ISelectable selectable <span class="keyword">in</span> currentlySelectedUnits)
    <span class="keyword">{</span>
        selectable.Deselect();  <span class="comment">// 이벤트 발행으로 리스트 변경됨</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>

            <h4>HandleRightClick() - 다중 유닛 이동</h4>
            <p><strong>왜 foreach로 모든 유닛을 처리하는가?</strong> 
            기존에는 <code>selectedUnit</code> 하나만 처리했지만, 이제는 <code>selectedUnits</code> 리스트에 여러 유닛이 있을 수 있습니다. 
            각 유닛이 <code>IMoveable</code> 인터페이스를 구현하는지 확인하고, 이동 가능한 유닛들에게만 이동 명령을 내립니다. 
            이렇게 하면 한 번의 우클릭으로 모든 선택된 유닛이 동시에 이동합니다.</p>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">HandleRightClick</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (selectedUnits.Count == <span class="keyword">0</span>) { <span class="keyword">return</span>; }  <span class="comment">// Guardian Pattern</span>

    Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

    <span class="keyword">if</span> (Mouse.current.rightButton.wasReleasedThisFrame
        && Physics.Raycast(cameraRay, <span class="keyword">out</span> RaycastHit hit, <span class="keyword">float</span>.MaxValue, floorLayers))
    <span class="keyword">{</span>
        <span class="comment">// 모든 선택된 유닛에게 이동 명령</span>
        <span class="keyword">foreach</span>(ISelectable selectable <span class="keyword">in</span> selectedUnits)
        <span class="keyword">{</span>
            <span class="keyword">if</span> (selectable <span class="keyword">is</span> IMoveable moveable)
            <span class="keyword">{</span>
                moveable.MoveTo(hit.point);
            <span class="keyword">}</span>
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>⚙️ Unity 설정</h3>
            <p>이번 강의에서는 Unity 에디터 설정 변경이 없습니다. 모든 변경사항은 스크립트에서만 발생합니다.</p>
        </div>

        <div class="content-section">
            <h3>🐛 주의사항</h3>
            <div class="problem-solution">
                <h5>⚠️ 리스트 반복 중 변경 오류</h5>
                <p><strong>문제:</strong> 선택 해제 시 리스트를 반복하면서 동시에 리스트를 변경하면 런타임 오류 발생</p>
                <p><strong>해결:</strong> <code>ToArray()</code>로 복사본을 만들어 안전하게 반복</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ 선택 박스 크기 초기화</h5>
                <p><strong>문제:</strong> 드래그 시작 시 이전 선택 박스 크기가 잠깐 보임</p>
                <p><strong>해결:</strong> <code>selectionBox.sizeDelta = Vector2.zero</code>로 초기화</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ HandleLeftClick() 임시 비활성화</h5>
                <p><strong>이유:</strong> 드래그 선택과 단일 클릭 선택의 충돌 방지</p>
                <p><strong>향후 계획:</strong> 다음 강의에서 통합된 선택 시스템 구현 예정</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul>
                <li><strong>Abstract Class 활용:</strong> 공통 기능을 상위 클래스로 추출하여 코드 중복 제거</li>
                <li><strong>Collection 선택:</strong> HashSet(순서 무관) vs List(순서 중요)의 적절한 사용</li>
                <li><strong>성능 최적화:</strong> 초기 용량 설정으로 런타임 리사이징 방지</li>
                <li><strong>Event Bus 확장:</strong> 새로운 이벤트 타입 추가로 시스템 확장성 확보</li>
                <li><strong>Expression-bodied Functions:</strong> 한 줄 함수의 간결한 표현법</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>🎮 노바1492 적용 포인트</h3>
            <ul>
                <li><strong>다중 로봇 제어:</strong> 여러 로봇을 동시에 선택하여 집단 작전 수행</li>
                <li><strong>파츠별 독립성:</strong> AbstractUnit 상속으로 각 로봇 파츠의 독립적 동작 유지</li>
                <li><strong>성능 최적화:</strong> 12개 유닛 제한으로 대규모 전투 시 성능 보장</li>
                <li><strong>확장성:</strong> 새로운 유닛 타입 추가 시 AbstractUnit만 상속하면 됨</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📌 주요 변경 파일</h3>
            <div class="code-block">Assets/Scripts/Events/UnitSpawnEvent.cs (신규)
Assets/Scripts/Units/AbstractUnit.cs (신규)
Assets/Scripts/Units/Worker.cs (리팩토링)
Assets/Scripts/Units/WorkerThreeRobot.cs (상속 구조 변경)
Assets/Scripts/Player/PlayerInput.cs (다중 선택 시스템)</div>
        </div>
    </div>

    <footer style="text-align: center; padding: 40px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin-top: 40px;">
        <h2>🎉 총 18개 강의 완료!</h2>
        <p style="font-size: 1.2rem; margin-top: 10px;">예상 학습 시간: 14-15시간</p>
        <p style="margin-top: 20px; opacity: 0.9;">다음 강의에서는 더 고급 네비게이션 기능을 구현합니다.</p>
    </footer>

    <div class="lecture-section">
        <h2>📚 강의 17: Add Units to Selection (Shift 키로 유닛 추가 선택)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul>
                <li>Shift 키를 이용한 다중 유닛 선택 기능 구현</li>
                <li>코드 리팩토링을 통한 가독성 향상</li>
                <li>단일 클릭 선택과 드래그 선택의 통합</li>
                <li>함수 분리를 통한 코드 구조 개선</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. 코드 리팩토링 - 함수 분리</h4>
            <p><strong>왜 필요한가?</strong> 
            <code>HandleDragSelect()</code> 함수가 너무 길어져서 가독성이 떨어졌습니다. 
            하나의 함수가 여러 가지 일을 하면 나중에 코드를 이해하기 어려워집니다. 
            각 단계별로 함수를 분리하면 코드의 의도가 명확해지고 유지보수가 쉬워집니다.</p>
            
            <p>HandleDragSelect를 3개의 작은 함수로 분리:</p>
            <div class="code-block">
<span class="comment">// 기존: 하나의 거대한 함수</span>
<span class="keyword">private void</span> <span class="method-name">HandleDragSelect</span>()
<span class="keyword">{</span>
    <span class="comment">// 50줄 이상의 복잡한 로직...</span>
<span class="keyword">}</span>

<span class="comment">// 개선: 3개의 명확한 함수로 분리</span>
<span class="keyword">private void</span> <span class="method-name">HandleDragSelect</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (Mouse.current.leftButton.wasPressedThisFrame)
    <span class="keyword">{</span>
        HandleMouseDown();
    <span class="keyword">}</span>
    <span class="keyword">else if</span> (Mouse.current.leftButton.isPressed && !Mouse.current.leftButton.wasPressedThisFrame)
    <span class="keyword">{</span>
        HandleMouseDrag();
    <span class="keyword">}</span>
    <span class="keyword">else if</span> (Mouse.current.leftButton.wasReleasedThisFrame)
    <span class="keyword">{</span>
        HandleMouseUp();
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>

            <h4>2. Shift 키를 이용한 다중 선택</h4>
            <p><strong>왜 이런 방식인가?</strong> 
            RTS 게임에서는 여러 유닛을 선택하는 방법이 여러 가지 있습니다. 
            Shift 키를 누르고 클릭하면 기존 선택을 유지하면서 새로운 유닛을 추가할 수 있습니다. 
            이는 사용자가 직관적으로 이해할 수 있는 표준적인 UI 패턴입니다.</p>
            
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">HandleMouseUp</span>()
<span class="keyword">{</span>
    <span class="comment">// Shift 키가 눌리지 않았을 때만 기존 선택 해제</span>
    <span class="keyword">if</span> (!Keyboard.current.shiftKey.isPressed)
    <span class="keyword">{</span>
        DeselectAllUnits();
    <span class="keyword">}</span>

    HandleLeftClick();  <span class="comment">// 단일 클릭 선택</span>
    <span class="keyword">foreach</span> (AbstractUnit unit <span class="keyword">in</span> addedUnits)
    <span class="keyword">{</span>
        unit.Select();  <span class="comment">// 드래그 선택된 유닛들 추가</span>
    <span class="keyword">}</span>
    selectionBox.gameObject.SetActive(<span class="keyword">false</span>);
<span class="keyword">}</span>
            </div>

            <h4>3. 단일 클릭과 드래그 선택 통합</h4>
            <p><strong>왜 통합해야 하는가?</strong> 
            기존에는 <code>HandleLeftClick()</code>이 Update에서 독립적으로 실행되어 드래그 선택과 충돌할 수 있었습니다. 
            <code>HandleMouseUp()</code>에서 <code>HandleLeftClick()</code>을 호출하면 
            마우스를 뗄 때만 단일 클릭이 실행되어 드래그와 자연스럽게 통합됩니다.</p>
            
            <div class="code-block">
<span class="comment">// Update()에서 제거</span>
<span class="keyword">private void</span> <span class="method-name">Update</span>()
<span class="keyword">{</span>
    HandlePanning();
    HandleZooming();
    HandleRotation();
    <span class="comment">// HandleLeftClick(); ← 제거됨</span>
    HandleRightClick();
    HandleDragSelect();
<span class="keyword">}</span>

<span class="comment">// HandleMouseUp()에서 통합</span>
<span class="keyword">private void</span> <span class="method-name">HandleMouseUp</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (!Keyboard.current.shiftKey.isPressed)
    <span class="keyword">{</span>
        DeselectAllUnits();
    <span class="keyword">}</span>

    HandleLeftClick();  <span class="comment">// 여기서 단일 클릭 처리</span>
    <span class="comment">// 드래그 선택 처리...</span>
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>HandleMouseDown() - 드래그 시작</h4>
            <p><strong>왜 별도 함수로 분리하는가?</strong> 
            드래그 시작 시 해야 할 일들이 명확합니다: 선택 박스 초기화, 마우스 위치 저장, 이전 선택 초기화. 
            이 로직을 별도 함수로 분리하면 코드의 의도가 명확해집니다.</p>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">HandleMouseDown</span>()
<span class="keyword">{</span>
    selectionBox.sizeDelta = Vector2.zero;  <span class="comment">// 이전 크기 초기화</span>
    selectionBox.gameObject.SetActive(<span class="keyword">true</span>);
    startingMousePosition = Mouse.current.position.ReadValue();
    addedUnits.Clear();  <span class="comment">// 이전 선택 초기화</span>
<span class="keyword">}</span>
            </div>

            <h4>HandleMouseDrag() - 드래그 중</h4>
            <p><strong>왜 별도 함수로 분리하는가?</strong> 
            드래그 중에는 선택 박스 내의 유닛들을 찾는 로직만 필요합니다. 
            이 로직이 복잡하므로 별도 함수로 분리하여 가독성을 높입니다.</p>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">HandleMouseDrag</span>()
<span class="keyword">{</span>
    Bounds selectionBoxBounds = ResizeSelectionBox();
    <span class="keyword">foreach</span> (AbstractUnit unit <span class="keyword">in</span> aliveUnits)
    <span class="keyword">{</span>
        Vector2 unitPosition = camera.WorldToScreenPoint(unit.transform.position);

        <span class="keyword">if</span> (selectionBoxBounds.Contains(unitPosition))
        <span class="keyword">{</span>
            addedUnits.Add(unit);
        <span class="keyword">}</span>
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>

            <h4>HandleLeftClick() - 단일 클릭 선택</h4>
            <p><strong>왜 단순화했는가?</strong> 
            기존에는 마우스 버튼 상태 확인과 선택 해제 로직이 있었지만, 
            이제는 <code>HandleMouseUp()</code>에서 마우스 상태를 확인하고 선택 해제도 처리하므로 
            <code>HandleLeftClick()</code>은 순수하게 레이캐스트와 선택만 담당하면 됩니다.</p>
            <div class="code-block">
<span class="keyword">private void</span> <span class="method-name">HandleLeftClick</span>()
<span class="keyword">{</span>
    <span class="keyword">if</span> (camera == <span class="keyword">null</span>) { <span class="keyword">return</span>; }

    Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

    <span class="keyword">if</span> (Physics.Raycast(cameraRay, <span class="keyword">out</span> RaycastHit hit, <span class="keyword">float</span>.MaxValue, selectableUnitsLayers)
        && hit.collider.TryGetComponent(<span class="keyword">out</span> ISelectable selectable))
    <span class="keyword">{</span>
        selectable.Select();
    <span class="keyword">}</span>
<span class="keyword">}</span>
            </div>
        </div>

        <div class="content-section">
            <h3>⚙️ Unity 설정</h3>
            <p>이번 강의에서는 Unity 에디터 설정 변경이 없습니다. 모든 변경사항은 스크립트에서만 발생합니다.</p>
        </div>

        <div class="content-section">
            <h3>🐛 주의사항</h3>
            <div class="problem-solution">
                <h5>⚠️ Shift 키 상태 확인</h5>
                <p><strong>주의:</strong> <code>Keyboard.current.shiftKey.isPressed</code>는 현재 프레임에서 Shift 키가 눌려있는지 확인</p>
                <p><strong>용도:</strong> Shift가 눌려있으면 기존 선택을 유지하고 새 유닛을 추가 선택</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ 함수 분리의 장점</h5>
                <p><strong>가독성:</strong> 각 함수가 하나의 명확한 역할만 담당</p>
                <p><strong>유지보수:</strong> 특정 기능 수정 시 해당 함수만 찾으면 됨</p>
                <p><strong>테스트:</strong> 각 함수를 독립적으로 테스트 가능</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul>
                <li><strong>코드 리팩토링:</strong> 큰 함수를 작은 함수로 분리하여 가독성 향상</li>
                <li><strong>UI 패턴:</strong> Shift 키를 이용한 다중 선택은 표준적인 RTS 게임 패턴</li>
                <li><strong>함수 통합:</strong> 관련된 기능들을 하나의 흐름으로 통합하여 일관성 확보</li>
                <li><strong>단일 책임 원칙:</strong> 각 함수가 하나의 명확한 역할만 담당하도록 설계</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>함수 분리 (Function Decomposition)</strong>: 복잡한 함수를 작은 단위로 분해</li>
                <li><strong>Shift 키 입력 처리</strong>: <code>Keyboard.current.shiftKey.isPressed</code></li>
                <li><strong>조건부 선택 해제</strong>: Shift 키 상태에 따른 선택 유지/해제</li>
                <li><strong>이벤트 통합</strong>: 단일 클릭과 드래그 선택의 자연스러운 통합</li>
            </ul>

            <h4>주요 변경 파일</h4>
            <div class="code-block">Assets/Scripts/Player/PlayerInput.cs (리팩토링)</div>
        </div>
    </div>

    <div class="lecture-section">
        <h2>📚 강의 18: NavMesh Areas and Obstacles (NavMesh 영역과 장애물)</h2>

        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul>
                <li>NavMesh Areas의 개념과 사용법 이해</li>
                <li>NavMesh Obstacle과 NavMesh Modifier의 차이점 파악</li>
                <li>런타임에서 동적으로 NavMesh를 조작하는 방법</li>
                <li>리소스와 건물에 적절한 NavMesh 컴포넌트 적용</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>

            <h4>1. NavMesh Areas (NavMesh 영역)</h4>
            <p><strong>왜 필요한가?</strong> 
            NavMesh Areas는 특정 지역의 이동 비용을 조정할 수 있게 해줍니다. 
            예를 들어, 물 지역은 2배 비싸게, 점프 지역은 3배 비싸게 설정할 수 있습니다. 
            이렇게 하면 AI가 더 현실적인 경로를 선택하게 됩니다.</p>
            
            <p>기본 내장 타입들:</p>
            <div class="code-block">
<span class="comment">// NavMesh Areas 기본 타입</span>
<span class="keyword">Walkable</span>: 비용 1 (기본)
<span class="keyword">Not Walkable</span>: 통과 불가 (특수)
<span class="keyword">Jump</span>: 비용 2 (점프 지역)
            </div>

            <h4>2. NavMesh Modifier vs NavMesh Obstacle</h4>
            <p><strong>왜 구분해야 하는가?</strong> 
            두 컴포넌트는 서로 다른 시점에서 NavMesh를 조작합니다. 
            Modifier는 베이킹 시에만 작동하고, Obstacle은 런타임에 동적으로 작동합니다.</p>
            
            <div class="code-block">
<span class="comment">// NavMesh Modifier (베이킹 시에만)</span>
<span class="keyword">장점:</strong> 정적 환경에서 영구적인 변경
<span class="keyword">단점:</strong> 런타임에 변경 불가 (리베이킹 필요)
<span class="keyword">사용처:</strong> 건물, 벽, 영구적 장애물

<span class="comment">// NavMesh Obstacle (런타임 동적)</span>
<span class="keyword">장점:</strong> 런타임에 실시간 변경 가능
<span class="keyword">단점:</strong> 성능 오버헤드 있음
<span class="keyword">사용처:</strong> 리소스, 파괴 가능한 객체
            </div>

            <h4>3. NavMesh Obstacle 설정</h4>
            <p><strong>왜 이런 설정들이 필요한가?</strong> 
            NavMesh Obstacle은 런타임에 NavMesh를 실시간으로 조각내므로, 
            성능과 정확성 사이의 균형을 맞추는 설정들이 중요합니다.</p>
            
            <div class="code-block">
<span class="comment">// NavMesh Obstacle 주요 설정</span>
<span class="keyword">Carve</span>: true  <span class="comment">// NavMesh를 조각낼지 여부</span>
<span class="keyword">Carve Only Stationary</span>: true  <span class="comment">// 정지 상태에서만 조각내기</span>
<span class="keyword">Move Threshold</span>: 0.1  <span class="comment">// 움직임 감지 임계값</span>
<span class="keyword">Time To Stationary</span>: 0.5  <span class="comment">// 정지로 간주되는 시간</span>
            </div>
        </div>

        <div class="content-section">
            <h3>💻 구현 코드</h3>

            <h4>Minerals Prefab에 NavMesh Obstacle 적용</h4>
            <p><strong>왜 Minerals에 Obstacle을 사용하는가?</strong> 
            Minerals는 채굴되면 사라지는 동적 객체입니다. 
            베이킹 시에만 작동하는 Modifier를 사용하면, 
            채굴 후에도 NavMesh가 업데이트되지 않아 유닛이 통과할 수 없게 됩니다.</p>
            
            <div class="code-block">
<span class="comment">// Minerals NavMesh Obstacle 설정</span>
<span class="keyword">Shape</span>: Box
<span class="keyword">Extents</span>: (0.25, 0.125, 0.25)  <span class="comment">// 미네랄 크기에 맞게 조정</span>
<span class="keyword">Center</span>: (0, -0.5, 0)  <span class="comment">// 바닥에 맞춤</span>
<span class="keyword">Carve</span>: true
<span class="keyword">Carve Only Stationary</span>: true
            </div>

            <h4>Gas Prefab에 NavMesh Obstacle 적용</h4>
            <p><strong>왜 Gas에 다른 설정을 사용하는가?</strong> 
            Gas는 Minerals보다 작고 높이가 낮은 객체입니다. 
            따라서 더 작은 크기와 다른 중심점을 사용해야 합니다.</p>
            
            <div class="code-block">
<span class="comment">// Gas NavMesh Obstacle 설정</span>
<span class="keyword">Shape</span>: Box
<span class="keyword">Extents</span>: (0.9, 0.125, 0.5)  <span class="comment">// 가스 크기에 맞게 조정</span>
<span class="keyword">Center</span>: (0.15, 0, 0)  <span class="comment">// 가스 위치에 맞춤</span>
<span class="keyword">Carve</span>: true
<span class="keyword">Carve Only Stationary</span>: true
            </div>

            <h4>NavMesh Surface Layer 설정</h4>
            <p><strong>왜 Layer를 분리해야 하는가?</strong> 
            NavMesh가 모든 객체를 고려하면 성능이 저하됩니다. 
            필요한 Layer만 포함시켜서 효율적인 NavMesh를 생성해야 합니다.</p>
            
            <div class="code-block">
<span class="comment">// NavMesh Surface Include Layers</span>
<span class="keyword">Floor</span>: ✓  <span class="comment">// 바닥만 포함</span>
<span class="keyword">Water</span>: ✓  <span class="comment">// 물 포함 (Not Walkable로 설정)</span>
<span class="keyword">Default</span>: ✗  <span class="comment">// 리소스 제외 (Obstacle 사용)</span>
            </div>
        </div>

        <div class="content-section">
            <h3>⚙️ Unity 설정</h3>
            
            <h4>1. NavMesh Surface 설정</h4>
            <p>Navigation Window에서 NavMesh Surface 컴포넌트 설정:</p>
            <ul>
                <li><strong>Include Layers</strong>: Floor, Water만 포함</li>
                <li><strong>Default Area</strong>: Walkable</li>
                <li><strong>Generate Links</strong>: false (필요시)</li>
            </ul>

            <h4>2. NavMesh Areas 설정</h4>
            <p>Navigation Window의 Areas 탭에서:</p>
            <ul>
                <li><strong>Walkable</strong>: 비용 1 (기본)</li>
                <li><strong>Not Walkable</strong>: 통과 불가</li>
                <li><strong>Jump</strong>: 비용 2</li>
            </ul>

            <h4>3. NavMesh Modifier Volume 설정</h4>
            <p>정적 장애물에 사용:</p>
            <ul>
                <li><strong>Area Type</strong>: Not Walkable</li>
                <li><strong>Affected Agents</strong>: All (또는 특정 에이전트)</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>🐛 주의사항</h3>
            <div class="problem-solution">
                <h5>⚠️ NavMesh Obstacle 성능 고려사항</h5>
                <p><strong>주의:</strong> NavMesh Obstacle은 런타임에 NavMesh를 실시간으로 조각내므로 성능 오버헤드가 있습니다</p>
                <p><strong>최적화:</strong> Carve Only Stationary를 true로 설정하여 정지 상태에서만 조각내기</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ Layer 설정 중요성</h5>
                <p><strong>문제:</strong> 모든 Layer를 포함하면 불필요한 객체들이 NavMesh에 포함됨</p>
                <p><strong>해결:</strong> 필요한 Layer만 선택적으로 포함 (Floor, Water)</p>
            </div>

            <div class="problem-solution">
                <h5>⚠️ NavMesh Modifier vs Obstacle 선택</h5>
                <p><strong>Modifier 사용:</strong> 정적 환경, 영구적 장애물</p>
                <p><strong>Obstacle 사용:</strong> 동적 객체, 파괴 가능한 리소스</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎓 학습 포인트</h3>
            <ul>
                <li><strong>NavMesh Areas:</strong> 지역별 이동 비용 조정으로 현실적인 경로 생성</li>
                <li><strong>Modifier vs Obstacle:</strong> 정적 vs 동적 환경에 따른 적절한 컴포넌트 선택</li>
                <li><strong>성능 최적화:</strong> Carve Only Stationary로 불필요한 계산 방지</li>
                <li><strong>Layer 관리:</strong> 필요한 Layer만 포함하여 효율적인 NavMesh 생성</li>
            </ul>
        </div>

        <div class="tech-stack">
            <h3>🔧 핵심 기술</h3>
            <ul class="content-list">
                <li><strong>NavMesh Areas</strong>: 지역별 이동 비용 설정</li>
                <li><strong>NavMesh Obstacle</strong>: 런타임 동적 NavMesh 조작</li>
                <li><strong>NavMesh Modifier</strong>: 베이킹 시 NavMesh 조작</li>
                <li><strong>Layer Mask</strong>: NavMesh Surface 포함 레이어 제어</li>
            </ul>

            <h4>주요 변경 파일</h4>
            <div class="code-block">Assets/Gatherable Resources/Gas.prefab (NavMesh Obstacle 추가)
Assets/Gatherable Resources/Minerals.prefab (NavMesh Obstacle 추가)
Assets/Scenes/Game.unity (NavMesh Surface 설정 변경)
Assets/Scenes/Game/NavMesh-Floor.asset (NavMesh 데이터 업데이트)</div>
        </div>

        <!-- 강의 19: Unit Dancing 문제 해결 -->
        <div class="lecture-section">
            <h2 class="lecture-title">🎯 강의 19: Unit Dancing 문제 해결 (수학적 접근)</h2>
            
            <div class="lecture-goal">
                <h3>🎯 학습 목표</h3>
                <ul class="content-list">
                    <li>Unit Dancing 문제의 원인과 해결 방법 이해</li>
                    <li>삼각함수와 원형 배치 알고리즘 구현</li>
                    <li>수학적 접근을 통한 유닛 포메이션 시스템 구축</li>
                    <li>Agent Radius 기반 동적 배치 시스템 개발</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>📝 핵심 개념</h3>
                
                <h4>🤔 Unit Dancing이란?</h4>
                <div class="step-guide">
                    <h5>문제 상황:</h5>
                    <ul>
                        <li>여러 유닛이 같은 목표 지점에 도달하려고 할 때 발생</li>
                        <li>유닛들이 서로 밀고 당기며 "춤추는" 현상</li>
                        <li>NavMesh Avoidance 시스템의 한계로 인한 문제</li>
                    </ul>
                </div>

                <h4>💡 해결 방법들</h4>
                <div class="step-guide">
                    <h5>1. 목표 지점 분산 (이번 강의에서 구현)</h5>
                    <ul>
                        <li>모든 유닛을 같은 지점으로 보내지 않음</li>
                        <li>원형 배치를 통한 자연스러운 포메이션</li>
                        <li>수학적 계산으로 최적 위치 결정</li>
                    </ul>
                    
                    <h5>2. 동적 목표 조정</h5>
                    <ul>
                        <li>목표 지점과 정지 거리를 동적으로 조정</li>
                        <li>복잡한 타이밍과 값 결정 문제</li>
                    </ul>
                    
                    <h5>3. Avoidance 비활성화</h5>
                    <ul>
                        <li>유닛들이 겹쳐서 이동</li>
                        <li>게임의 완성도가 떨어짐</li>
                    </ul>
                </div>

                <h4>🧮 수학적 접근: Unit Circle 활용</h4>
                <div class="step-guide">
                    <h5>Unit Circle의 핵심:</h5>
                    <ul>
                        <li><strong>cos(θ)</strong>: X 좌표 계산</li>
                        <li><strong>sin(θ)</strong>: Y 좌표 계산 (Unity에서는 Z)</li>
                        <li><strong>360° = 2π radians</strong></li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>💻 구현 코드</h3>
                
                <h4>1. AbstractUnit에 AgentRadius 프로퍼티 추가</h4>
                <div class="code-block">
<span class="comment">// AbstractUnit.cs - Agent Radius 접근성 개선</span>
<span class="keyword">public float</span> AgentRadius => agent.radius;

<span class="comment">// 왜 필요한가?</span>
<span class="comment">// - 원형 배치 알고리즘에서 각 유닛의 크기를 알아야 함</span>
<span class="comment">// - 유닛 간 충돌 방지를 위한 최소 거리 계산</span>
<span class="comment">// - 동적 원의 반지름 계산에 필수</span>
                </div>

                <h4>2. 원형 배치 알고리즘 구현</h4>
                <div class="code-block">
<span class="keyword">private void</span> MoveUnitsInFormation(Vector3 targetPoint)
{
    <span class="comment">// 선택된 유닛들 중 AbstractUnit만 필터링</span>
    List&lt;AbstractUnit&gt; abstractUnits = <span class="keyword">new</span> List&lt;AbstractUnit&gt;(selectedUnits.Count);
    <span class="keyword">foreach</span> (ISelectable selectable <span class="keyword">in</span> selectedUnits)
    {
        <span class="keyword">if</span> (selectable <span class="keyword">is</span> AbstractUnit unit)
            abstractUnits.Add(unit);
    }

    <span class="comment">// 원형 배치 알고리즘 변수들</span>
    <span class="keyword">int</span> layer = 0;                    <span class="comment">// 현재 레이어 (원의 반지름)</span>
    <span class="keyword">int</span> unitsOnLayer = 0;           <span class="comment">// 현재 레이어의 유닛 수</span>
    <span class="keyword">int</span> maxUnitsOnLayer = 1;        <span class="comment">// 현재 레이어에 배치할 수 있는 최대 유닛 수</span>
    <span class="keyword">float</span> circleRadius = 0f;       <span class="comment">// 현재 원의 반지름</span>
    <span class="keyword">float</span> radialOffset = 0f;       <span class="comment">// 각 유닛 간의 각도 차이</span>

    <span class="keyword">foreach</span> (AbstractUnit unit <span class="keyword">in</span> abstractUnits)
    {
        <span class="comment">// 목표 위치 계산 (삼각함수 활용)</span>
        Vector3 targetPosition = <span class="keyword">new</span> Vector3(
            targetPoint.x + circleRadius * Mathf.Cos(radialOffset * unitsOnLayer),
            targetPoint.y,
            targetPoint.z + circleRadius * Mathf.Sin(radialOffset * unitsOnLayer)
        );

        unit.MoveTo(targetPosition);
        unitsOnLayer++;

        <span class="comment">// 현재 레이어가 가득 찼는지 확인</span>
        <span class="keyword">if</span> (unitsOnLayer >= maxUnitsOnLayer)
        {
            <span class="comment">// 다음 레이어로 이동</span>
            unitsOnLayer = 0;
            layer++;
            
            <span class="comment">// 새로운 원의 반지름 계산 (에이전트 반지름의 3.5배씩 증가)</span>
            circleRadius += unit.AgentRadius * 3.5f;
            
            <span class="comment">// 새로운 레이어에 배치할 수 있는 최대 유닛 수 계산</span>
            <span class="comment">// 원의 둘레 = 2πr, 유닛 직경 = 2 * AgentRadius</span>
            <span class="keyword">float</span> circumference = 2f * Mathf.PI * circleRadius;
            maxUnitsOnLayer = Mathf.FloorToInt(circumference / (unit.AgentRadius * 2f));
            
            <span class="comment">// 각 유닛 간의 각도 차이 계산</span>
            radialOffset = 2f * Mathf.PI / maxUnitsOnLayer;
        }
    }
}
                </div>

                <h4>3. HandleRightClick 수정</h4>
                <div class="code-block">
<span class="keyword">private void</span> HandleRightClick()
{
    <span class="keyword">if</span> (selectedUnits.Count == 0) { <span class="keyword">return</span>; }

    Ray cameraRay = camera.ScreenPointToRay(Mouse.current.position.ReadValue());

    <span class="keyword">if</span> (Mouse.current.rightButton.wasReleasedThisFrame
        && Physics.Raycast(cameraRay, <span class="keyword">out</span> RaycastHit hit, <span class="keyword">float</span>.MaxValue, floorLayers))
    {
        <span class="comment">// 기존 단순 이동 로직 (주석 처리)</span>
        <span class="comment">// foreach(ISelectable selectable in selectedUnits)</span>
        <span class="comment">// {</span>
        <span class="comment">//     if (selectable is IMoveable moveable)</span>
        <span class="comment">//         moveable.MoveTo(hit.point);</span>
        <span class="comment">// }</span>

        <span class="comment">// 새로운 원형 배치 이동 로직</span>
        MoveUnitsInFormation(hit.point);
    }
}
                </div>
            </div>

            <div class="content-section">
                <h3>🧮 수학 공식 설명</h3>
                
                <h4>원의 둘레 계산</h4>
                <div class="step-guide">
                    <h5>공식: C = 2πr</h5>
                    <ul>
                        <li>C: 원의 둘레 (Circumference)</li>
                        <li>r: 원의 반지름 (Radius)</li>
                        <li>π: 파이 (3.14159...)</li>
                    </ul>
                </div>

                <h4>최대 유닛 수 계산</h4>
                <div class="step-guide">
                    <h5>공식: maxUnits = floor(둘레 / 유닛직경)</h5>
                    <ul>
                        <li>둘레 = 2π × circleRadius</li>
                        <li>유닛직경 = 2 × AgentRadius</li>
                        <li>floor(): 소수점 버림 (정수로 변환)</li>
                    </ul>
                </div>

                <h4>각도 차이 계산</h4>
                <div class="step-guide">
                    <h5>공식: radialOffset = 2π / maxUnitsOnLayer</h5>
                    <ul>
                        <li>전체 원 = 2π radians (360도)</li>
                        <li>유닛 수로 나누어 균등 분할</li>
                        <li>각 유닛의 위치 = radialOffset × unitsOnLayer</li>
                    </ul>
                </div>

                <h4>삼각함수 좌표 계산</h4>
                <div class="step-guide">
                    <h5>X 좌표: circleRadius × cos(angle)</h5>
                    <h5>Z 좌표: circleRadius × sin(angle)</h5>
                    <ul>
                        <li>angle = radialOffset × unitsOnLayer</li>
                        <li>Unity는 Y축이 위쪽이므로 Z축을 사용</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>⚙️ Unity 설정</h3>
                
                <h4>NavMeshAgent 설정</h4>
                <div class="step-guide">
                    <h5>중요한 설정값들:</h5>
                    <ul>
                        <li><strong>Radius</strong>: 유닛의 반지름 (0.5 권장)</li>
                        <li><strong>Stopping Distance</strong>: 목표 지점에서의 정지 거리</li>
                        <li><strong>Avoidance Priority</strong>: 회피 우선순위</li>
                    </ul>
                </div>

                <h4>테스트를 위한 유닛 복제</h4>
                <div class="step-guide">
                    <h5>단계별 복제:</h5>
                    <ol>
                        <li>기본 2개 유닛 선택</li>
                        <li>복제하여 4개로 증가</li>
                        <li>4개 선택 후 복제하여 8개로 증가</li>
                        <li>8개 선택 후 복제하여 16개로 증가</li>
                    </ol>
                </div>
            </div>

            <div class="content-section">
                <h3>🎓 학습 포인트</h3>
                
                <h4>왜 필요한가?</h4>
                <div class="step-guide">
                    <h5>1. AgentRadius 프로퍼티</h5>
                    <ul>
                        <li><strong>동적 계산</strong>: 각 유닛의 크기에 맞는 배치</li>
                        <li><strong>충돌 방지</strong>: 유닛 간 겹침 방지</li>
                        <li><strong>확장성</strong>: 다양한 크기의 유닛 지원</li>
                    </ul>
                    
                    <h5>2. 원형 배치 알고리즘</h5>
                    <ul>
                        <li><strong>자연스러운 포메이션</strong>: 군집 이동의 현실성</li>
                        <li><strong>수학적 정확성</strong>: 삼각함수로 정확한 위치 계산</li>
                        <li><strong>확장 가능성</strong>: 무제한 유닛 수 지원</li>
                    </ul>
                    
                    <h5>3. 레이어 시스템</h5>
                    <ul>
                        <li><strong>효율적 공간 활용</strong>: 원형으로 최대한 많은 유닛 배치</li>
                        <li><strong>동적 확장</strong>: 유닛 수에 따라 자동으로 레이어 추가</li>
                        <li><strong>균등 분배</strong>: 각 레이어에 최적의 유닛 수 배치</li>
                    </ul>
                </div>

                <h4>성능 최적화</h4>
                <div class="step-guide">
                    <h5>최적화 포인트:</h5>
                    <ul>
                        <li><strong>List 초기 용량</strong>: selectedUnits.Count로 리사이징 방지</li>
                        <li><strong>Mathf.FloorToInt</strong>: 정수 변환으로 메모리 효율성</li>
                        <li><strong>삼각함수 캐싱</strong>: 동일한 각도에 대한 중복 계산 방지</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>🎮 노바1492 적용 포인트</h3>
                
                <h4>로봇 부품 시스템과의 연동</h4>
                <div class="step-guide">
                    <h5>WorkerThreeRobot 특화:</h5>
                    <ul>
                        <li><strong>부품별 크기 고려</strong>: 각 로봇의 실제 크기에 맞는 배치</li>
                        <li><strong>회전 시스템 연동</strong>: 이동 시 부품 회전과 포메이션 조화</li>
                        <li><strong>부품 교체 시 대응</strong>: 런타임 부품 변경에 따른 크기 조정</li>
                    </ul>
                </div>

                <h4>전술적 포메이션</h4>
                <div class="step-guide">
                    <h5>게임플레이 향상:</h5>
                    <ul>
                        <li><strong>군집 이동</strong>: 다수의 로봇이 자연스럽게 이동</li>
                        <li><strong>전투 포메이션</strong>: 적과의 거리에 따른 배치 조정</li>
                        <li><strong>작업 효율성</strong>: 리소스 수집 시 최적 배치</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <h3>📌 주요 변경 파일</h3>
                <ul class="content-list">
                    <li><strong>AbstractUnit.cs</strong>: AgentRadius 프로퍼티 추가</li>
                    <li><strong>PlayerInput.cs</strong>: MoveUnitsInFormation 메서드 구현</li>
                    <li><strong>HandleRightClick</strong>: 원형 배치 로직으로 교체</li>
                </ul>
            </div>

            <div class="content-section">
                <h3>🚀 다음 단계</h3>
                <ul class="content-list">
                    <li>다양한 포메이션 패턴 구현 (사각형, 삼각형 등)</li>
                    <li>적과의 거리에 따른 동적 포메이션 조정</li>
                    <li>유닛 타입별 특화 배치 시스템</li>
                    <li>성능 최적화를 위한 포메이션 캐싱</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- 강의 20: Multiple NavMeshes (다중 네비메시) -->
    <div class="lecture-section">
        <h2 class="lecture-title">🎯 강의 20: Multiple NavMeshes (다중 네비메시)</h2>
        
        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>다중 NavMesh Surface를 사용한 다양한 유닛 타입 지원</li>
                <li>Air Unit과 Ground Unit의 독립적인 네비게이션 시스템</li>
                <li>NavMesh Obstacle의 한계와 해결 방법</li>
                <li>Agent Type 설정과 Layer Collision Matrix 활용</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>
            <ul class="content-list">
                <li><strong>Multiple NavMesh Surfaces</strong>: 같은 씬에 여러 개의 독립적인 NavMesh</li>
                <li><strong>Agent Types</strong>: Humanoid, Air Units 등 다양한 에이전트 타입</li>
                <li><strong>Layer Separation</strong>: TransparentFX 레이어를 활용한 물리 충돌 방지</li>
                <li><strong>Height Separation</strong>: Y축 높이 차이로 NavMesh 격리</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>💻 구현 과정</h3>
            
            <div class="step-guide">
                <h5>1단계: Air Unit Floor 생성</h5>
                <ol>
                    <li>Floor 하위에 Empty GameObject 생성 → "Air Unit Floor"</li>
                    <li>Box Collider 추가 (Size: X=96, Z=128)</li>
                    <li>Y 위치를 1.26으로 설정 (장애물 위로)</li>
                    <li>Layer를 TransparentFX로 변경</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>2단계: Air Units Agent Type 생성</h5>
                <ol>
                    <li>Window → AI → Navigation 열기</li>
                    <li>Agent Types 탭에서 "Air Units" 추가</li>
                    <li>기본 설정 유지 (Radius: 0.5, Height: 2, Speed: 3.5)</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>3단계: 두 번째 NavMesh Surface 추가</h5>
                <ol>
                    <li>Floor에 NavMesh Surface 컴포넌트 추가</li>
                    <li>Agent Type을 "Air Units"로 설정</li>
                    <li>Layer Mask를 "TransparentFX"만 선택</li>
                    <li>Bake 실행</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>4단계: Physics Settings 조정</h5>
                <ol>
                    <li>Edit → Project Settings → Physics</li>
                    <li>Layer Collision Matrix에서 TransparentFX 체크 해제</li>
                    <li>모든 레이어와의 충돌 비활성화</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🔧 Unity 설정 변경사항</h3>
            
            <div class="code-block">// Floor GameObject에 추가된 컴포넌트
NavMesh Surface (Air Units용)
- Agent Type: Air Units (-1372625422)
- Collect Objects: Volume
- Size: {x: 96.29, y: 7.025, z: 127.91}
- Center: {x: -0.1419, y: 3.48, z: 0.178}
- Layer Mask: TransparentFX (2)</div>

            <div class="code-block">// Air Transport 설정
NavMeshAgent:
- Agent Type: Air Units
- Obstacle Avoidance: No Obstacle Avoidance
- Height: 2 (기본값)</div>
        </div>

        <div class="content-section">
            <h3>❓ 왜 필요한가?</h3>
            
            <div class="tech-stack">
                <h4>🎯 NavMesh Obstacle의 한계</h4>
                <p><strong>문제점</strong>: NavMesh Obstacle은 모든 NavMesh를 자동으로 carve합니다.</p>
                <p><strong>해결책</strong>: NavMesh Modifier는 특정 Agent Type만 영향을 받지만, 런타임에는 변경 불가능합니다.</p>
            </div>

            <div class="tech-stack">
                <h4>🚁 Air Unit의 특수 요구사항</h4>
                <p><strong>비행 유닛</strong>: 물, 미네랄, 가스 위를 자유롭게 날아야 함</p>
                <p><strong>Ground Unit</strong>: 장애물을 피해서 돌아다녀야 함</p>
                <p><strong>충돌 방지</strong>: 서로 다른 높이의 NavMesh로 격리</p>
            </div>

            <div class="tech-stack">
                <h4>⚙️ Layer Collision Matrix 활용</h4>
                <p><strong>TransparentFX 레이어</strong>: 물리 충돌에 영향 없이 NavMesh Bake만 가능</p>
                <p><strong>Y축 분리</strong>: Air Unit Floor를 높은 위치에 배치하여 독립성 확보</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎮 노바1492 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>다양한 로봇 타입</strong>: 지상형, 공중형, 수중형 로봇의 독립적인 네비게이션</li>
                <li><strong>3D 전장</strong>: 높이 차이를 활용한 입체적인 전투 시스템</li>
                <li><strong>전략적 깊이</strong>: 공중 유닛의 우위와 지상 유닛의 제약</li>
                <li><strong>성능 최적화</strong>: 각 유닛 타입별 최적화된 NavMesh 설정</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>🚀 다음 단계</h3>
            <ul class="content-list">
                <li>수중 유닛을 위한 세 번째 NavMesh Surface 추가</li>
                <li>Agent Type별 특화된 이동 속도와 회전 속도 설정</li>
                <li>다층 NavMesh 간의 경로 찾기 최적화</li>
                <li>동적 NavMesh 생성 시스템 구현</li>
            </ul>
        </div>
    </div>

    <!-- 강의 21: Our First Building - The Supply Hut (첫 번째 건물 - 공급소) -->
    <div class="lecture-section">
        <h2 class="lecture-title">🏗️ 강의 21: Our First Building - The Supply Hut (첫 번째 건물 - 공급소)</h2>
        
        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>첫 번째 건물 시스템 구현 (Supply Hut)</li>
                <li>ISelectable 인터페이스를 활용한 건물 선택 시스템</li>
                <li>Property Fields와 Access Modifiers 활용</li>
                <li>NavMesh Obstacle을 통한 건물 통과 방지</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>
            <ul class="content-list">
                <li><strong>Building System</strong>: 유닛과 구분되는 건물 시스템</li>
                <li><strong>ISelectable Interface</strong>: 건물도 선택 가능하도록 구현</li>
                <li><strong>Property Fields</strong>: Health를 안전하게 관리하는 프로퍼티</li>
                <li><strong>NavMesh Obstacle</strong>: 건물을 통과할 수 없도록 하는 장애물</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>💻 구현 과정</h3>
            
            <div class="step-guide">
                <h5>1단계: SupplyHut 클래스 생성</h5>
                <ol>
                    <li>MonoBehaviour 스크립트 생성 → "SupplyHut"</li>
                    <li>ISelectable 인터페이스 구현</li>
                    <li>DecalProjector와 Health 필드 추가</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>2단계: 클래스 멤버 변수 설정</h5>
                <ol>
                    <li>DecalProjector: [SerializeField] private</li>
                    <li>Health: Property Field with private set</li>
                    <li>적절한 Access Modifiers 적용</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>3단계: 선택/해제 로직 구현</h5>
                <ol>
                    <li>Select(): DecalProjector 활성화 + UnitSelectedEvent 발생</li>
                    <li>Deselect(): DecalProjector 비활성화 + UnitDeselectedEvent 발생</li>
                    <li>Event Bus를 통한 이벤트 통신</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>4단계: Unity Prefab 설정</h5>
                <ol>
                    <li>Supply Hut Prefab에 SupplyHut 스크립트 연결</li>
                    <li>DecalProjector GameObject 생성 및 설정</li>
                    <li>NavMesh Obstacle 컴포넌트 추가</li>
                    <li>Buildings 레이어로 이동</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🔧 핵심 코드</h3>
            
            <div class="code-block">// SupplyHut.cs - 첫 번째 건물 클래스
using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;
using UnityEngine;
using UnityEngine.Rendering.Universal;

namespace GameDevTV.RTS.Units
{
    public class SupplyHut : MonoBehaviour, ISelectable
    {
        [SerializeField] private DecalProjector decalProjector;
        [field: SerializeField] public int Health { get; private set; }

        public void Deselect()
        {
            if (decalProjector != null)
            {
                decalProjector.gameObject.SetActive(false);
            }
            Bus<UnitDeselectedEvent>.Raise(new UnitDeselectedEvent(this));
        }

        public void Select()
        {
            if (decalProjector != null)
            {
                decalProjector.gameObject.SetActive(true);
            }
            Bus<UnitSelectedEvent>.Raise(new UnitSelectedEvent(this));
        }
    }
}</div>
        </div>

        <div class="content-section">
            <h3>❓ 왜 필요한가?</h3>
            
            <div class="tech-stack">
                <h4>🏗️ 건물 시스템의 필요성</h4>
                <p><strong>RTS 게임의 핵심</strong>: 유닛뿐만 아니라 건물도 선택하고 관리할 수 있어야 함</p>
                <p><strong>전략적 깊이</strong>: 건물 배치와 관리가 게임의 중요한 요소</p>
                <p><strong>확장성</strong>: 다양한 건물 타입을 추가할 수 있는 기반 구조</p>
            </div>

            <div class="tech-stack">
                <h4>🔒 Property Fields의 장점</h4>
                <p><strong>캡슐화</strong>: Health를 직접 수정할 수 없도록 보호</p>
                <p><strong>Inspector 표시</strong>: [field: SerializeField]로 Inspector에서 확인 가능</p>
                <p><strong>안전성</strong>: private set으로 내부에서만 수정 가능</p>
            </div>

            <div class="tech-stack">
                <h4>🚧 NavMesh Obstacle의 역할</h4>
                <p><strong>통과 방지</strong>: 유닛이 건물을 통과하지 못하도록 차단</p>
                <p><strong>현실성</strong>: 건물이 실제 장애물 역할을 하도록 구현</p>
                <p><strong>전략적 요소</strong>: 건물 배치가 유닛 이동에 영향을 미침</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎮 노바1492 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>로봇 생산 건물</strong>: 다양한 로봇을 생산하는 공장 시스템</li>
                <li><strong>리소스 건물</strong>: 에너지와 부품을 생산하는 발전소</li>
                <li><strong>방어 건물</strong>: 적의 공격을 막는 방어 시설</li>
                <li><strong>연구 건물</strong>: 새로운 기술을 개발하는 연구소</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>🚀 다음 단계</h3>
            <ul class="content-list">
                <li>건물 건설 시스템 구현</li>
                <li>건물별 고유 기능 추가</li>
                <li>건물 업그레이드 시스템</li>
                <li>건물 파괴 및 수리 시스템</li>
            </ul>
        </div>
    </div>

    <!-- 강의 22: Unifying Interactions with Buildings & Units (건물과 유닛 상호작용 통합) -->
    <div class="lecture-section">
        <h2 class="lecture-title">🔗 강의 22: Unifying Interactions with Buildings & Units (건물과 유닛 상호작용 통합)</h2>
        
        <div class="lecture-goal">
            <h3>🎯 학습 목표</h3>
            <ul class="content-list">
                <li>AbstractCommandable 클래스를 통한 코드 중복 제거</li>
                <li>유닛과 건물의 공통 기능을 상위 클래스로 리프트</li>
                <li>상속 계층 구조 최적화 및 확장성 향상</li>
                <li>DRY (Don't Repeat Yourself) 원칙 적용</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>📝 핵심 개념</h3>
            <ul class="content-list">
                <li><strong>AbstractCommandable</strong>: 유닛과 건물의 공통 기반 클래스</li>
                <li><strong>Code Refactoring</strong>: 중복 코드를 상위 클래스로 이동</li>
                <li><strong>Inheritance Hierarchy</strong>: 명확한 상속 계층 구조 구축</li>
                <li><strong>DRY Principle</strong>: 코드 중복을 최소화하는 설계 원칙</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>💻 구현 과정</h3>
            
            <div class="step-guide">
                <h5>1단계: AbstractCommandable 클래스 생성</h5>
                <ol>
                    <li>MonoBehaviour를 상속받는 추상 클래스 생성</li>
                    <li>ISelectable 인터페이스 구현</li>
                    <li>공통 필드와 메서드 정의</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>2단계: 공통 기능 리프트</h5>
                <ol>
                    <li>DecalProjector: 선택 시각적 피드백</li>
                    <li>Health: Property Field로 안전한 관리</li>
                    <li>Select/Deselect: 이벤트 발생 로직</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>3단계: 기존 클래스 리팩토링</h5>
                <ol>
                    <li>AbstractUnit: AbstractCommandable 상속</li>
                    <li>SupplyHut: AbstractCommandable 상속</li>
                    <li>중복 코드 제거 및 상속 구조 정리</li>
                </ol>
            </div>

            <div class="step-guide">
                <h5>4단계: 상속 계층 구조 최적화</h5>
                <ol>
                    <li>AbstractCommandable: 공통 기반</li>
                    <li>AbstractUnit: 유닛 전용 기능 (NavMeshAgent)</li>
                    <li>SupplyHut: 건물 전용 기능</li>
                </ol>
            </div>
        </div>

        <div class="content-section">
            <h3>🔧 핵심 코드</h3>
            
            <div class="code-block">// AbstractCommandable.cs - 공통 기반 클래스
using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;
using UnityEngine;
using UnityEngine.Rendering.Universal;

namespace GameDevTV.RTS.Units
{
    public abstract class AbstractCommandable : MonoBehaviour, ISelectable
    {
        [SerializeField] private DecalProjector decalProjector;
        [field: SerializeField] public int Health { get; private set; }

        public void Select()
        {
            if (decalProjector != null)
            {
                decalProjector.gameObject.SetActive(true);
            }
            Bus<UnitSelectedEvent>.Raise(new UnitSelectedEvent(this));
        }

        public void Deselect()
        {
            if (decalProjector != null)
            {
                decalProjector.gameObject.SetActive(false);
            }
            Bus<UnitDeselectedEvent>.Raise(new UnitDeselectedEvent(this));
        }
    }
}</div>

            <div class="code-block">// AbstractUnit.cs - 유닛 전용 클래스
using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;
using UnityEngine;
using UnityEngine.AI;

namespace GameDevTV.RTS.Units
{
    [RequireComponent(typeof(NavMeshAgent))]
    public abstract class AbstractUnit : AbstractCommandable, IMoveable
    {
        public float AgentRadius => agent.radius;
        private NavMeshAgent agent;

        protected virtual void Awake()
        {
            agent = GetComponent<NavMeshAgent>();
        }

        private void Start()
        {
            Bus<UnitSpawnEvent>.Raise(new UnitSpawnEvent(this));
        }

        public void MoveTo(Vector3 position)
        {
            agent.SetDestination(position);
        }
    }
}</div>

            <div class="code-block">// SupplyHut.cs - 건물 클래스 (간소화됨)
using GameDevTV.RTS.EventBus;
using GameDevTV.RTS.Events;
using UnityEngine;

namespace GameDevTV.RTS.Units
{
    public class SupplyHut : AbstractCommandable
    {
        // 공통 기능은 AbstractCommandable에서 상속
        // 건물 전용 기능만 여기에 추가
    }
}</div>
        </div>

        <div class="content-section">
            <h3>❓ 왜 필요한가?</h3>
            
            <div class="tech-stack">
                <h4>🔄 코드 중복 제거</h4>
                <p><strong>DRY 원칙</strong>: 같은 코드를 여러 곳에 작성하지 않음</p>
                <p><strong>유지보수성</strong>: 한 곳에서 수정하면 모든 곳에 적용</p>
                <p><strong>일관성</strong>: 동일한 동작이 모든 클래스에서 보장</p>
            </div>

            <div class="tech-stack">
                <h4>🏗️ 확장성 향상</h4>
                <p><strong>새로운 건물 타입</strong>: AbstractCommandable만 상속하면 됨</p>
                <p><strong>새로운 유닛 타입</strong>: AbstractUnit만 상속하면 됨</p>
                <p><strong>공통 기능 추가</strong>: 상위 클래스에만 추가하면 모든 하위 클래스에 적용</p>
            </div>

            <div class="tech-stack">
                <h4>🎯 명확한 책임 분리</h4>
                <p><strong>AbstractCommandable</strong>: 선택 가능한 모든 객체의 공통 기능</p>
                <p><strong>AbstractUnit</strong>: 이동 가능한 유닛의 전용 기능</p>
                <p><strong>SupplyHut</strong>: 건물만의 고유 기능</p>
            </div>
        </div>

        <div class="content-section">
            <h3>🎮 노바1492 적용 포인트</h3>
            <ul class="content-list">
                <li><strong>로봇 생산 건물</strong>: AbstractCommandable 상속으로 일관된 선택 시스템</li>
                <li><strong>다양한 로봇 타입</strong>: AbstractUnit 상속으로 공통 이동 시스템</li>
                <li><strong>방어 건물</strong>: AbstractCommandable 상속으로 공통 방어 시스템</li>
                <li><strong>연구 건물</strong>: AbstractCommandable 상속으로 공통 연구 시스템</li>
            </ul>
        </div>

        <div class="content-section">
            <h3>🚀 다음 단계</h3>
            <ul class="content-list">
                <li>더 많은 건물 타입 추가</li>
                <li>건물별 고유 기능 구현</li>
                <li>건물 건설 시스템 개발</li>
                <li>건물 업그레이드 시스템 구현</li>
            </ul>
        </div>
    </div>

</body>
</html>